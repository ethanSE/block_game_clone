/*! For license information please see 8fbbc819351e3920a627.bundle.js.LICENSE.txt */
(() => {
  var e, t, n = { 254: (e, t) => { "use strict"; Symbol.for("react.element"), Symbol.for("react.portal"), Symbol.for("react.fragment"), Symbol.for("react.strict_mode"), Symbol.for("react.profiler"), Symbol.for("react.provider"), Symbol.for("react.context"), Symbol.for("react.server_context"), Symbol.for("react.forward_ref"), Symbol.for("react.suspense"), Symbol.for("react.suspense_list"), Symbol.for("react.memo"), Symbol.for("react.lazy"), Symbol.for("react.offscreen"); Symbol.for("react.module.reference") }, 2: (e, t, n) => { "use strict"; n(254) }, 171: (e, t, n) => { "use strict"; n.d(t, { A: () => s }); var r = n(601), i = n.n(r), a = n(314), o = n.n(a)()(i()); o.push([e.id, "*{margin:0;padding:0;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none}.BeCqZtLIiWUTyIUfMEao{height:100%;display:flex;flex-direction:column}", ""]), o.locals = { app: "BeCqZtLIiWUTyIUfMEao" }; const s = o }, 820: (e, t, n) => { "use strict"; n.d(t, { A: () => s }); var r = n(601), i = n.n(r), a = n(314), o = n.n(a)()(i()); o.push([e.id, "._yN9ER9S7JYA3jGaJiBc{flex:1;width:100%;display:flex;flex-direction:column}.KkzqHhBkcLfLOnAaGl6Y{flex:1}", ""]), o.locals = { canvasContainer: "_yN9ER9S7JYA3jGaJiBc", canvasSection: "KkzqHhBkcLfLOnAaGl6Y" }; const s = o }, 518: (e, t, n) => { "use strict"; n.d(t, { A: () => s }); var r = n(601), i = n.n(r), a = n(314), o = n.n(a)()(i()); o.push([e.id, ".WmmRjqXSm5qTgevR5UMk{position:fixed;top:40px;height:calc(100% - 40px);box-sizing:border-box;width:100%;display:flex;flex-direction:column;justify-content:space-between;pointer-events:none}.EJauJhPj_PFHNnqqAktf{flex:1;width:100%;display:flex;flex-direction:row;align-items:center;justify-content:space-between;pointer-events:auto}.AzCwyptmWCEZC4mDClaf{pointer-events:none;flex:1;width:100%;display:flex;flex-direction:column;justify-content:flex-end}._hCTPRwWoYr_CmCvCDvl{pointer-events:auto;margin:5px;z-index:2;height:50px;width:70px}.W3E5m9i5XQ42SH8wep8B{align-self:center;display:flex;flex-direction:row;align-items:center}.lOpw8GorHHHCtVN7tv6P{display:flex;flex-direction:row;align-items:center}", ""]), o.locals = { controlsContainer: "WmmRjqXSm5qTgevR5UMk", topControls: "EJauJhPj_PFHNnqqAktf", bottomControls: "AzCwyptmWCEZC4mDClaf", button: "_hCTPRwWoYr_CmCvCDvl", scoreContainer: "W3E5m9i5XQ42SH8wep8B", scoreRow: "lOpw8GorHHHCtVN7tv6P" }; const s = o }, 593: (e, t, n) => { "use strict"; n.d(t, { A: () => s }); var r = n(601), i = n.n(r), a = n(314), o = n.n(a)()(i()); o.push([e.id, ".leCDgNc0pUVPl17wHlBS{height:100%;display:flex;flex-direction:column;background-color:gray}.HIgvEVMrEfp8K4HNseg9{flex-grow:1;position:relative}.hCHNLEiyjWONM_NkK5Ip{height:fit-content;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:space-around;padding:10px}.Lm0W5fUqLPZdjrMdsu18{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:space-evenly}.FqOCTjY3R75IOuXZe5gX{width:125px;height:40px;margin:5px;border-radius:5px}", ""]), o.locals = { menu: "leCDgNc0pUVPl17wHlBS", menuDemoContainer: "HIgvEVMrEfp8K4HNseg9", menuOptionsContainer: "hCHNLEiyjWONM_NkK5Ip", mapSelector: "Lm0W5fUqLPZdjrMdsu18", button: "FqOCTjY3R75IOuXZe5gX" }; const s = o }, 535: (e, t, n) => { "use strict"; n.d(t, { A: () => s }); var r = n(601), i = n.n(r), a = n(314), o = n.n(a)()(i()); o.push([e.id, ".su_m66EpnvmZP6f5py4m{background-color:gray;width:auto;overflow:hidden;padding:5px;display:flex;flex-direction:column;pointer-events:auto;position:fixed;bottom:0;box-sizing:border-box}.qwQTUJrtHffGi_gKWd9t{pointer-events:none;height:100%;width:auto;overflow:hidden;display:grid;align-items:stretch;justify-items:stretch;grid-template-columns:repeat(4, 1fr);grid-template-rows:repeat(3, 1fr);padding:5px;gap:5px;box-sizing:border-box;border-radius:10px}.lpmckIdJVZC_E3EhrVNs{background-color:navy}.UwbvCaPdEJqSL2HBcS1x{background-color:green}.QhJErGXohVGjn3LWn6n6{object-fit:contain;min-width:0px;min-height:0px;max-width:100%;max-height:100%;border-radius:10px;pointer-events:auto;box-sizing:border-box}.ZMISDE6ry1LSLFIfbxq9{cursor:pointer;background-color:teal}.f0mZ9iLPVJcOFqvXrz0o{background-color:gray}", ""]), o.locals = { pieceSelectorContainer: "su_m66EpnvmZP6f5py4m", pieceGroup: "qwQTUJrtHffGi_gKWd9t", p1: "lpmckIdJVZC_E3EhrVNs qwQTUJrtHffGi_gKWd9t", p2: "UwbvCaPdEJqSL2HBcS1x qwQTUJrtHffGi_gKWd9t", piece: "QhJErGXohVGjn3LWn6n6", available: "ZMISDE6ry1LSLFIfbxq9 QhJErGXohVGjn3LWn6n6", unavailable: "f0mZ9iLPVJcOFqvXrz0o QhJErGXohVGjn3LWn6n6" }; const s = o }, 702: (e, t, n) => { "use strict"; n.d(t, { A: () => s }); var r = n(601), i = n.n(r), a = n(314), o = n.n(a)()(i()); o.push([e.id, ".UW9jRpBlxFGBRujN6jmz{width:100vw;display:flex;flex-direction:row;justify-content:space-between;align-items:center}", ""]), o.locals = { topBarContainer: "UW9jRpBlxFGBRujN6jmz" }; const s = o }, 314: e => { "use strict"; e.exports = function (e) { var t = []; return t.toString = function () { return this.map((function (t) { var n = "", r = void 0 !== t[5]; return t[4] && (n += "@supports (".concat(t[4], ") {")), t[2] && (n += "@media ".concat(t[2], " {")), r && (n += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")), n += e(t), r && (n += "}"), t[2] && (n += "}"), t[4] && (n += "}"), n })).join("") }, t.i = function (e, n, r, i, a) { "string" == typeof e && (e = [[null, e, void 0]]); var o = {}; if (r) for (var s = 0; s < this.length; s++) { var l = this[s][0]; null != l && (o[l] = !0) } for (var c = 0; c < e.length; c++) { var u = [].concat(e[c]); r && o[u[0]] || (void 0 !== a && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = a), n && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = n) : u[2] = n), i && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = i) : u[4] = "".concat(i)), t.push(u)) } }, t } }, 601: e => { "use strict"; e.exports = function (e) { return e[1] } }, 334: e => { function t(e, t, n) { var r, i, a, o, s; function l() { var c = Date.now() - o; c < t && c >= 0 ? r = setTimeout(l, t - c) : (r = null, n || (s = e.apply(a, i), a = i = null)) } null == t && (t = 100); var c = function () { a = this, i = arguments, o = Date.now(); var c = n && !r; return r || (r = setTimeout(l, t)), c && (s = e.apply(a, i), a = i = null), s }; return c.clear = function () { r && (clearTimeout(r), r = null) }, c.flush = function () { r && (s = e.apply(a, i), a = i = null, clearTimeout(r), r = null) }, c } t.debounce = t, e.exports = t }, 146: (e, t, n) => { "use strict"; var r = n(404), i = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, a = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, o = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, s = {}; function l(e) { return r.isMemo(e) ? o : s[e.$$typeof] || i } s[r.ForwardRef] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, s[r.Memo] = o; var c = Object.defineProperty, u = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, h = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, f = Object.prototype; e.exports = function e(t, n, r) { if ("string" != typeof n) { if (f) { var i = p(n); i && i !== f && e(t, i, r) } var o = u(n); d && (o = o.concat(d(n))); for (var s = l(t), m = l(n), g = 0; g < o.length; ++g) { var v = o[g]; if (!(a[v] || r && r[v] || m && m[v] || s && s[v])) { var y = h(n, v); try { c(t, v, y) } catch (e) { } } } } return t } }, 691: (e, t) => { "use strict"; var n = "function" == typeof Symbol && Symbol.for, r = n ? Symbol.for("react.element") : 60103, i = n ? Symbol.for("react.portal") : 60106, a = n ? Symbol.for("react.fragment") : 60107, o = n ? Symbol.for("react.strict_mode") : 60108, s = n ? Symbol.for("react.profiler") : 60114, l = n ? Symbol.for("react.provider") : 60109, c = n ? Symbol.for("react.context") : 60110, u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111, h = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, f = n ? Symbol.for("react.suspense_list") : 60120, m = n ? Symbol.for("react.memo") : 60115, g = n ? Symbol.for("react.lazy") : 60116, v = n ? Symbol.for("react.block") : 60121, y = n ? Symbol.for("react.fundamental") : 60117, b = n ? Symbol.for("react.responder") : 60118, x = n ? Symbol.for("react.scope") : 60119; function A(e) { if ("object" == typeof e && null !== e) { var t = e.$$typeof; switch (t) { case r: switch (e = e.type) { case u: case d: case a: case s: case o: case p: return e; default: switch (e = e && e.$$typeof) { case c: case h: case g: case m: case l: return e; default: return t } }case i: return t } } } function S(e) { return A(e) === d } t.AsyncMode = u, t.ConcurrentMode = d, t.ContextConsumer = c, t.ContextProvider = l, t.Element = r, t.ForwardRef = h, t.Fragment = a, t.Lazy = g, t.Memo = m, t.Portal = i, t.Profiler = s, t.StrictMode = o, t.Suspense = p, t.isAsyncMode = function (e) { return S(e) || A(e) === u }, t.isConcurrentMode = S, t.isContextConsumer = function (e) { return A(e) === c }, t.isContextProvider = function (e) { return A(e) === l }, t.isElement = function (e) { return "object" == typeof e && null !== e && e.$$typeof === r }, t.isForwardRef = function (e) { return A(e) === h }, t.isFragment = function (e) { return A(e) === a }, t.isLazy = function (e) { return A(e) === g }, t.isMemo = function (e) { return A(e) === m }, t.isPortal = function (e) { return A(e) === i }, t.isProfiler = function (e) { return A(e) === s }, t.isStrictMode = function (e) { return A(e) === o }, t.isSuspense = function (e) { return A(e) === p }, t.isValidElementType = function (e) { return "string" == typeof e || "function" == typeof e || e === a || e === d || e === s || e === o || e === p || e === f || "object" == typeof e && null !== e && (e.$$typeof === g || e.$$typeof === m || e.$$typeof === l || e.$$typeof === c || e.$$typeof === h || e.$$typeof === y || e.$$typeof === b || e.$$typeof === x || e.$$typeof === v) }, t.typeOf = A }, 404: (e, t, n) => { "use strict"; e.exports = n(691) }, 551: (e, t, n) => { "use strict"; var r = n(540), i = n(194); function a(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var o = new Set, s = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (s[e] = t, e = 0; e < t.length; e++)o.add(t[e]) } var u = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, p = {}, f = {}; function m(e, t, n, r, i, a, o) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = a, this.removeEmptyString = o } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var v = /[\-:]([a-z])/g; function y(e) { return e[1].toUpperCase() } function b(e, t, n, r) { var i = g.hasOwnProperty(t) ? g[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null == t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!d.call(f, e) || !d.call(p, e) && (h.test(e) ? f[e] = !0 : (p[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var x = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, A = Symbol.for("react.element"), S = Symbol.for("react.portal"), M = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), _ = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), C = Symbol.for("react.context"), T = Symbol.for("react.forward_ref"), R = Symbol.for("react.suspense"), B = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), P = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var L = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var D = Symbol.iterator; function k(e) { return null === e || "object" != typeof e ? null : "function" == typeof (e = D && e[D] || e["@@iterator"]) ? e : null } var N, F = Object.assign; function O(e) { if (void 0 === N) try { throw Error() } catch (e) { var t = e.stack.trim().match(/\n( *(at )?)/); N = t && t[1] || "" } return "\n" + N + e } var U = !1; function z(e, t) { if (!e || U) return ""; U = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" == typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (e) { var r = e } Reflect.construct(e, [], t) } else { try { t.call() } catch (e) { r = e } e.call(t.prototype) } else { try { throw Error() } catch (e) { r = e } e() } } catch (t) { if (t && r && "string" == typeof t.stack) { for (var i = t.stack.split("\n"), a = r.stack.split("\n"), o = i.length - 1, s = a.length - 1; 1 <= o && 0 <= s && i[o] !== a[s];)s--; for (; 1 <= o && 0 <= s; o--, s--)if (i[o] !== a[s]) { if (1 !== o || 1 !== s) do { if (o--, 0 > --s || i[o] !== a[s]) { var l = "\n" + i[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= o && 0 <= s); break } } } finally { U = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? O(e) : "" } function H(e) { switch (e.tag) { case 5: return O(e.type); case 16: return O("Lazy"); case 13: return O("Suspense"); case 19: return O("SuspenseList"); case 0: case 2: case 15: return z(e.type, !1); case 11: return z(e.type.render, !1); case 1: return z(e.type, !0); default: return "" } } function G(e) { if (null == e) return null; if ("function" == typeof e) return e.displayName || e.name || null; if ("string" == typeof e) return e; switch (e) { case M: return "Fragment"; case S: return "Portal"; case _: return "Profiler"; case w: return "StrictMode"; case R: return "Suspense"; case B: return "SuspenseList" }if ("object" == typeof e) switch (e.$$typeof) { case C: return (e.displayName || "Context") + ".Consumer"; case E: return (e._context.displayName || "Context") + ".Provider"; case T: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case I: return null !== (t = e.displayName || null) ? t : G(e.type) || "Memo"; case P: t = e._payload, e = e._init; try { return G(e(t)) } catch (e) { } }return null } function j(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return G(t); case 8: return t === w ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" == typeof t) return t.displayName || t.name || null; if ("string" == typeof t) return t }return null } function V(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function W(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function X(e) { e._valueTracker || (e._valueTracker = function (e) { var t = W(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) { var i = n.get, a = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, a.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function J(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = W(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function Y(e) { if (void 0 === (e = e || ("undefined" != typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function Q(e, t) { var n = t.checked; return F({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function K(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = V(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function q(e, t) { null != (t = t.checked) && b(e, "checked", t, !1) } function Z(e, t) { q(e, t); var n = V(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, V(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function $(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && Y(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + V(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(a(91)); return F({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(a(92)); if (te(n)) { if (1 < n.length) throw Error(a(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: V(n) } } function ae(e, t) { var n = V(t.value), r = V(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function oe(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function se(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function he(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var pe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, fe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" == typeof t || "" === t ? "" : n || "number" != typeof t || 0 === t || pe.hasOwnProperty(e) && pe[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = me(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(pe).forEach((function (e) { fe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), pe[t] = pe[e] })) })); var ve = F({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ye(e, t) { if (t) { if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(a(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(a(60)); if ("object" != typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(a(61)) } if (null != t.style && "object" != typeof t.style) throw Error(a(62)) } } function be(e, t) { if (-1 === e.indexOf("-")) return "string" == typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var xe = null; function Ae(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var Se = null, Me = null, we = null; function _e(e) { if (e = bi(e)) { if ("function" != typeof Se) throw Error(a(280)); var t = e.stateNode; t && (t = Ai(t), Se(e.stateNode, e.type, t)) } } function Ee(e) { Me ? we ? we.push(e) : we = [e] : Me = e } function Ce() { if (Me) { var e = Me, t = we; if (we = Me = null, _e(e), t) for (e = 0; e < t.length; e++)_e(t[e]) } } function Te(e, t) { return e(t) } function Re() { } var Be = !1; function Ie(e, t, n) { if (Be) return e(t, n); Be = !0; try { return Te(e, t, n) } finally { Be = !1, (null !== Me || null !== we) && (Re(), Ce()) } } function Pe(e, t) { var n = e.stateNode; if (null === n) return null; var r = Ai(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" != typeof n) throw Error(a(231, t, typeof n)); return n } var Le = !1; if (u) try { var De = {}; Object.defineProperty(De, "passive", { get: function () { Le = !0 } }), window.addEventListener("test", De, De), window.removeEventListener("test", De, De) } catch (ue) { Le = !1 } function ke(e, t, n, r, i, a, o, s, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (e) { this.onError(e) } } var Ne = !1, Fe = null, Oe = !1, Ue = null, ze = { onError: function (e) { Ne = !0, Fe = e } }; function He(e, t, n, r, i, a, o, s, l) { Ne = !1, Fe = null, ke.apply(ze, arguments) } function Ge(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { !!(4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function je(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && null !== (e = e.alternate) && (t = e.memoizedState), null !== t) return t.dehydrated } return null } function Ve(e) { if (Ge(e) !== e) throw Error(a(188)) } function We(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = Ge(e))) throw Error(a(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var o = i.alternate; if (null === o) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return Ve(i), e; if (o === r) return Ve(i), t; o = o.sibling } throw Error(a(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, l = i.child; l;) { if (l === n) { s = !0, n = i, r = o; break } if (l === r) { s = !0, r = i, n = o; break } l = l.sibling } if (!s) { for (l = o.child; l;) { if (l === n) { s = !0, n = o, r = i; break } if (l === r) { s = !0, r = o, n = i; break } l = l.sibling } if (!s) throw Error(a(189)) } } if (n.alternate !== r) throw Error(a(190)) } if (3 !== n.tag) throw Error(a(188)); return n.stateNode.current === n ? e : t }(e)) ? Xe(e) : null } function Xe(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Xe(e); if (null !== t) return t; e = e.sibling } return null } var Je = i.unstable_scheduleCallback, Ye = i.unstable_cancelCallback, Qe = i.unstable_shouldYield, Ke = i.unstable_requestPaint, qe = i.unstable_now, Ze = i.unstable_getCurrentPriorityLevel, $e = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, at = null, ot = Math.clz32 ? Math.clz32 : function (e) { return 0 === (e >>>= 0) ? 32 : 31 - (st(e) / lt | 0) | 0 }, st = Math.log, lt = Math.LN2, ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ht(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, a = e.pingedLanes, o = 268435455 & n; if (0 !== o) { var s = o & ~i; 0 !== s ? r = dt(s) : 0 != (a &= o) && (r = dt(a)) } else 0 != (o = n & ~i) ? r = dt(o) : 0 !== a && (r = dt(a)); if (0 === r) return 0; if (0 !== t && t !== r && !(t & i) && ((i = r & -r) >= (a = t & -t) || 16 === i && 4194240 & a)) return t; if (4 & r && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - ot(t)), r |= e[n], t &= ~i; return r } function pt(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function ft(e) { return 0 != (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return !(4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function vt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - ot(t)] = n } function yt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - ot(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var bt = 0; function xt(e) { return 1 < (e &= -e) ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1 } var At, St, Mt, wt, _t, Et = !1, Ct = [], Tt = null, Rt = null, Bt = null, It = new Map, Pt = new Map, Lt = [], Dt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function kt(e, t) { switch (e) { case "focusin": case "focusout": Tt = null; break; case "dragenter": case "dragleave": Rt = null; break; case "mouseover": case "mouseout": Bt = null; break; case "pointerover": case "pointerout": It.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Pt.delete(t.pointerId) } } function Nt(e, t, n, r, i, a) { return null === e || e.nativeEvent !== a ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: a, targetContainers: [i] }, null !== t && null !== (t = bi(t)) && St(t), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function Ft(e) { var t = yi(e.target); if (null !== t) { var n = Ge(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = je(n))) return e.blockedOn = t, void _t(e.priority, (function () { Mt(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function Ot(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Qt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = bi(n)) && St(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); xe = r, n.target.dispatchEvent(r), xe = null, t.shift() } return !0 } function Ut(e, t, n) { Ot(e) && n.delete(t) } function zt() { Et = !1, null !== Tt && Ot(Tt) && (Tt = null), null !== Rt && Ot(Rt) && (Rt = null), null !== Bt && Ot(Bt) && (Bt = null), It.forEach(Ut), Pt.forEach(Ut) } function Ht(e, t) { e.blockedOn === t && (e.blockedOn = null, Et || (Et = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, zt))) } function Gt(e) { function t(t) { return Ht(t, e) } if (0 < Ct.length) { Ht(Ct[0], e); for (var n = 1; n < Ct.length; n++) { var r = Ct[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== Tt && Ht(Tt, e), null !== Rt && Ht(Rt, e), null !== Bt && Ht(Bt, e), It.forEach(t), Pt.forEach(t), n = 0; n < Lt.length; n++)(r = Lt[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Lt.length && null === (n = Lt[0]).blockedOn;)Ft(n), null === n.blockedOn && Lt.shift() } var jt = x.ReactCurrentBatchConfig, Vt = !0; function Wt(e, t, n, r) { var i = bt, a = jt.transition; jt.transition = null; try { bt = 1, Jt(e, t, n, r) } finally { bt = i, jt.transition = a } } function Xt(e, t, n, r) { var i = bt, a = jt.transition; jt.transition = null; try { bt = 4, Jt(e, t, n, r) } finally { bt = i, jt.transition = a } } function Jt(e, t, n, r) { if (Vt) { var i = Qt(e, t, n, r); if (null === i) Vr(e, t, r, Yt, n), kt(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return Tt = Nt(Tt, e, t, n, r, i), !0; case "dragenter": return Rt = Nt(Rt, e, t, n, r, i), !0; case "mouseover": return Bt = Nt(Bt, e, t, n, r, i), !0; case "pointerover": var a = i.pointerId; return It.set(a, Nt(It.get(a) || null, e, t, n, r, i)), !0; case "gotpointercapture": return a = i.pointerId, Pt.set(a, Nt(Pt.get(a) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (kt(e, r), 4 & t && -1 < Dt.indexOf(e)) { for (; null !== i;) { var a = bi(i); if (null !== a && At(a), null === (a = Qt(e, t, n, r)) && Vr(e, t, r, Yt, n), a === i) break; i = a } null !== i && r.stopPropagation() } else Vr(e, t, r, null, n) } } var Yt = null; function Qt(e, t, n, r) { if (Yt = null, null !== (e = yi(e = Ae(r)))) if (null === (t = Ge(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = je(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Yt = e, null } function Kt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Ze()) { case $e: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var qt = null, Zt = null, $t = null; function en() { if ($t) return $t; var e, t, n = Zt, r = n.length, i = "value" in qt ? qt.value : qt.textContent, a = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var o = r - e; for (t = 1; t <= o && n[r - t] === i[a - t]; t++); return $t = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function an(e) { function t(t, n, r, i, a) { for (var o in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = a, this.currentTarget = null, e) e.hasOwnProperty(o) && (t = e[o], this[o] = t ? t(i) : i[o]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return F(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" != typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" != typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var on, sn, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = an(cn), dn = F({}, cn, { view: 0, detail: 0 }), hn = an(dn), pn = F({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: _n, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (on = e.screenX - ln.screenX, sn = e.screenY - ln.screenY) : sn = on = 0, ln = e), on) }, movementY: function (e) { return "movementY" in e ? e.movementY : sn } }), fn = an(pn), mn = an(F({}, pn, { dataTransfer: 0 })), gn = an(F({}, dn, { relatedTarget: 0 })), vn = an(F({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), yn = F({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), bn = an(yn), xn = an(F({}, cn, { data: 0 })), An = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Sn = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Mn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function wn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = Mn[e]) && !!t[e] } function _n() { return wn } var En = F({}, dn, { key: function (e) { if (e.key) { var t = An[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Sn[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: _n, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), Cn = an(En), Tn = an(F({}, pn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Rn = an(F({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: _n })), Bn = an(F({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), In = F({}, pn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Pn = an(In), Ln = [9, 13, 27, 32], Dn = u && "CompositionEvent" in window, kn = null; u && "documentMode" in document && (kn = document.documentMode); var Nn = u && "TextEvent" in window && !kn, Fn = u && (!Dn || kn && 8 < kn && 11 >= kn), On = String.fromCharCode(32), Un = !1; function zn(e, t) { switch (e) { case "keyup": return -1 !== Ln.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Hn(e) { return "object" == typeof (e = e.detail) && "data" in e ? e.data : null } var Gn = !1, jn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Vn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!jn[e.type] : "textarea" === t } function Wn(e, t, n, r) { Ee(r), 0 < (t = Xr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Xn = null, Jn = null; function Yn(e) { Or(e, 0) } function Qn(e) { if (J(xi(e))) return e } function Kn(e, t) { if ("change" === e) return t } var qn = !1; if (u) { var Zn; if (u) { var $n = "oninput" in document; if (!$n) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), $n = "function" == typeof er.oninput } Zn = $n } else Zn = !1; qn = Zn && (!document.documentMode || 9 < document.documentMode) } function tr() { Xn && (Xn.detachEvent("onpropertychange", nr), Jn = Xn = null) } function nr(e) { if ("value" === e.propertyName && Qn(Jn)) { var t = []; Wn(t, Jn, e, Ae(e)), Ie(Yn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), Jn = n, (Xn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Qn(Jn) } function ar(e, t) { if ("click" === e) return Qn(t) } function or(e, t) { if ("input" === e || "change" === e) return Qn(t) } var sr = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }; function lr(e, t) { if (sr(e, t)) return !0; if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!d.call(t, i) || !sr(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function dr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hr() { for (var e = window, t = Y(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" == typeof t.contentWindow.location.href } catch (e) { n = !1 } if (!n) break; t = Y((e = t.contentWindow).document) } return t } function pr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function fr(e) { var t = hr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) { if (null !== r && pr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, a = Math.min(r.start, i); r = void 0 === r.end ? a : Math.min(r.end, i), !e.extend && a > r && (i = r, r = a, a = i), i = ur(n, a); var o = ur(n, r); i && o && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), a > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" == typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, vr = null, yr = null, br = !1; function xr(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; br || null == gr || gr !== Y(r) || (r = "selectionStart" in (r = gr) && pr(r) ? { start: r.selectionStart, end: r.selectionEnd } : { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, yr && lr(yr, r) || (yr = r, 0 < (r = Xr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = gr))) } function Ar(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Sr = { animationend: Ar("Animation", "AnimationEnd"), animationiteration: Ar("Animation", "AnimationIteration"), animationstart: Ar("Animation", "AnimationStart"), transitionend: Ar("Transition", "TransitionEnd") }, Mr = {}, wr = {}; function _r(e) { if (Mr[e]) return Mr[e]; if (!Sr[e]) return e; var t, n = Sr[e]; for (t in n) if (n.hasOwnProperty(t) && t in wr) return Mr[e] = n[t]; return e } u && (wr = document.createElement("div").style, "AnimationEvent" in window || (delete Sr.animationend.animation, delete Sr.animationiteration.animation, delete Sr.animationstart.animation), "TransitionEvent" in window || delete Sr.transitionend.transition); var Er = _r("animationend"), Cr = _r("animationiteration"), Tr = _r("animationstart"), Rr = _r("transitionend"), Br = new Map, Ir = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Pr(e, t) { Br.set(e, t), l(t, [e]) } for (var Lr = 0; Lr < Ir.length; Lr++) { var Dr = Ir[Lr]; Pr(Dr.toLowerCase(), "on" + (Dr[0].toUpperCase() + Dr.slice(1))) } Pr(Er, "onAnimationEnd"), Pr(Cr, "onAnimationIteration"), Pr(Tr, "onAnimationStart"), Pr("dblclick", "onDoubleClick"), Pr("focusin", "onFocus"), Pr("focusout", "onBlur"), Pr(Rr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var kr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Nr = new Set("cancel close invalid load scroll toggle".split(" ").concat(kr)); function Fr(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, o, s, l, c) { if (He.apply(this, arguments), Ne) { if (!Ne) throw Error(a(198)); var u = Fe; Ne = !1, Fe = null, Oe || (Oe = !0, Ue = u) } }(r, t, void 0, e), e.currentTarget = null } function Or(e, t) { t = !!(4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var a = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var s = r[o], l = s.instance, c = s.currentTarget; if (s = s.listener, l !== a && i.isPropagationStopped()) break e; Fr(i, s, c), a = l } else for (o = 0; o < r.length; o++) { if (l = (s = r[o]).instance, c = s.currentTarget, s = s.listener, l !== a && i.isPropagationStopped()) break e; Fr(i, s, c), a = l } } } if (Oe) throw e = Ue, Oe = !1, Ue = null, e } function Ur(e, t) { var n = t[mi]; void 0 === n && (n = t[mi] = new Set); var r = e + "__bubble"; n.has(r) || (jr(t, e, 2, !1), n.add(r)) } function zr(e, t, n) { var r = 0; t && (r |= 4), jr(n, e, r, t) } var Hr = "_reactListening" + Math.random().toString(36).slice(2); function Gr(e) { if (!e[Hr]) { e[Hr] = !0, o.forEach((function (t) { "selectionchange" !== t && (Nr.has(t) || zr(t, !1, e), zr(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Hr] || (t[Hr] = !0, zr("selectionchange", !1, t)) } } function jr(e, t, n, r) { switch (Kt(t)) { case 1: var i = Wt; break; case 4: i = Xt; break; default: i = Jt }n = i.bind(null, t, n, e), i = void 0, !Le || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Vr(e, t, n, r, i) { var a = r; if (!(1 & t || 2 & t || null === r)) e: for (; ;) { if (null === r) return; var o = r.tag; if (3 === o || 4 === o) { var s = r.stateNode.containerInfo; if (s === i || 8 === s.nodeType && s.parentNode === i) break; if (4 === o) for (o = r.return; null !== o;) { var l = o.tag; if ((3 === l || 4 === l) && ((l = o.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; o = o.return } for (; null !== s;) { if (null === (o = yi(s))) return; if (5 === (l = o.tag) || 6 === l) { r = a = o; continue e } s = s.parentNode } } r = r.return } Ie((function () { var r = a, i = Ae(n), o = []; e: { var s = Br.get(e); if (void 0 !== s) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = Cn; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = fn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = Rn; break; case Er: case Cr: case Tr: l = vn; break; case Rr: l = Bn; break; case "scroll": l = hn; break; case "wheel": l = Pn; break; case "copy": case "cut": case "paste": l = bn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = Tn }var u = !!(4 & t), d = !u && "scroll" === e, h = u ? null !== s ? s + "Capture" : null : s; u = []; for (var p, f = r; null !== f;) { var m = (p = f).stateNode; if (5 === p.tag && null !== m && (p = m, null !== h && null != (m = Pe(f, h)) && u.push(Wr(f, m, p))), d) break; f = f.return } 0 < u.length && (s = new l(s, c, null, n, i), o.push({ event: s, listeners: u })) } } if (!(7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(s = "mouseover" === e || "pointerover" === e) || n === xe || !(c = n.relatedTarget || n.fromElement) || !yi(c) && !c[fi]) && (l || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? yi(c) : null) && (c !== (d = Ge(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = fn, m = "onMouseLeave", h = "onMouseEnter", f = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Tn, m = "onPointerLeave", h = "onPointerEnter", f = "pointer"), d = null == l ? s : xi(l), p = null == c ? s : xi(c), (s = new u(m, f + "leave", l, n, i)).target = d, s.relatedTarget = p, m = null, yi(i) === r && ((u = new u(h, f + "enter", c, n, i)).target = p, u.relatedTarget = d, m = u), d = m, l && c) e: { for (h = c, f = 0, p = u = l; p; p = Jr(p))f++; for (p = 0, m = h; m; m = Jr(m))p++; for (; 0 < f - p;)u = Jr(u), f--; for (; 0 < p - f;)h = Jr(h), p--; for (; f--;) { if (u === h || null !== h && u === h.alternate) break e; u = Jr(u), h = Jr(h) } u = null } else u = null; null !== l && Yr(o, s, l, u, !1), null !== c && null !== d && Yr(o, d, c, u, !0) } if ("select" === (l = (s = r ? xi(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === l && "file" === s.type) var g = Kn; else if (Vn(s)) if (qn) g = or; else { g = ir; var v = rr } else (l = s.nodeName) && "input" === l.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (g = ar); switch (g && (g = g(e, r)) ? Wn(o, g, n, i) : (v && v(e, s, r), "focusout" === e && (v = s._wrapperState) && v.controlled && "number" === s.type && ee(s, "number", s.value)), v = r ? xi(r) : window, e) { case "focusin": (Vn(v) || "true" === v.contentEditable) && (gr = v, vr = r, yr = null); break; case "focusout": yr = vr = gr = null; break; case "mousedown": br = !0; break; case "contextmenu": case "mouseup": case "dragend": br = !1, xr(o, n, i); break; case "selectionchange": if (mr) break; case "keydown": case "keyup": xr(o, n, i) }var y; if (Dn) e: { switch (e) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else Gn ? zn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart"); b && (Fn && "ko" !== n.locale && (Gn || "onCompositionStart" !== b ? "onCompositionEnd" === b && Gn && (y = en()) : (Zt = "value" in (qt = i) ? qt.value : qt.textContent, Gn = !0)), 0 < (v = Xr(r, b)).length && (b = new xn(b, e, null, n, i), o.push({ event: b, listeners: v }), (y || null !== (y = Hn(n))) && (b.data = y))), (y = Nn ? function (e, t) { switch (e) { case "compositionend": return Hn(t); case "keypress": return 32 !== t.which ? null : (Un = !0, On); case "textInput": return (e = t.data) === On && Un ? null : e; default: return null } }(e, n) : function (e, t) { if (Gn) return "compositionend" === e || !Dn && zn(e, t) ? (e = en(), $t = Zt = qt = null, Gn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Fn && "ko" !== t.locale ? null : t.data } }(e, n)) && 0 < (r = Xr(r, "onBeforeInput")).length && (i = new xn("onBeforeInput", "beforeinput", null, n, i), o.push({ event: i, listeners: r }), i.data = y) } Or(o, t) })) } function Wr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Xr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, a = i.stateNode; 5 === i.tag && null !== a && (i = a, null != (a = Pe(e, n)) && r.unshift(Wr(e, a, i)), null != (a = Pe(e, t)) && r.push(Wr(e, a, i))), e = e.return } return r } function Jr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Yr(e, t, n, r, i) { for (var a = t._reactName, o = []; null !== n && n !== r;) { var s = n, l = s.alternate, c = s.stateNode; if (null !== l && l === r) break; 5 === s.tag && null !== c && (s = c, i ? null != (l = Pe(n, a)) && o.unshift(Wr(n, l, s)) : i || null != (l = Pe(n, a)) && o.push(Wr(n, l, s))), n = n.return } 0 !== o.length && e.push({ event: t, listeners: o }) } var Qr = /\r\n?/g, Kr = /\u0000|\uFFFD/g; function qr(e) { return ("string" == typeof e ? e : "" + e).replace(Qr, "\n").replace(Kr, "") } function Zr(e, t, n) { if (t = qr(t), qr(e) !== t && n) throw Error(a(425)) } function $r() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" == typeof t.children || "number" == typeof t.children || "object" == typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" == typeof setTimeout ? setTimeout : void 0, ii = "function" == typeof clearTimeout ? clearTimeout : void 0, ai = "function" == typeof Promise ? Promise : void 0, oi = "function" == typeof queueMicrotask ? queueMicrotask : void 0 !== ai ? function (e) { return ai.resolve(null).then(e).catch(si) } : ri; function si(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void Gt(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); Gt(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var di = Math.random().toString(36).slice(2), hi = "__reactFiber$" + di, pi = "__reactProps$" + di, fi = "__reactContainer$" + di, mi = "__reactEvents$" + di, gi = "__reactListeners$" + di, vi = "__reactHandles$" + di; function yi(e) { var t = e[hi]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[fi] || n[hi]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[hi]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function bi(e) { return !(e = e[hi] || e[fi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function xi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(a(33)) } function Ai(e) { return e[pi] || null } var Si = [], Mi = -1; function wi(e) { return { current: e } } function _i(e) { 0 > Mi || (e.current = Si[Mi], Si[Mi] = null, Mi--) } function Ei(e, t) { Mi++, Si[Mi] = e.current, e.current = t } var Ci = {}, Ti = wi(Ci), Ri = wi(!1), Bi = Ci; function Ii(e, t) { var n = e.type.contextTypes; if (!n) return Ci; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, a = {}; for (i in n) a[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = a), a } function Pi(e) { return null != e.childContextTypes } function Li() { _i(Ri), _i(Ti) } function Di(e, t, n) { if (Ti.current !== Ci) throw Error(a(168)); Ei(Ti, t), Ei(Ri, n) } function ki(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" != typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(a(108, j(e) || "Unknown", i)); return F({}, n, r) } function Ni(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ci, Bi = Ti.current, Ei(Ti, e), Ei(Ri, Ri.current), !0 } function Fi(e, t, n) { var r = e.stateNode; if (!r) throw Error(a(169)); n ? (e = ki(e, t, Bi), r.__reactInternalMemoizedMergedChildContext = e, _i(Ri), _i(Ti), Ei(Ti, e)) : _i(Ri), Ei(Ri, n) } var Oi = null, Ui = !1, zi = !1; function Hi(e) { null === Oi ? Oi = [e] : Oi.push(e) } function Gi() { if (!zi && null !== Oi) { zi = !0; var e = 0, t = bt; try { var n = Oi; for (bt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Oi = null, Ui = !1 } catch (t) { throw null !== Oi && (Oi = Oi.slice(e + 1)), Je($e, Gi), t } finally { bt = t, zi = !1 } } return null } var ji = [], Vi = 0, Wi = null, Xi = 0, Ji = [], Yi = 0, Qi = null, Ki = 1, qi = ""; function Zi(e, t) { ji[Vi++] = Xi, ji[Vi++] = Wi, Wi = e, Xi = t } function $i(e, t, n) { Ji[Yi++] = Ki, Ji[Yi++] = qi, Ji[Yi++] = Qi, Qi = e; var r = Ki; e = qi; var i = 32 - ot(r) - 1; r &= ~(1 << i), n += 1; var a = 32 - ot(t) + i; if (30 < a) { var o = i - i % 5; a = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Ki = 1 << 32 - ot(t) + i | n << i | r, qi = a + e } else Ki = 1 << a | n << i | r, qi = e } function ea(e) { null !== e.return && (Zi(e, 1), $i(e, 1, 0)) } function ta(e) { for (; e === Wi;)Wi = ji[--Vi], ji[Vi] = null, Xi = ji[--Vi], ji[Vi] = null; for (; e === Qi;)Qi = Ji[--Yi], Ji[Yi] = null, qi = Ji[--Yi], Ji[Yi] = null, Ki = Ji[--Yi], Ji[Yi] = null } var na = null, ra = null, ia = !1, aa = null; function oa(e, t) { var n = Pc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function sa(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, na = e, ra = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, na = e, ra = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Qi ? { id: Ki, overflow: qi } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Pc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, na = e, ra = null, !0); default: return !1 } } function la(e) { return !(!(1 & e.mode) || 128 & e.flags) } function ca(e) { if (ia) { var t = ra; if (t) { var n = t; if (!sa(e, t)) { if (la(e)) throw Error(a(418)); t = ci(n.nextSibling); var r = na; t && sa(e, t) ? oa(r, n) : (e.flags = -4097 & e.flags | 2, ia = !1, na = e) } } else { if (la(e)) throw Error(a(418)); e.flags = -4097 & e.flags | 2, ia = !1, na = e } } } function ua(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; na = e } function da(e) { if (e !== na) return !1; if (!ia) return ua(e), ia = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ra)) { if (la(e)) throw ha(), Error(a(418)); for (; t;)oa(e, t), t = ci(t.nextSibling) } if (ua(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(a(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { ra = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } ra = null } } else ra = na ? ci(e.stateNode.nextSibling) : null; return !0 } function ha() { for (var e = ra; e;)e = ci(e.nextSibling) } function pa() { ra = na = null, ia = !1 } function fa(e) { null === aa ? aa = [e] : aa.push(e) } var ma = x.ReactCurrentBatchConfig; function ga(e, t) { if (e && e.defaultProps) { for (var n in t = F({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var va = wi(null), ya = null, ba = null, xa = null; function Aa() { xa = ba = ya = null } function Sa(e) { var t = va.current; _i(va), e._currentValue = t } function Ma(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function wa(e, t) { ya = e, xa = ba = null, null !== (e = e.dependencies) && null !== e.firstContext && (!!(e.lanes & t) && (xs = !0), e.firstContext = null) } function _a(e) { var t = e._currentValue; if (xa !== e) if (e = { context: e, memoizedValue: t, next: null }, null === ba) { if (null === ya) throw Error(a(308)); ba = e, ya.dependencies = { lanes: 0, firstContext: e } } else ba = ba.next = e; return t } var Ea = null; function Ca(e) { null === Ea ? Ea = [e] : Ea.push(e) } function Ta(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, Ca(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ra(e, r) } function Ra(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var Ba = !1; function Ia(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Pa(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function La(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Da(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 2 & Rl) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ra(e, n) } return null === (i = r.interleaved) ? (t.next = t, Ca(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ra(e, n) } function ka(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } function Na(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, a = null; if (null !== (n = n.firstBaseUpdate)) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === a ? i = a = o : a = a.next = o, n = n.next } while (null !== n); null === a ? i = a = t : a = a.next = t } else i = a = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: a, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Fa(e, t, n, r) { var i = e.updateQueue; Ba = !1; var a = i.firstBaseUpdate, o = i.lastBaseUpdate, s = i.shared.pending; if (null !== s) { i.shared.pending = null; var l = s, c = l.next; l.next = null, null === o ? a = c : o.next = c, o = l; var u = e.alternate; null !== u && (s = (u = u.updateQueue).lastBaseUpdate) !== o && (null === s ? u.firstBaseUpdate = c : s.next = c, u.lastBaseUpdate = l) } if (null !== a) { var d = i.baseState; for (o = 0, u = c = l = null, s = a; ;) { var h = s.lane, p = s.eventTime; if ((r & h) === h) { null !== u && (u = u.next = { eventTime: p, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null }); e: { var f = e, m = s; switch (h = t, p = n, m.tag) { case 1: if ("function" == typeof (f = m.payload)) { d = f.call(p, d, h); break e } d = f; break e; case 3: f.flags = -65537 & f.flags | 128; case 0: if (null == (h = "function" == typeof (f = m.payload) ? f.call(p, d, h) : f)) break e; d = F({}, d, h); break e; case 2: Ba = !0 } } null !== s.callback && 0 !== s.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [s] : h.push(s)) } else p = { eventTime: p, lane: h, tag: s.tag, payload: s.payload, callback: s.callback, next: null }, null === u ? (c = u = p, l = d) : u = u.next = p, o |= h; if (null === (s = s.next)) { if (null === (s = i.shared.pending)) break; s = (h = s).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { o |= i.lane, i = i.next } while (i !== t) } else null === a && (i.shared.lanes = 0); Fl |= o, e.lanes = o, e.memoizedState = d } } function Oa(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" != typeof i) throw Error(a(191, i)); i.call(r) } } } var Ua = (new r.Component).refs; function za(e, t, n, r) { n = null == (n = n(r, t = e.memoizedState)) ? t : F({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var Ha = { isMounted: function (e) { return !!(e = e._reactInternals) && Ge(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), a = La(r, i); a.payload = t, null != n && (a.callback = n), null !== (t = Da(e, a, i)) && (rc(t, e, i, r), ka(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), a = La(r, i); a.tag = 1, a.payload = t, null != n && (a.callback = n), null !== (t = Da(e, a, i)) && (rc(t, e, i, r), ka(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tc(), r = nc(e), i = La(n, r); i.tag = 2, null != t && (i.callback = t), null !== (t = Da(e, i, r)) && (rc(t, e, r, n), ka(t, e, r)) } }; function Ga(e, t, n, r, i, a, o) { return "function" == typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, a, o) : !(t.prototype && t.prototype.isPureReactComponent && lr(n, r) && lr(i, a)) } function ja(e, t, n) { var r = !1, i = Ci, a = t.contextType; return "object" == typeof a && null !== a ? a = _a(a) : (i = Pi(t) ? Bi : Ti.current, a = (r = null != (r = t.contextTypes)) ? Ii(e, i) : Ci), t = new t(n, a), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Ha, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = a), t } function Va(e, t, n, r) { e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Ha.enqueueReplaceState(t, t.state, null) } function Wa(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = Ua, Ia(e); var a = t.contextType; "object" == typeof a && null !== a ? i.context = _a(a) : (a = Pi(t) ? Bi : Ti.current, i.context = Ii(e, a)), i.state = e.memoizedState, "function" == typeof (a = t.getDerivedStateFromProps) && (za(e, t, a, n), i.state = e.memoizedState), "function" == typeof t.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (t = i.state, "function" == typeof i.componentWillMount && i.componentWillMount(), "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Ha.enqueueReplaceState(i, i.state, null), Fa(e, n, i, r), i.state = e.memoizedState), "function" == typeof i.componentDidMount && (e.flags |= 4194308) } function Xa(e, t, n) { if (null !== (e = n.ref) && "function" != typeof e && "object" != typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(a(309)); var r = n.stateNode } if (!r) throw Error(a(147, e)); var i = r, o = "" + e; return null !== t && null !== t.ref && "function" == typeof t.ref && t.ref._stringRef === o ? t.ref : (t = function (e) { var t = i.refs; t === Ua && (t = i.refs = {}), null === e ? delete t[o] : t[o] = e }, t._stringRef = o, t) } if ("string" != typeof e) throw Error(a(284)); if (!n._owner) throw Error(a(290, e)) } return e } function Ja(e, t) { throw e = Object.prototype.toString.call(t), Error(a(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Ya(e) { return (0, e._init)(e._payload) } function Qa(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Dc(e, t)).index = 0, e.sibling = null, e } function o(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function s(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = Oc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var a = n.type; return a === M ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === a || "object" == typeof a && null !== a && a.$$typeof === P && Ya(a) === t.type) ? ((r = i(t, n.props)).ref = Xa(e, t, n), r.return = e, r) : ((r = kc(n.type, n.key, n.props, null, e.mode, r)).ref = Xa(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Uc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function d(e, t, n, r, a) { return null === t || 7 !== t.tag ? ((t = Nc(n, e.mode, r, a)).return = e, t) : ((t = i(t, n)).return = e, t) } function h(e, t, n) { if ("string" == typeof t && "" !== t || "number" == typeof t) return (t = Oc("" + t, e.mode, n)).return = e, t; if ("object" == typeof t && null !== t) { switch (t.$$typeof) { case A: return (n = kc(t.type, t.key, t.props, null, e.mode, n)).ref = Xa(e, null, t), n.return = e, n; case S: return (t = Uc(t, e.mode, n)).return = e, t; case P: return h(e, (0, t._init)(t._payload), n) }if (te(t) || k(t)) return (t = Nc(t, e.mode, n, null)).return = e, t; Ja(e, t) } return null } function p(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" == typeof n && "" !== n || "number" == typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" == typeof n && null !== n) { switch (n.$$typeof) { case A: return n.key === i ? c(e, t, n, r) : null; case S: return n.key === i ? u(e, t, n, r) : null; case P: return p(e, t, (i = n._init)(n._payload), r) }if (te(n) || k(n)) return null !== i ? null : d(e, t, n, r, null); Ja(e, n) } return null } function f(e, t, n, r, i) { if ("string" == typeof r && "" !== r || "number" == typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" == typeof r && null !== r) { switch (r.$$typeof) { case A: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case S: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case P: return f(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || k(r)) return d(t, e = e.get(n) || null, r, i, null); Ja(t, r) } return null } function m(i, a, s, l) { for (var c = null, u = null, d = a, m = a = 0, g = null; null !== d && m < s.length; m++) { d.index > m ? (g = d, d = null) : g = d.sibling; var v = p(i, d, s[m], l); if (null === v) { null === d && (d = g); break } e && d && null === v.alternate && t(i, d), a = o(v, a, m), null === u ? c = v : u.sibling = v, u = v, d = g } if (m === s.length) return n(i, d), ia && Zi(i, m), c; if (null === d) { for (; m < s.length; m++)null !== (d = h(i, s[m], l)) && (a = o(d, a, m), null === u ? c = d : u.sibling = d, u = d); return ia && Zi(i, m), c } for (d = r(i, d); m < s.length; m++)null !== (g = f(d, i, m, s[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), a = o(g, a, m), null === u ? c = g : u.sibling = g, u = g); return e && d.forEach((function (e) { return t(i, e) })), ia && Zi(i, m), c } function g(i, s, l, c) { var u = k(l); if ("function" != typeof u) throw Error(a(150)); if (null == (l = u.call(l))) throw Error(a(151)); for (var d = u = null, m = s, g = s = 0, v = null, y = l.next(); null !== m && !y.done; g++, y = l.next()) { m.index > g ? (v = m, m = null) : v = m.sibling; var b = p(i, m, y.value, c); if (null === b) { null === m && (m = v); break } e && m && null === b.alternate && t(i, m), s = o(b, s, g), null === d ? u = b : d.sibling = b, d = b, m = v } if (y.done) return n(i, m), ia && Zi(i, g), u; if (null === m) { for (; !y.done; g++, y = l.next())null !== (y = h(i, y.value, c)) && (s = o(y, s, g), null === d ? u = y : d.sibling = y, d = y); return ia && Zi(i, g), u } for (m = r(i, m); !y.done; g++, y = l.next())null !== (y = f(m, i, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key), s = o(y, s, g), null === d ? u = y : d.sibling = y, d = y); return e && m.forEach((function (e) { return t(i, e) })), ia && Zi(i, g), u } return function e(r, a, o, l) { if ("object" == typeof o && null !== o && o.type === M && null === o.key && (o = o.props.children), "object" == typeof o && null !== o) { switch (o.$$typeof) { case A: e: { for (var c = o.key, u = a; null !== u;) { if (u.key === c) { if ((c = o.type) === M) { if (7 === u.tag) { n(r, u.sibling), (a = i(u, o.props.children)).return = r, r = a; break e } } else if (u.elementType === c || "object" == typeof c && null !== c && c.$$typeof === P && Ya(c) === u.type) { n(r, u.sibling), (a = i(u, o.props)).ref = Xa(r, u, o), a.return = r, r = a; break e } n(r, u); break } t(r, u), u = u.sibling } o.type === M ? ((a = Nc(o.props.children, r.mode, l, o.key)).return = r, r = a) : ((l = kc(o.type, o.key, o.props, null, r.mode, l)).ref = Xa(r, a, o), l.return = r, r = l) } return s(r); case S: e: { for (u = o.key; null !== a;) { if (a.key === u) { if (4 === a.tag && a.stateNode.containerInfo === o.containerInfo && a.stateNode.implementation === o.implementation) { n(r, a.sibling), (a = i(a, o.children || [])).return = r, r = a; break e } n(r, a); break } t(r, a), a = a.sibling } (a = Uc(o, r.mode, l)).return = r, r = a } return s(r); case P: return e(r, a, (u = o._init)(o._payload), l) }if (te(o)) return m(r, a, o, l); if (k(o)) return g(r, a, o, l); Ja(r, o) } return "string" == typeof o && "" !== o || "number" == typeof o ? (o = "" + o, null !== a && 6 === a.tag ? (n(r, a.sibling), (a = i(a, o)).return = r, r = a) : (n(r, a), (a = Oc(o, r.mode, l)).return = r, r = a), s(r)) : n(r, a) } } var Ka = Qa(!0), qa = Qa(!1), Za = {}, $a = wi(Za), eo = wi(Za), to = wi(Za); function no(e) { if (e === Za) throw Error(a(174)); return e } function ro(e, t) { switch (Ei(to, t), Ei(eo, e), Ei($a, Za), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }_i($a), Ei($a, t) } function io() { _i($a), _i(eo), _i(to) } function ao(e) { no(to.current); var t = no($a.current), n = le(t, e.type); t !== n && (Ei(eo, e), Ei($a, n)) } function oo(e) { eo.current === e && (_i($a), _i(eo)) } var so = wi(0); function lo(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (128 & t.flags) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var co = []; function uo() { for (var e = 0; e < co.length; e++)co[e]._workInProgressVersionPrimary = null; co.length = 0 } var ho = x.ReactCurrentDispatcher, po = x.ReactCurrentBatchConfig, fo = 0, mo = null, go = null, vo = null, yo = !1, bo = !1, xo = 0, Ao = 0; function So() { throw Error(a(321)) } function Mo(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!sr(e[n], t[n])) return !1; return !0 } function wo(e, t, n, r, i, o) { if (fo = o, mo = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ho.current = null === e || null === e.memoizedState ? ss : ls, e = n(r, i), bo) { o = 0; do { if (bo = !1, xo = 0, 25 <= o) throw Error(a(301)); o += 1, vo = go = null, t.updateQueue = null, ho.current = cs, e = n(r, i) } while (bo) } if (ho.current = os, t = null !== go && null !== go.next, fo = 0, vo = go = mo = null, yo = !1, t) throw Error(a(300)); return e } function _o() { var e = 0 !== xo; return xo = 0, e } function Eo() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === vo ? mo.memoizedState = vo = e : vo = vo.next = e, vo } function Co() { if (null === go) { var e = mo.alternate; e = null !== e ? e.memoizedState : null } else e = go.next; var t = null === vo ? mo.memoizedState : vo.next; if (null !== t) vo = t, go = e; else { if (null === e) throw Error(a(310)); e = { memoizedState: (go = e).memoizedState, baseState: go.baseState, baseQueue: go.baseQueue, queue: go.queue, next: null }, null === vo ? mo.memoizedState = vo = e : vo = vo.next = e } return vo } function To(e, t) { return "function" == typeof t ? t(e) : t } function Ro(e) { var t = Co(), n = t.queue; if (null === n) throw Error(a(311)); n.lastRenderedReducer = e; var r = go, i = r.baseQueue, o = n.pending; if (null !== o) { if (null !== i) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (null !== i) { o = i.next, r = r.baseState; var l = s = null, c = null, u = o; do { var d = u.lane; if ((fo & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, s = r) : c = c.next = h, mo.lanes |= d, Fl |= d } u = u.next } while (null !== u && u !== o); null === c ? s = r : c.next = l, sr(r, t.memoizedState) || (xs = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { o = i.lane, mo.lanes |= o, Fl |= o, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Bo(e) { var t = Co(), n = t.queue; if (null === n) throw Error(a(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (null !== i) { n.pending = null; var s = i = i.next; do { o = e(o, s.action), s = s.next } while (s !== i); sr(o, t.memoizedState) || (xs = !0), t.memoizedState = o, null === t.baseQueue && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function Io() { } function Po(e, t) { var n = mo, r = Co(), i = t(), o = !sr(r.memoizedState, i); if (o && (r.memoizedState = i, xs = !0), r = r.queue, Vo(ko.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || null !== vo && 1 & vo.memoizedState.tag) { if (n.flags |= 2048, Uo(9, Do.bind(null, n, r, i, t), void 0, null), null === Bl) throw Error(a(349)); 30 & fo || Lo(n, t, i) } return i } function Lo(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = mo.updateQueue) ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Do(e, t, n, r) { t.value = n, t.getSnapshot = r, No(t) && Fo(e) } function ko(e, t, n) { return n((function () { No(t) && Fo(e) })) } function No(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !sr(e, n) } catch (e) { return !0 } } function Fo(e) { var t = Ra(e, 1); null !== t && rc(t, e, 1, -1) } function Oo(e) { var t = Eo(); return "function" == typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: To, lastRenderedState: e }, t.queue = e, e = e.dispatch = ns.bind(null, mo, e), [t.memoizedState, e] } function Uo(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = mo.updateQueue) ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function zo() { return Co().memoizedState } function Ho(e, t, n, r) { var i = Eo(); mo.flags |= e, i.memoizedState = Uo(1 | t, n, void 0, void 0 === r ? null : r) } function Go(e, t, n, r) { var i = Co(); r = void 0 === r ? null : r; var a = void 0; if (null !== go) { var o = go.memoizedState; if (a = o.destroy, null !== r && Mo(r, o.deps)) return void (i.memoizedState = Uo(t, n, a, r)) } mo.flags |= e, i.memoizedState = Uo(1 | t, n, a, r) } function jo(e, t) { return Ho(8390656, 8, e, t) } function Vo(e, t) { return Go(2048, 8, e, t) } function Wo(e, t) { return Go(4, 2, e, t) } function Xo(e, t) { return Go(4, 4, e, t) } function Jo(e, t) { return "function" == typeof t ? (e = e(), t(e), function () { t(null) }) : null != t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Yo(e, t, n) { return n = null != n ? n.concat([e]) : null, Go(4, 4, Jo.bind(null, t, e), n) } function Qo() { } function Ko(e, t) { var n = Co(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && Mo(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function qo(e, t) { var n = Co(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && Mo(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Zo(e, t, n) { return 21 & fo ? (sr(n, t) || (n = mt(), mo.lanes |= n, Fl |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, xs = !0), e.memoizedState = n) } function $o(e, t) { var n = bt; bt = 0 !== n && 4 > n ? n : 4, e(!0); var r = po.transition; po.transition = {}; try { e(!1), t() } finally { bt = n, po.transition = r } } function es() { return Co().memoizedState } function ts(e, t, n) { var r = nc(e); n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, rs(e) ? is(t, n) : null !== (n = Ta(e, t, n, r)) && (rc(n, e, r, tc()), as(n, t, r)) } function ns(e, t, n) { var r = nc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (rs(e)) is(t, i); else { var a = e.alternate; if (0 === e.lanes && (null === a || 0 === a.lanes) && null !== (a = t.lastRenderedReducer)) try { var o = t.lastRenderedState, s = a(o, n); if (i.hasEagerState = !0, i.eagerState = s, sr(s, o)) { var l = t.interleaved; return null === l ? (i.next = i, Ca(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (e) { } null !== (n = Ta(e, t, i, r)) && (rc(n, e, r, i = tc()), as(n, t, r)) } } function rs(e) { var t = e.alternate; return e === mo || null !== t && t === mo } function is(e, t) { bo = yo = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function as(e, t, n) { if (4194240 & n) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } var os = { readContext: _a, useCallback: So, useContext: So, useEffect: So, useImperativeHandle: So, useInsertionEffect: So, useLayoutEffect: So, useMemo: So, useReducer: So, useRef: So, useState: So, useDebugValue: So, useDeferredValue: So, useTransition: So, useMutableSource: So, useSyncExternalStore: So, useId: So, unstable_isNewReconciler: !1 }, ss = { readContext: _a, useCallback: function (e, t) { return Eo().memoizedState = [e, void 0 === t ? null : t], e }, useContext: _a, useEffect: jo, useImperativeHandle: function (e, t, n) { return n = null != n ? n.concat([e]) : null, Ho(4194308, 4, Jo.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Ho(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Ho(4, 2, e, t) }, useMemo: function (e, t) { var n = Eo(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Eo(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = ts.bind(null, mo, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, Eo().memoizedState = e }, useState: Oo, useDebugValue: Qo, useDeferredValue: function (e) { return Eo().memoizedState = e }, useTransition: function () { var e = Oo(!1), t = e[0]; return e = $o.bind(null, e[1]), Eo().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = mo, i = Eo(); if (ia) { if (void 0 === n) throw Error(a(407)); n = n() } else { if (n = t(), null === Bl) throw Error(a(349)); 30 & fo || Lo(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, jo(ko.bind(null, r, o, e), [e]), r.flags |= 2048, Uo(9, Do.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = Eo(), t = Bl.identifierPrefix; if (ia) { var n = qi; t = ":" + t + "R" + (n = (Ki & ~(1 << 32 - ot(Ki) - 1)).toString(32) + n), 0 < (n = xo++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = Ao++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, ls = { readContext: _a, useCallback: Ko, useContext: _a, useEffect: Vo, useImperativeHandle: Yo, useInsertionEffect: Wo, useLayoutEffect: Xo, useMemo: qo, useReducer: Ro, useRef: zo, useState: function () { return Ro(To) }, useDebugValue: Qo, useDeferredValue: function (e) { return Zo(Co(), go.memoizedState, e) }, useTransition: function () { return [Ro(To)[0], Co().memoizedState] }, useMutableSource: Io, useSyncExternalStore: Po, useId: es, unstable_isNewReconciler: !1 }, cs = { readContext: _a, useCallback: Ko, useContext: _a, useEffect: Vo, useImperativeHandle: Yo, useInsertionEffect: Wo, useLayoutEffect: Xo, useMemo: qo, useReducer: Bo, useRef: zo, useState: function () { return Bo(To) }, useDebugValue: Qo, useDeferredValue: function (e) { var t = Co(); return null === go ? t.memoizedState = e : Zo(t, go.memoizedState, e) }, useTransition: function () { return [Bo(To)[0], Co().memoizedState] }, useMutableSource: Io, useSyncExternalStore: Po, useId: es, unstable_isNewReconciler: !1 }; function us(e, t) { try { var n = "", r = t; do { n += H(r), r = r.return } while (r); var i = n } catch (e) { i = "\nError generating stack: " + e.message + "\n" + e.stack } return { value: e, source: t, stack: i, digest: null } } function ds(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function hs(e, t) { try { console.error(t.value) } catch (e) { setTimeout((function () { throw e })) } } var ps = "function" == typeof WeakMap ? WeakMap : Map; function fs(e, t, n) { (n = La(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Wl || (Wl = !0, Xl = r), hs(0, t) }, n } function ms(e, t, n) { (n = La(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" == typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { hs(0, t) } } var a = e.stateNode; return null !== a && "function" == typeof a.componentDidCatch && (n.callback = function () { hs(0, t), "function" != typeof r && (null === Jl ? Jl = new Set([this]) : Jl.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function gs(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new ps; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Ec.bind(null, e, t, n), t.then(e, e)) } function vs(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function ys(e, t, n, r, i) { return 1 & e.mode ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = La(-1, 1)).tag = 2, Da(n, t, 1))), n.lanes |= 1), e) } var bs = x.ReactCurrentOwner, xs = !1; function As(e, t, n, r) { t.child = null === e ? qa(t, null, n, r) : Ka(t, e.child, n, r) } function Ss(e, t, n, r, i) { n = n.render; var a = t.ref; return wa(t, i), r = wo(e, t, n, r, a, i), n = _o(), null === e || xs ? (ia && n && ea(t), t.flags |= 1, As(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ws(e, t, i)) } function Ms(e, t, n, r, i) { if (null === e) { var a = n.type; return "function" != typeof a || Lc(a) || void 0 !== a.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = kc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = a, ws(e, t, a, r, i)) } if (a = e.child, !(e.lanes & i)) { var o = a.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(o, r) && e.ref === t.ref) return Ws(e, t, i) } return t.flags |= 1, (e = Dc(a, r)).ref = t.ref, e.return = t, t.child = e } function ws(e, t, n, r, i) { if (null !== e) { var a = e.memoizedProps; if (lr(a, r) && e.ref === t.ref) { if (xs = !1, t.pendingProps = r = a, !(e.lanes & i)) return t.lanes = e.lanes, Ws(e, t, i); 131072 & e.flags && (xs = !0) } } return Cs(e, t, n, r, i) } function _s(e, t, n) { var r = t.pendingProps, i = r.children, a = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (1 & t.mode) { if (!(1073741824 & n)) return e = null !== a ? a.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ei(Dl, Ll), Ll |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== a ? a.baseLanes : n, Ei(Dl, Ll), Ll |= r } else t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ei(Dl, Ll), Ll |= n; else null !== a ? (r = a.baseLanes | n, t.memoizedState = null) : r = n, Ei(Dl, Ll), Ll |= r; return As(e, t, i, n), t.child } function Es(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Cs(e, t, n, r, i) { var a = Pi(n) ? Bi : Ti.current; return a = Ii(t, a), wa(t, i), n = wo(e, t, n, r, a, i), r = _o(), null === e || xs ? (ia && r && ea(t), t.flags |= 1, As(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ws(e, t, i)) } function Ts(e, t, n, r, i) { if (Pi(n)) { var a = !0; Ni(t) } else a = !1; if (wa(t, i), null === t.stateNode) Vs(e, t), ja(t, n, r), Wa(t, n, r, i), r = !0; else if (null === e) { var o = t.stateNode, s = t.memoizedProps; o.props = s; var l = o.context, c = n.contextType; c = "object" == typeof c && null !== c ? _a(c) : Ii(t, c = Pi(n) ? Bi : Ti.current); var u = n.getDerivedStateFromProps, d = "function" == typeof u || "function" == typeof o.getSnapshotBeforeUpdate; d || "function" != typeof o.UNSAFE_componentWillReceiveProps && "function" != typeof o.componentWillReceiveProps || (s !== r || l !== c) && Va(t, o, r, c), Ba = !1; var h = t.memoizedState; o.state = h, Fa(t, r, o, i), l = t.memoizedState, s !== r || h !== l || Ri.current || Ba ? ("function" == typeof u && (za(t, n, u, r), l = t.memoizedState), (s = Ba || Ga(t, n, s, r, h, l, c)) ? (d || "function" != typeof o.UNSAFE_componentWillMount && "function" != typeof o.componentWillMount || ("function" == typeof o.componentWillMount && o.componentWillMount(), "function" == typeof o.UNSAFE_componentWillMount && o.UNSAFE_componentWillMount()), "function" == typeof o.componentDidMount && (t.flags |= 4194308)) : ("function" == typeof o.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = c, r = s) : ("function" == typeof o.componentDidMount && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, Pa(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : ga(t.type, s), o.props = c, d = t.pendingProps, h = o.context, l = "object" == typeof (l = n.contextType) && null !== l ? _a(l) : Ii(t, l = Pi(n) ? Bi : Ti.current); var p = n.getDerivedStateFromProps; (u = "function" == typeof p || "function" == typeof o.getSnapshotBeforeUpdate) || "function" != typeof o.UNSAFE_componentWillReceiveProps && "function" != typeof o.componentWillReceiveProps || (s !== d || h !== l) && Va(t, o, r, l), Ba = !1, h = t.memoizedState, o.state = h, Fa(t, r, o, i); var f = t.memoizedState; s !== d || h !== f || Ri.current || Ba ? ("function" == typeof p && (za(t, n, p, r), f = t.memoizedState), (c = Ba || Ga(t, n, c, r, h, f, l) || !1) ? (u || "function" != typeof o.UNSAFE_componentWillUpdate && "function" != typeof o.componentWillUpdate || ("function" == typeof o.componentWillUpdate && o.componentWillUpdate(r, f, l), "function" == typeof o.UNSAFE_componentWillUpdate && o.UNSAFE_componentWillUpdate(r, f, l)), "function" == typeof o.componentDidUpdate && (t.flags |= 4), "function" == typeof o.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" != typeof o.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" != typeof o.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), o.props = r, o.state = f, o.context = l, r = c) : ("function" != typeof o.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" != typeof o.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return Rs(e, t, n, r, a, i) } function Rs(e, t, n, r, i, a) { Es(e, t); var o = !!(128 & t.flags); if (!r && !o) return i && Fi(t, n, !1), Ws(e, t, a); r = t.stateNode, bs.current = t; var s = o && "function" != typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && o ? (t.child = Ka(t, e.child, null, a), t.child = Ka(t, null, s, a)) : As(e, t, s, a), t.memoizedState = r.state, i && Fi(t, n, !0), t.child } function Bs(e) { var t = e.stateNode; t.pendingContext ? Di(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Di(0, t.context, !1), ro(e, t.containerInfo) } function Is(e, t, n, r, i) { return pa(), fa(i), t.flags |= 256, As(e, t, n, r), t.child } var Ps, Ls, Ds, ks, Ns = { dehydrated: null, treeContext: null, retryLane: 0 }; function Fs(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Os(e, t, n) { var r, i = t.pendingProps, o = so.current, s = !1, l = !!(128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && !!(2 & o)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (o |= 1), Ei(so, 1 & o), null === e) return ca(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (1 & t.mode ? "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (l = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, l = { mode: "hidden", children: l }, 1 & i || null === s ? s = Fc(l, i, 0, null) : (s.childLanes = 0, s.pendingProps = l), e = Nc(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Fs(n), t.memoizedState = Ns, e) : Us(t, l)); if (null !== (o = e.memoizedState) && null !== (r = o.dehydrated)) return function (e, t, n, r, i, o, s) { if (n) return 256 & t.flags ? (t.flags &= -257, zs(e, t, s, r = ds(Error(a(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Fc({ mode: "visible", children: r.children }, i, 0, null), (o = Nc(o, i, s, null)).flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, 1 & t.mode && Ka(t, e.child, null, s), t.child.memoizedState = Fs(s), t.memoizedState = Ns, o); if (!(1 & t.mode)) return zs(e, t, s, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, zs(e, t, s, r = ds(o = Error(a(419)), r, void 0)) } if (l = !!(s & e.childLanes), xs || l) { if (null !== (r = Bl)) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = i & (r.suspendedLanes | s) ? 0 : i) && i !== o.retryLane && (o.retryLane = i, Ra(e, i), rc(r, e, i, -1)) } return gc(), zs(e, t, s, r = ds(Error(a(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Tc.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, ra = ci(i.nextSibling), na = t, ia = !0, aa = null, null !== e && (Ji[Yi++] = Ki, Ji[Yi++] = qi, Ji[Yi++] = Qi, Ki = e.id, qi = e.overflow, Qi = t), (t = Us(t, r.children)).flags |= 4096, t) }(e, t, l, i, r, o, n); if (s) { s = i.fallback, l = t.mode, r = (o = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 1 & l || t.child === o ? (i = Dc(o, c)).subtreeFlags = 14680064 & o.subtreeFlags : ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null), null !== r ? s = Dc(r, s) : (s = Nc(s, l, n, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, l = null === (l = e.child.memoizedState) ? Fs(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, s.memoizedState = l, s.childLanes = e.childLanes & ~n, t.memoizedState = Ns, i } return e = (s = e.child).sibling, i = Dc(s, { mode: "visible", children: i.children }), !(1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Us(e, t) { return (t = Fc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function zs(e, t, n, r) { return null !== r && fa(r), Ka(t, e.child, null, n), (e = Us(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Hs(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), Ma(e.return, t, n) } function Gs(e, t, n, r, i) { var a = e.memoizedState; null === a ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (a.isBackwards = t, a.rendering = null, a.renderingStartTime = 0, a.last = r, a.tail = n, a.tailMode = i) } function js(e, t, n) { var r = t.pendingProps, i = r.revealOrder, a = r.tail; if (As(e, t, r.children, n), 2 & (r = so.current)) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 128 & e.flags) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Hs(e, n, t); else if (19 === e.tag) Hs(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ei(so, r), 1 & t.mode) switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === lo(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Gs(t, !1, i, n, a); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === lo(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Gs(t, !0, n, null, a); break; case "together": Gs(t, !1, null, null, void 0); break; default: t.memoizedState = null } else t.memoizedState = null; return t.child } function Vs(e, t) { !(1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Ws(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), Fl |= t.lanes, !(n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(a(153)); if (null !== t.child) { for (n = Dc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Dc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Xs(e, t) { if (!ia) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Js(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Ys(e, t, n) { var r = t.pendingProps; switch (ta(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Js(t), null; case 1: case 17: return Pi(t.type) && Li(), Js(t), null; case 3: return r = t.stateNode, io(), _i(Ri), _i(Ti), uo(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (da(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024, null !== aa && (sc(aa), aa = null))), Ls(e, t), Js(t), null; case 5: oo(t); var i = no(to.current); if (n = t.type, null !== e && null != t.stateNode) Ds(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(a(166)); return Js(t), null } if (e = no($a.current), da(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[hi] = t, r[pi] = o, e = !!(1 & t.mode), n) { case "dialog": Ur("cancel", r), Ur("close", r); break; case "iframe": case "object": case "embed": Ur("load", r); break; case "video": case "audio": for (i = 0; i < kr.length; i++)Ur(kr[i], r); break; case "source": Ur("error", r); break; case "img": case "image": case "link": Ur("error", r), Ur("load", r); break; case "details": Ur("toggle", r); break; case "input": K(r, o), Ur("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Ur("invalid", r); break; case "textarea": ie(r, o), Ur("invalid", r) }for (var l in ye(n, o), i = null, o) if (o.hasOwnProperty(l)) { var c = o[l]; "children" === l ? "string" == typeof c ? r.textContent !== c && (!0 !== o.suppressHydrationWarning && Zr(r.textContent, c, e), i = ["children", c]) : "number" == typeof c && r.textContent !== "" + c && (!0 !== o.suppressHydrationWarning && Zr(r.textContent, c, e), i = ["children", "" + c]) : s.hasOwnProperty(l) && null != c && "onScroll" === l && Ur("scroll", r) } switch (n) { case "input": X(r), $(r, o, !0); break; case "textarea": X(r), oe(r); break; case "select": case "option": break; default: "function" == typeof o.onClick && (r.onclick = $r) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = se(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" == typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[pi] = r, Ps(e, t, !1, !1), t.stateNode = e; e: { switch (l = be(n, r), n) { case "dialog": Ur("cancel", e), Ur("close", e), i = r; break; case "iframe": case "object": case "embed": Ur("load", e), i = r; break; case "video": case "audio": for (i = 0; i < kr.length; i++)Ur(kr[i], e); i = r; break; case "source": Ur("error", e), i = r; break; case "img": case "image": case "link": Ur("error", e), Ur("load", e), i = r; break; case "details": Ur("toggle", e), i = r; break; case "input": K(e, r), i = Q(e, r), Ur("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = F({}, r, { value: void 0 }), Ur("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), Ur("invalid", e) }for (o in ye(n, i), c = i) if (c.hasOwnProperty(o)) { var u = c[o]; "style" === o ? ge(e, u) : "dangerouslySetInnerHTML" === o ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === o ? "string" == typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" == typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== o && "suppressHydrationWarning" !== o && "autoFocus" !== o && (s.hasOwnProperty(o) ? null != u && "onScroll" === o && Ur("scroll", e) : null != u && b(e, o, u, l)) } switch (n) { case "input": X(e), $(e, r, !1); break; case "textarea": X(e), oe(e); break; case "option": null != r.value && e.setAttribute("value", "" + V(r.value)); break; case "select": e.multiple = !!r.multiple, null != (o = r.value) ? ne(e, !!r.multiple, o, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" == typeof i.onClick && (e.onclick = $r) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Js(t), null; case 6: if (e && null != t.stateNode) ks(e, t, e.memoizedProps, r); else { if ("string" != typeof r && null === t.stateNode) throw Error(a(166)); if (n = no(to.current), no($a.current), da(t)) { if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (o = r.nodeValue !== n) && null !== (e = na)) switch (e.tag) { case 3: Zr(r.nodeValue, n, !!(1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Zr(r.nodeValue, n, !!(1 & e.mode)) }o && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r } return Js(t), null; case 13: if (_i(so), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (ia && null !== ra && 1 & t.mode && !(128 & t.flags)) ha(), pa(), t.flags |= 98560, o = !1; else if (o = da(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!o) throw Error(a(318)); if (!(o = null !== (o = t.memoizedState) ? o.dehydrated : null)) throw Error(a(317)); o[hi] = t } else pa(), !(128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Js(t), o = !1 } else null !== aa && (sc(aa), aa = null), o = !0; if (!o) return 65536 & t.flags ? t : null } return 128 & t.flags ? (t.lanes = n, t) : ((r = null !== r) != (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 1 & t.mode && (null === e || 1 & so.current ? 0 === kl && (kl = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Js(t), null); case 4: return io(), Ls(e, t), null === e && Gr(t.stateNode.containerInfo), Js(t), null; case 10: return Sa(t.type._context), Js(t), null; case 19: if (_i(so), null === (o = t.memoizedState)) return Js(t), null; if (r = !!(128 & t.flags), null === (l = o.rendering)) if (r) Xs(o, !1); else { if (0 !== kl || null !== e && 128 & e.flags) for (e = t.child; null !== e;) { if (null !== (l = lo(e))) { for (t.flags |= 128, Xs(o, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (o = n).flags &= 14680066, null === (l = o.alternate) ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = l.childLanes, o.lanes = l.lanes, o.child = l.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = l.memoizedProps, o.memoizedState = l.memoizedState, o.updateQueue = l.updateQueue, o.type = l.type, e = l.dependencies, o.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ei(so, 1 & so.current | 2), t.child } e = e.sibling } null !== o.tail && qe() > jl && (t.flags |= 128, r = !0, Xs(o, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = lo(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Xs(o, !0), null === o.tail && "hidden" === o.tailMode && !l.alternate && !ia) return Js(t), null } else 2 * qe() - o.renderingStartTime > jl && 1073741824 !== n && (t.flags |= 128, r = !0, Xs(o, !1), t.lanes = 4194304); o.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = o.last) ? n.sibling = l : t.child = l, o.last = l) } return null !== o.tail ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = qe(), t.sibling = null, n = so.current, Ei(so, r ? 1 & n | 2 : 1 & n), t) : (Js(t), null); case 22: case 23: return hc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 1 & t.mode ? !!(1073741824 & Ll) && (Js(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Js(t), null; case 24: case 25: return null }throw Error(a(156, t.tag)) } function Qs(e, t) { switch (ta(t), t.tag) { case 1: return Pi(t.type) && Li(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return io(), _i(Ri), _i(Ti), uo(), 65536 & (e = t.flags) && !(128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return oo(t), null; case 13: if (_i(so), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(a(340)); pa() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return _i(so), null; case 4: return io(), null; case 10: return Sa(t.type._context), null; case 22: case 23: return hc(), null; default: return null } } Ps = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, Ls = function () { }, Ds = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, no($a.current); var a, o = null; switch (n) { case "input": i = Q(e, i), r = Q(e, r), o = []; break; case "select": i = F({}, i, { value: void 0 }), r = F({}, r, { value: void 0 }), o = []; break; case "textarea": i = re(e, i), r = re(e, r), o = []; break; default: "function" != typeof i.onClick && "function" == typeof r.onClick && (e.onclick = $r) }for (u in ye(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (a in l) l.hasOwnProperty(a) && (n || (n = {}), n[a] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (a in l) !l.hasOwnProperty(a) || c && c.hasOwnProperty(a) || (n || (n = {}), n[a] = ""); for (a in c) c.hasOwnProperty(a) && l[a] !== c[a] && (n || (n = {}), n[a] = c[a]) } else n || (o || (o = []), o.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (o = o || []).push(u, c)) : "children" === u ? "string" != typeof c && "number" != typeof c || (o = o || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != c && "onScroll" === u && Ur("scroll", e), o || l === c || (o = [])) : (o = o || []).push(u, c)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }, ks = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Ks = !1, qs = !1, Zs = "function" == typeof WeakSet ? WeakSet : Set, $s = null; function el(e, t) { var n = e.ref; if (null !== n) if ("function" == typeof n) try { n(null) } catch (n) { _c(e, t, n) } else n.current = null } function tl(e, t, n) { try { n() } catch (n) { _c(e, t, n) } } var nl = !1; function rl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var a = i.destroy; i.destroy = void 0, void 0 !== a && tl(t, n, a) } i = i.next } while (i !== r) } } function il(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function al(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" == typeof t ? t(e) : t.current = e } } function ol(e) { var t = e.alternate; null !== t && (e.alternate = null, ol(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && null !== (t = e.stateNode) && (delete t[hi], delete t[pi], delete t[mi], delete t[gi], delete t[vi]), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function sl(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ll(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || sl(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null != (n = n._reactRootContainer) || null !== t.onclick || (t.onclick = $r)); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } function ul(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;)ul(e, t, n), e = e.sibling } var dl = null, hl = !1; function pl(e, t, n) { for (n = n.child; null !== n;)fl(e, t, n), n = n.sibling } function fl(e, t, n) { if (at && "function" == typeof at.onCommitFiberUnmount) try { at.onCommitFiberUnmount(it, n) } catch (e) { } switch (n.tag) { case 5: qs || el(n, t); case 6: var r = dl, i = hl; dl = null, pl(e, t, n), hl = i, null !== (dl = r) && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode)); break; case 18: null !== dl && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), Gt(e)) : li(dl, n.stateNode)); break; case 4: r = dl, i = hl, dl = n.stateNode.containerInfo, hl = !0, pl(e, t, n), dl = r, hl = i; break; case 0: case 11: case 14: case 15: if (!qs && null !== (r = n.updateQueue) && null !== (r = r.lastEffect)) { i = r = r.next; do { var a = i, o = a.destroy; a = a.tag, void 0 !== o && (2 & a || 4 & a) && tl(n, t, o), i = i.next } while (i !== r) } pl(e, t, n); break; case 1: if (!qs && (el(n, t), "function" == typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (e) { _c(n, t, e) } pl(e, t, n); break; case 21: pl(e, t, n); break; case 22: 1 & n.mode ? (qs = (r = qs) || null !== n.memoizedState, pl(e, t, n), qs = r) : pl(e, t, n); break; default: pl(e, t, n) } } function ml(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Zs), t.forEach((function (t) { var r = Rc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function gl(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, l = s; e: for (; null !== l;) { switch (l.tag) { case 5: dl = l.stateNode, hl = !1; break e; case 3: case 4: dl = l.stateNode.containerInfo, hl = !0; break e }l = l.return } if (null === dl) throw Error(a(160)); fl(o, s, i), dl = null, hl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (e) { _c(i, t, e) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)vl(t, e), t = t.sibling } function vl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (gl(t, e), yl(e), 4 & r) { try { rl(3, e, e.return), il(3, e) } catch (t) { _c(e, e.return, t) } try { rl(5, e, e.return) } catch (t) { _c(e, e.return, t) } } break; case 1: gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return); break; case 5: if (gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) { var i = e.stateNode; try { he(i, "") } catch (t) { _c(e, e.return, t) } } if (4 & r && null != (i = e.stateNode)) { var o = e.memoizedProps, s = null !== n ? n.memoizedProps : o, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === o.type && null != o.name && q(i, o), be(l, s); var u = be(l, o); for (s = 0; s < c.length; s += 2) { var d = c[s], h = c[s + 1]; "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, u) } switch (l) { case "input": Z(i, o); break; case "textarea": ae(i, o); break; case "select": var p = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var f = o.value; null != f ? ne(i, !!o.multiple, f, !1) : p !== !!o.multiple && (null != o.defaultValue ? ne(i, !!o.multiple, o.defaultValue, !0) : ne(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[pi] = o } catch (t) { _c(e, e.return, t) } } break; case 6: if (gl(t, e), yl(e), 4 & r) { if (null === e.stateNode) throw Error(a(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (t) { _c(e, e.return, t) } } break; case 3: if (gl(t, e), yl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { Gt(t.containerInfo) } catch (t) { _c(e, e.return, t) } break; case 4: default: gl(t, e), yl(e); break; case 13: gl(t, e), yl(e), 8192 & (i = e.child).flags && (o = null !== i.memoizedState, i.stateNode.isHidden = o, !o || null !== i.alternate && null !== i.alternate.memoizedState || (Gl = qe())), 4 & r && ml(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (qs = (u = qs) || d, gl(t, e), qs = u) : gl(t, e), yl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 1 & e.mode) for ($s = e, d = e.child; null !== d;) { for (h = $s = d; null !== $s;) { switch (f = (p = $s).child, p.tag) { case 0: case 11: case 14: case 15: rl(4, p, p.return); break; case 1: el(p, p.return); var m = p.stateNode; if ("function" == typeof m.componentWillUnmount) { r = p, n = p.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (e) { _c(r, n, e) } } break; case 5: el(p, p.return); break; case 22: if (null !== p.memoizedState) { Sl(h); continue } }null !== f ? (f.return = p, $s = f) : Sl(h) } d = d.sibling } e: for (d = null, h = e; ;) { if (5 === h.tag) { if (null === d) { d = h; try { i = h.stateNode, u ? "function" == typeof (o = i.style).setProperty ? o.setProperty("display", "none", "important") : o.display = "none" : (l = h.stateNode, s = null != (c = h.memoizedProps.style) && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", s)) } catch (t) { _c(e, e.return, t) } } } else if (6 === h.tag) { if (null === d) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (t) { _c(e, e.return, t) } } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) { h.child.return = h, h = h.child; continue } if (h === e) break e; for (; null === h.sibling;) { if (null === h.return || h.return === e) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: gl(t, e), yl(e), 4 & r && ml(e); case 21: } } function yl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (sl(n)) { var r = n; break e } n = n.return } throw Error(a(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (he(i, ""), r.flags &= -33), ul(e, ll(e), i); break; case 3: case 4: var o = r.stateNode.containerInfo; cl(e, ll(e), o); break; default: throw Error(a(161)) } } catch (t) { _c(e, e.return, t) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function bl(e, t, n) { $s = e, xl(e, t, n) } function xl(e, t, n) { for (var r = !!(1 & e.mode); null !== $s;) { var i = $s, a = i.child; if (22 === i.tag && r) { var o = null !== i.memoizedState || Ks; if (!o) { var s = i.alternate, l = null !== s && null !== s.memoizedState || qs; s = Ks; var c = qs; if (Ks = o, (qs = l) && !c) for ($s = i; null !== $s;)l = (o = $s).child, 22 === o.tag && null !== o.memoizedState ? Ml(i) : null !== l ? (l.return = o, $s = l) : Ml(i); for (; null !== a;)$s = a, xl(a, t, n), a = a.sibling; $s = i, Ks = s, qs = c } Al(e) } else 8772 & i.subtreeFlags && null !== a ? (a.return = i, $s = a) : Al(e) } } function Al(e) { for (; null !== $s;) { var t = $s; if (8772 & t.flags) { var n = t.alternate; try { if (8772 & t.flags) switch (t.tag) { case 0: case 11: case 15: qs || il(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !qs) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : ga(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; null !== o && Oa(t, o, r); break; case 3: var s = t.updateQueue; if (null !== s) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }Oa(t, s, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var h = d.dehydrated; null !== h && Gt(h) } } } break; default: throw Error(a(163)) }qs || 512 & t.flags && al(t) } catch (e) { _c(t, t.return, e) } } if (t === e) { $s = null; break } if (null !== (n = t.sibling)) { n.return = t.return, $s = n; break } $s = t.return } } function Sl(e) { for (; null !== $s;) { var t = $s; if (t === e) { $s = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, $s = n; break } $s = t.return } } function Ml(e) { for (; null !== $s;) { var t = $s; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { il(4, t) } catch (e) { _c(t, n, e) } break; case 1: var r = t.stateNode; if ("function" == typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (e) { _c(t, i, e) } } var a = t.return; try { al(t) } catch (e) { _c(t, a, e) } break; case 5: var o = t.return; try { al(t) } catch (e) { _c(t, o, e) } } } catch (e) { _c(t, t.return, e) } if (t === e) { $s = null; break } var s = t.sibling; if (null !== s) { s.return = t.return, $s = s; break } $s = t.return } } var wl, _l = Math.ceil, El = x.ReactCurrentDispatcher, Cl = x.ReactCurrentOwner, Tl = x.ReactCurrentBatchConfig, Rl = 0, Bl = null, Il = null, Pl = 0, Ll = 0, Dl = wi(0), kl = 0, Nl = null, Fl = 0, Ol = 0, Ul = 0, zl = null, Hl = null, Gl = 0, jl = 1 / 0, Vl = null, Wl = !1, Xl = null, Jl = null, Yl = !1, Ql = null, Kl = 0, ql = 0, Zl = null, $l = -1, ec = 0; function tc() { return 6 & Rl ? qe() : -1 !== $l ? $l : $l = qe() } function nc(e) { return 1 & e.mode ? 2 & Rl && 0 !== Pl ? Pl & -Pl : null !== ma.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Kt(e.type) : 1 } function rc(e, t, n, r) { if (50 < ql) throw ql = 0, Zl = null, Error(a(185)); vt(e, n, r), 2 & Rl && e === Bl || (e === Bl && (!(2 & Rl) && (Ol |= n), 4 === kl && lc(e, Pl)), ic(e, r), 1 === n && 0 === Rl && !(1 & t.mode) && (jl = qe() + 500, Ui && Gi())) } function ic(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, a = e.pendingLanes; 0 < a;) { var o = 31 - ot(a), s = 1 << o, l = i[o]; -1 === l ? s & n && !(s & r) || (i[o] = pt(s, t)) : l <= t && (e.expiredLanes |= s), a &= ~s } }(e, t); var r = ht(e, e === Bl ? Pl : 0); if (0 === r) null !== n && Ye(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && Ye(n), 1 === t) 0 === e.tag ? function (e) { Ui = !0, Hi(e) }(cc.bind(null, e)) : Hi(cc.bind(null, e)), oi((function () { !(6 & Rl) && Gi() })), n = null; else { switch (xt(r)) { case 1: n = $e; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Bc(n, ac.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function ac(e, t) { if ($l = -1, ec = 0, 6 & Rl) throw Error(a(327)); var n = e.callbackNode; if (Mc() && e.callbackNode !== n) return null; var r = ht(e, e === Bl ? Pl : 0); if (0 === r) return null; if (30 & r || r & e.expiredLanes || t) t = vc(e, r); else { t = r; var i = Rl; Rl |= 2; var o = mc(); for (Bl === e && Pl === t || (Vl = null, jl = qe() + 500, pc(e, t)); ;)try { bc(); break } catch (t) { fc(e, t) } Aa(), El.current = o, Rl = i, null !== Il ? t = 0 : (Bl = null, Pl = 0, t = kl) } if (0 !== t) { if (2 === t && 0 !== (i = ft(e)) && (r = i, t = oc(e, i)), 1 === t) throw n = Nl, pc(e, 0), lc(e, r), ic(e, qe()), n; if (6 === t) lc(e, r); else { if (i = e.current.alternate, !(30 & r || function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], a = i.getSnapshot; i = i.value; try { if (!sr(a(), i)) return !1 } catch (e) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) || (t = vc(e, r), 2 === t && (o = ft(e), 0 !== o && (r = o, t = oc(e, o))), 1 !== t))) throw n = Nl, pc(e, 0), lc(e, r), ic(e, qe()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(a(345)); case 2: case 5: Sc(e, Hl, Vl); break; case 3: if (lc(e, r), (130023424 & r) === r && 10 < (t = Gl + 500 - qe())) { if (0 !== ht(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { tc(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(Sc.bind(null, e, Hl, Vl), t); break } Sc(e, Hl, Vl); break; case 4: if (lc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - ot(r); o = 1 << s, (s = t[s]) > i && (i = s), r &= ~o } if (r = i, 10 < (r = (120 > (r = qe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * _l(r / 1960)) - r)) { e.timeoutHandle = ri(Sc.bind(null, e, Hl, Vl), r); break } Sc(e, Hl, Vl); break; default: throw Error(a(329)) } } } return ic(e, qe()), e.callbackNode === n ? ac.bind(null, e) : null } function oc(e, t) { var n = zl; return e.current.memoizedState.isDehydrated && (pc(e, t).flags |= 256), 2 !== (e = vc(e, t)) && (t = Hl, Hl = n, null !== t && sc(t)), e } function sc(e) { null === Hl ? Hl = e : Hl.push.apply(Hl, e) } function lc(e, t) { for (t &= ~Ul, t &= ~Ol, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - ot(t), r = 1 << n; e[n] = -1, t &= ~r } } function cc(e) { if (6 & Rl) throw Error(a(327)); Mc(); var t = ht(e, 0); if (!(1 & t)) return ic(e, qe()), null; var n = vc(e, t); if (0 !== e.tag && 2 === n) { var r = ft(e); 0 !== r && (t = r, n = oc(e, r)) } if (1 === n) throw n = Nl, pc(e, 0), lc(e, t), ic(e, qe()), n; if (6 === n) throw Error(a(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Sc(e, Hl, Vl), ic(e, qe()), null } function uc(e, t) { var n = Rl; Rl |= 1; try { return e(t) } finally { 0 === (Rl = n) && (jl = qe() + 500, Ui && Gi()) } } function dc(e) { null !== Ql && 0 === Ql.tag && !(6 & Rl) && Mc(); var t = Rl; Rl |= 1; var n = Tl.transition, r = bt; try { if (Tl.transition = null, bt = 1, e) return e() } finally { bt = r, Tl.transition = n, !(6 & (Rl = t)) && Gi() } } function hc() { Ll = Dl.current, _i(Dl) } function pc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Il) for (n = Il.return; null !== n;) { var r = n; switch (ta(r), r.tag) { case 1: null != (r = r.type.childContextTypes) && Li(); break; case 3: io(), _i(Ri), _i(Ti), uo(); break; case 5: oo(r); break; case 4: io(); break; case 13: case 19: _i(so); break; case 10: Sa(r.type._context); break; case 22: case 23: hc() }n = n.return } if (Bl = e, Il = e = Dc(e.current, null), Pl = Ll = t, kl = 0, Nl = null, Ul = Ol = Fl = 0, Hl = zl = null, null !== Ea) { for (t = 0; t < Ea.length; t++)if (null !== (r = (n = Ea[t]).interleaved)) { n.interleaved = null; var i = r.next, a = n.pending; if (null !== a) { var o = a.next; a.next = i, r.next = o } n.pending = r } Ea = null } return e } function fc(e, t) { for (; ;) { var n = Il; try { if (Aa(), ho.current = os, yo) { for (var r = mo.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } yo = !1 } if (fo = 0, vo = go = mo = null, bo = !1, xo = 0, Cl.current = null, null === n || null === n.return) { kl = 1, Nl = t, Il = null; break } e: { var o = e, s = n.return, l = n, c = t; if (t = Pl, l.flags |= 32768, null !== c && "object" == typeof c && "function" == typeof c.then) { var u = c, d = l, h = d.tag; if (!(1 & d.mode || 0 !== h && 11 !== h && 15 !== h)) { var p = d.alternate; p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null) } var f = vs(s); if (null !== f) { f.flags &= -257, ys(f, s, l, 0, t), 1 & f.mode && gs(o, u, t), c = u; var m = (t = f).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (!(1 & t)) { gs(o, u, t), gc(); break e } c = Error(a(426)) } else if (ia && 1 & l.mode) { var v = vs(s); if (null !== v) { !(65536 & v.flags) && (v.flags |= 256), ys(v, s, l, 0, t), fa(us(c, l)); break e } } o = c = us(c, l), 4 !== kl && (kl = 2), null === zl ? zl = [o] : zl.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t, Na(o, fs(0, c, t)); break e; case 1: l = c; var y = o.type, b = o.stateNode; if (!(128 & o.flags || "function" != typeof y.getDerivedStateFromError && (null === b || "function" != typeof b.componentDidCatch || null !== Jl && Jl.has(b)))) { o.flags |= 65536, t &= -t, o.lanes |= t, Na(o, ms(o, l, t)); break e } }o = o.return } while (null !== o) } Ac(n) } catch (e) { t = e, Il === n && null !== n && (Il = n = n.return); continue } break } } function mc() { var e = El.current; return El.current = os, null === e ? os : e } function gc() { 0 !== kl && 3 !== kl && 2 !== kl || (kl = 4), null === Bl || !(268435455 & Fl) && !(268435455 & Ol) || lc(Bl, Pl) } function vc(e, t) { var n = Rl; Rl |= 2; var r = mc(); for (Bl === e && Pl === t || (Vl = null, pc(e, t)); ;)try { yc(); break } catch (t) { fc(e, t) } if (Aa(), Rl = n, El.current = r, null !== Il) throw Error(a(261)); return Bl = null, Pl = 0, kl } function yc() { for (; null !== Il;)xc(Il) } function bc() { for (; null !== Il && !Qe();)xc(Il) } function xc(e) { var t = wl(e.alternate, e, Ll); e.memoizedProps = e.pendingProps, null === t ? Ac(e) : Il = t, Cl.current = null } function Ac(e) { var t = e; do { var n = t.alternate; if (e = t.return, 32768 & t.flags) { if (null !== (n = Qs(n, t))) return n.flags &= 32767, void (Il = n); if (null === e) return kl = 6, void (Il = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } else if (null !== (n = Ys(n, t, Ll))) return void (Il = n); if (null !== (t = t.sibling)) return void (Il = t); Il = t = e } while (null !== t); 0 === kl && (kl = 5) } function Sc(e, t, n) { var r = bt, i = Tl.transition; try { Tl.transition = null, bt = 1, function (e, t, n, r) { do { Mc() } while (null !== Ql); if (6 & Rl) throw Error(a(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(a(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - ot(n), a = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~a } }(e, o), e === Bl && (Il = Bl = null, Pl = 0), !(2064 & n.subtreeFlags) && !(2064 & n.flags) || Yl || (Yl = !0, Bc(tt, (function () { return Mc(), null }))), o = !!(15990 & n.flags), 15990 & n.subtreeFlags || o) { o = Tl.transition, Tl.transition = null; var s = bt; bt = 1; var l = Rl; Rl |= 4, Cl.current = null, function (e, t) { if (ei = Vt, pr(e = hr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch (e) { n = null; break e } var s = 0, l = -1, c = -1, u = 0, d = 0, h = e, p = null; t: for (; ;) { for (var f; h !== n || 0 !== i && 3 !== h.nodeType || (l = s + i), h !== o || 0 !== r && 3 !== h.nodeType || (c = s + r), 3 === h.nodeType && (s += h.nodeValue.length), null !== (f = h.firstChild);)p = h, h = f; for (; ;) { if (h === e) break t; if (p === n && ++u === i && (l = s), p === o && ++d === r && (c = s), null !== (f = h.nextSibling)) break; p = (h = p).parentNode } h = f } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Vt = !1, $s = t; null !== $s;)if (e = (t = $s).child, 1028 & t.subtreeFlags && null !== e) e.return = t, $s = e; else for (; null !== $s;) { t = $s; try { var m = t.alternate; if (1024 & t.flags) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, v = m.memoizedState, y = t.stateNode, b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : ga(t.type, g), v); y.__reactInternalSnapshotBeforeUpdate = b } break; case 3: var x = t.stateNode.containerInfo; 1 === x.nodeType ? x.textContent = "" : 9 === x.nodeType && x.documentElement && x.removeChild(x.documentElement); break; default: throw Error(a(163)) } } catch (e) { _c(t, t.return, e) } if (null !== (e = t.sibling)) { e.return = t.return, $s = e; break } $s = t.return } m = nl, nl = !1 }(e, n), vl(n, e), fr(ti), Vt = !!ei, ti = ei = null, e.current = n, bl(n, e, i), Ke(), Rl = l, bt = s, Tl.transition = o } else e.current = n; if (Yl && (Yl = !1, Ql = e, Kl = i), 0 === (o = e.pendingLanes) && (Jl = null), function (e) { if (at && "function" == typeof at.onCommitFiberRoot) try { at.onCommitFiberRoot(it, e, void 0, !(128 & ~e.current.flags)) } catch (e) { } }(n.stateNode), ic(e, qe()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)r((i = t[n]).value, { componentStack: i.stack, digest: i.digest }); if (Wl) throw Wl = !1, e = Xl, Xl = null, e; !!(1 & Kl) && 0 !== e.tag && Mc(), 1 & (o = e.pendingLanes) ? e === Zl ? ql++ : (ql = 0, Zl = e) : ql = 0, Gi() }(e, t, n, r) } finally { Tl.transition = i, bt = r } return null } function Mc() { if (null !== Ql) { var e = xt(Kl), t = Tl.transition, n = bt; try { if (Tl.transition = null, bt = 16 > e ? 16 : e, null === Ql) var r = !1; else { if (e = Ql, Ql = null, Kl = 0, 6 & Rl) throw Error(a(331)); var i = Rl; for (Rl |= 4, $s = e.current; null !== $s;) { var o = $s, s = o.child; if (16 & $s.flags) { var l = o.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for ($s = u; null !== $s;) { var d = $s; switch (d.tag) { case 0: case 11: case 15: rl(8, d, o) }var h = d.child; if (null !== h) h.return = d, $s = h; else for (; null !== $s;) { var p = (d = $s).sibling, f = d.return; if (ol(d), d === u) { $s = null; break } if (null !== p) { p.return = f, $s = p; break } $s = f } } } var m = o.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var v = g.sibling; g.sibling = null, g = v } while (null !== g) } } $s = o } } if (2064 & o.subtreeFlags && null !== s) s.return = o, $s = s; else e: for (; null !== $s;) { if (2048 & (o = $s).flags) switch (o.tag) { case 0: case 11: case 15: rl(9, o, o.return) }var y = o.sibling; if (null !== y) { y.return = o.return, $s = y; break e } $s = o.return } } var b = e.current; for ($s = b; null !== $s;) { var x = (s = $s).child; if (2064 & s.subtreeFlags && null !== x) x.return = s, $s = x; else e: for (s = b; null !== $s;) { if (2048 & (l = $s).flags) try { switch (l.tag) { case 0: case 11: case 15: il(9, l) } } catch (e) { _c(l, l.return, e) } if (l === s) { $s = null; break e } var A = l.sibling; if (null !== A) { A.return = l.return, $s = A; break e } $s = l.return } } if (Rl = i, Gi(), at && "function" == typeof at.onPostCommitFiberRoot) try { at.onPostCommitFiberRoot(it, e) } catch (e) { } r = !0 } return r } finally { bt = n, Tl.transition = t } } return !1 } function wc(e, t, n) { e = Da(e, t = fs(0, t = us(n, t), 1), 1), t = tc(), null !== e && (vt(e, 1, t), ic(e, t)) } function _c(e, t, n) { if (3 === e.tag) wc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { wc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" == typeof t.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === Jl || !Jl.has(r))) { t = Da(t, e = ms(t, e = us(n, e), 1), 1), e = tc(), null !== t && (vt(t, 1, e), ic(t, e)); break } } t = t.return } } function Ec(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Bl === e && (Pl & n) === n && (4 === kl || 3 === kl && (130023424 & Pl) === Pl && 500 > qe() - Gl ? pc(e, 0) : Ul |= n), ic(e, t) } function Cc(e, t) { 0 === t && (1 & e.mode ? (t = ut, !(130023424 & (ut <<= 1)) && (ut = 4194304)) : t = 1); var n = tc(); null !== (e = Ra(e, t)) && (vt(e, t, n), ic(e, n)) } function Tc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Cc(e, n) } function Rc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(a(314)) }null !== r && r.delete(t), Cc(e, n) } function Bc(e, t) { return Je(e, t) } function Ic(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Pc(e, t, n, r) { return new Ic(e, t, n, r) } function Lc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Dc(e, t) { var n = e.alternate; return null === n ? ((n = Pc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function kc(e, t, n, r, i, o) { var s = 2; if (r = e, "function" == typeof e) Lc(e) && (s = 1); else if ("string" == typeof e) s = 5; else e: switch (e) { case M: return Nc(n.children, i, o, t); case w: s = 8, i |= 8; break; case _: return (e = Pc(12, n, t, 2 | i)).elementType = _, e.lanes = o, e; case R: return (e = Pc(13, n, t, i)).elementType = R, e.lanes = o, e; case B: return (e = Pc(19, n, t, i)).elementType = B, e.lanes = o, e; case L: return Fc(n, i, o, t); default: if ("object" == typeof e && null !== e) switch (e.$$typeof) { case E: s = 10; break e; case C: s = 9; break e; case T: s = 11; break e; case I: s = 14; break e; case P: s = 16, r = null; break e }throw Error(a(130, null == e ? e : typeof e, "")) }return (t = Pc(s, n, t, i)).elementType = e, t.type = r, t.lanes = o, t } function Nc(e, t, n, r) { return (e = Pc(7, e, r, t)).lanes = n, e } function Fc(e, t, n, r) { return (e = Pc(22, e, r, t)).elementType = L, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Oc(e, t, n) { return (e = Pc(6, e, null, t)).lanes = n, e } function Uc(e, t, n) { return (t = Pc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function zc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Hc(e, t, n, r, i, a, o, s, l) { return e = new zc(e, t, n, s, l), 1 === t ? (t = 1, !0 === a && (t |= 8)) : t = 0, a = Pc(3, null, null, t), e.current = a, a.stateNode = e, a.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ia(a), e } function Gc(e) { if (!e) return Ci; e: { if (Ge(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(a(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Pi(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(a(171)) } if (1 === e.tag) { var n = e.type; if (Pi(n)) return ki(e, n, t) } return t } function jc(e, t, n, r, i, a, o, s, l) { return (e = Hc(n, r, !0, e, 0, a, 0, s, l)).context = Gc(null), n = e.current, (a = La(r = tc(), i = nc(n))).callback = null != t ? t : null, Da(n, a, i), e.current.lanes = i, vt(e, i, r), ic(e, r), e } function Vc(e, t, n, r) { var i = t.current, a = tc(), o = nc(i); return n = Gc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = La(a, o)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Da(i, t, o)) && (rc(e, i, o, a), ka(e, i, o)), o } function Wc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Xc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Jc(e, t) { Xc(e, t), (e = e.alternate) && Xc(e, t) } wl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Ri.current) xs = !0; else { if (!(e.lanes & n || 128 & t.flags)) return xs = !1, function (e, t, n) { switch (t.tag) { case 3: Bs(t), pa(); break; case 5: ao(t); break; case 1: Pi(t.type) && Ni(t); break; case 4: ro(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ei(va, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ei(so, 1 & so.current), t.flags |= 128, null) : n & t.child.childLanes ? Os(e, t, n) : (Ei(so, 1 & so.current), null !== (e = Ws(e, t, n)) ? e.sibling : null); Ei(so, 1 & so.current); break; case 19: if (r = !!(n & t.childLanes), 128 & e.flags) { if (r) return js(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ei(so, so.current), r) break; return null; case 22: case 23: return t.lanes = 0, _s(e, t, n) }return Ws(e, t, n) }(e, t, n); xs = !!(131072 & e.flags) } else xs = !1, ia && 1048576 & t.flags && $i(t, Xi, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Vs(e, t), e = t.pendingProps; var i = Ii(t, Ti.current); wa(t, n), i = wo(null, t, r, e, i, n); var o = _o(); return t.flags |= 1, "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Pi(r) ? (o = !0, Ni(t)) : o = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Ia(t), i.updater = Ha, t.stateNode = i, i._reactInternals = t, Wa(t, r, e, n), t = Rs(null, t, r, !0, o, n)) : (t.tag = 0, ia && o && ea(t), As(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Vs(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" == typeof e) return Lc(e) ? 1 : 0; if (null != e) { if ((e = e.$$typeof) === T) return 11; if (e === I) return 14 } return 2 }(r), e = ga(r, e), i) { case 0: t = Cs(null, t, r, e, n); break e; case 1: t = Ts(null, t, r, e, n); break e; case 11: t = Ss(null, t, r, e, n); break e; case 14: t = Ms(null, t, r, ga(r.type, e), n); break e }throw Error(a(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, Cs(e, t, r, i = t.elementType === r ? i : ga(r, i), n); case 1: return r = t.type, i = t.pendingProps, Ts(e, t, r, i = t.elementType === r ? i : ga(r, i), n); case 3: e: { if (Bs(t), null === e) throw Error(a(387)); r = t.pendingProps, i = (o = t.memoizedState).element, Pa(e, t), Fa(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) { if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { t = Is(e, t, r, n, i = us(Error(a(423)), t)); break e } if (r !== i) { t = Is(e, t, r, n, i = us(Error(a(424)), t)); break e } for (ra = ci(t.stateNode.containerInfo.firstChild), na = t, ia = !0, aa = null, n = qa(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (pa(), r === i) { t = Ws(e, t, n); break e } As(e, t, r, n) } t = t.child } return t; case 5: return ao(t), null === e && ca(t), r = t.type, i = t.pendingProps, o = null !== e ? e.memoizedProps : null, s = i.children, ni(r, i) ? s = null : null !== o && ni(r, o) && (t.flags |= 32), Es(e, t), As(e, t, s, n), t.child; case 6: return null === e && ca(t), null; case 13: return Os(e, t, n); case 4: return ro(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Ka(t, null, r, n) : As(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, Ss(e, t, r, i = t.elementType === r ? i : ga(r, i), n); case 7: return As(e, t, t.pendingProps, n), t.child; case 8: case 12: return As(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, Ei(va, r._currentValue), r._currentValue = s, null !== o) if (sr(o.value, s)) { if (o.children === i.children && !Ri.current) { t = Ws(e, t, n); break e } } else for (null !== (o = t.child) && (o.return = t); null !== o;) { var l = o.dependencies; if (null !== l) { s = o.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === o.tag) { (c = La(-1, n & -n)).tag = 2; var u = o.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } o.lanes |= n, null !== (c = o.alternate) && (c.lanes |= n), Ma(o.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === o.tag) s = o.type === t.type ? null : o.child; else if (18 === o.tag) { if (null === (s = o.return)) throw Error(a(341)); s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), Ma(s, n, t), s = o.sibling } else s = o.child; if (null !== s) s.return = o; else for (s = o; null !== s;) { if (s === t) { s = null; break } if (null !== (o = s.sibling)) { o.return = s.return, s = o; break } s = s.return } o = s } As(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, wa(t, n), r = r(i = _a(i)), t.flags |= 1, As(e, t, r, n), t.child; case 14: return i = ga(r = t.type, t.pendingProps), Ms(e, t, r, i = ga(r.type, i), n); case 15: return ws(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : ga(r, i), Vs(e, t), t.tag = 1, Pi(r) ? (e = !0, Ni(t)) : e = !1, wa(t, n), ja(t, r, i), Wa(t, r, i, n), Rs(null, t, r, !0, e, n); case 19: return js(e, t, n); case 22: return _s(e, t, n) }throw Error(a(156, t.tag)) }; var Yc = "function" == typeof reportError ? reportError : function (e) { console.error(e) }; function Qc(e) { this._internalRoot = e } function Kc(e) { this._internalRoot = e } function qc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Zc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function $c() { } function eu(e, t, n, r, i) { var a = n._reactRootContainer; if (a) { var o = a; if ("function" == typeof i) { var s = i; i = function () { var e = Wc(o); s.call(e) } } Vc(t, o, e, i) } else o = function (e, t, n, r, i) { if (i) { if ("function" == typeof r) { var a = r; r = function () { var e = Wc(o); a.call(e) } } var o = jc(t, r, e, 0, null, !1, 0, "", $c); return e._reactRootContainer = o, e[fi] = o.current, Gr(8 === e.nodeType ? e.parentNode : e), dc(), o } for (; i = e.lastChild;)e.removeChild(i); if ("function" == typeof r) { var s = r; r = function () { var e = Wc(l); s.call(e) } } var l = Hc(e, 0, !1, null, 0, !1, 0, "", $c); return e._reactRootContainer = l, e[fi] = l.current, Gr(8 === e.nodeType ? e.parentNode : e), dc((function () { Vc(t, l, n, r) })), l }(n, t, e, i, r); return Wc(o) } Kc.prototype.render = Qc.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(a(409)); Vc(e, t, null, null) }, Kc.prototype.unmount = Qc.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; dc((function () { Vc(null, e, null, null) })), t[fi] = null } }, Kc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = wt(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Lt.length && 0 !== t && t < Lt[n].priority; n++); Lt.splice(n, 0, e), 0 === n && Ft(e) } }, At = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (yt(t, 1 | n), ic(t, qe()), !(6 & Rl) && (jl = qe() + 500, Gi())) } break; case 13: dc((function () { var t = Ra(e, 1); if (null !== t) { var n = tc(); rc(t, e, 1, n) } })), Jc(e, 1) } }, St = function (e) { if (13 === e.tag) { var t = Ra(e, 134217728); null !== t && rc(t, e, 134217728, tc()), Jc(e, 134217728) } }, Mt = function (e) { if (13 === e.tag) { var t = nc(e), n = Ra(e, t); null !== n && rc(n, e, t, tc()), Jc(e, t) } }, wt = function () { return bt }, _t = function (e, t) { var n = bt; try { return bt = e, t() } finally { bt = n } }, Se = function (e, t, n) { switch (t) { case "input": if (Z(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Ai(r); if (!i) throw Error(a(90)); J(r), Z(r, i) } } } break; case "textarea": ae(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, Te = uc, Re = dc; var tu = { usingClientEntryPoint: !1, Events: [bi, xi, Ai, Ee, Ce, uc] }, nu = { findFiberByHostInstance: yi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, ru = { bundleType: nu.bundleType, version: nu.version, rendererPackageName: nu.rendererPackageName, rendererConfig: nu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: x.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = We(e)) ? null : e.stateNode }, findFiberByHostInstance: nu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!iu.isDisabled && iu.supportsFiber) try { it = iu.inject(ru), at = iu } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!qc(t)) throw Error(a(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: S, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!qc(e)) throw Error(a(299)); var n = !1, r = "", i = Yc; return null != t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Hc(e, 1, !1, null, 0, n, 0, r, i), e[fi] = t.current, Gr(8 === e.nodeType ? e.parentNode : e), new Qc(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" == typeof e.render) throw Error(a(188)); throw e = Object.keys(e).join(","), Error(a(268, e)) } return null === (e = We(t)) ? null : e.stateNode }, t.flushSync = function (e) { return dc(e) }, t.hydrate = function (e, t, n) { if (!Zc(t)) throw Error(a(200)); return eu(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!qc(e)) throw Error(a(405)); var r = null != n && n.hydratedSources || null, i = !1, o = "", s = Yc; if (null != n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (o = n.identifierPrefix), void 0 !== n.onRecoverableError && (s = n.onRecoverableError)), t = jc(t, null, e, 1, null != n ? n : null, i, 0, o, s), e[fi] = t.current, Gr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Kc(t) }, t.render = function (e, t, n) { if (!Zc(t)) throw Error(a(200)); return eu(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Zc(e)) throw Error(a(40)); return !!e._reactRootContainer && (dc((function () { eu(null, null, e, !1, (function () { e._reactRootContainer = null, e[fi] = null })) })), !0) }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Zc(n)) throw Error(a(200)); if (null == e || void 0 === e._reactInternals) throw Error(a(38)); return eu(e, t, n, !1, r) }, t.version = "18.2.0-next-9e3b772b8-20220608" }, 338: (e, t, n) => { "use strict"; var r = n(961); t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot }, 961: (e, t, n) => { "use strict"; !function e() { if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (e) { console.error(e) } }(), e.exports = n(551) }, 731: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < a(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var s = 2 * (r + 1) - 1, l = e[s], c = s + 1, u = e[c]; if (0 > a(l, n)) c < i && 0 > a(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s); else { if (!(c < i && 0 > a(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function a(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" == typeof performance && "function" == typeof performance.now) { var o = performance; t.unstable_now = function () { return o.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var c = [], u = [], d = 1, h = null, p = 3, f = !1, m = !1, g = !1, v = "function" == typeof setTimeout ? setTimeout : null, y = "function" == typeof clearTimeout ? clearTimeout : null, b = "undefined" != typeof setImmediate ? setImmediate : null; function x(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function A(e) { if (g = !1, x(e), !m) if (null !== r(c)) m = !0, L(S); else { var t = r(u); null !== t && D(A, t.startTime - e) } } function S(e, n) { m = !1, g && (g = !1, y(E), E = -1), f = !0; var a = p; try { for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !R());) { var o = h.callback; if ("function" == typeof o) { h.callback = null, p = h.priorityLevel; var s = o(h.expirationTime <= n); n = t.unstable_now(), "function" == typeof s ? h.callback = s : h === r(c) && i(c), x(n) } else i(c); h = r(c) } if (null !== h) var l = !0; else { var d = r(u); null !== d && D(A, d.startTime - n), l = !1 } return l } finally { h = null, p = a, f = !1 } } "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var M, w = !1, _ = null, E = -1, C = 5, T = -1; function R() { return !(t.unstable_now() - T < C) } function B() { if (null !== _) { var e = t.unstable_now(); T = e; var n = !0; try { n = _(!0, e) } finally { n ? M() : (w = !1, _ = null) } } else w = !1 } if ("function" == typeof b) M = function () { b(B) }; else if ("undefined" != typeof MessageChannel) { var I = new MessageChannel, P = I.port2; I.port1.onmessage = B, M = function () { P.postMessage(null) } } else M = function () { v(B, 0) }; function L(e) { _ = e, w || (w = !0, M()) } function D(e, n) { E = v((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || f || (m = !0, L(S)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return p }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (p) { case 1: case 2: case 3: var t = 3; break; default: t = p }var n = p; p = t; try { return e() } finally { p = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = p; p = e; try { return t() } finally { p = n } }, t.unstable_scheduleCallback = function (e, i, a) { var o = t.unstable_now(); switch (a = "object" == typeof a && null !== a && "number" == typeof (a = a.delay) && 0 < a ? o + a : o, e) { case 1: var s = -1; break; case 2: s = 250; break; case 5: s = 1073741823; break; case 4: s = 1e4; break; default: s = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: a, expirationTime: s = a + s, sortIndex: -1 }, a > o ? (e.sortIndex = a, n(u, e), null === r(c) && e === r(u) && (g ? (y(E), E = -1) : g = !0, D(A, a - o))) : (e.sortIndex = s, n(c, e), m || f || (m = !0, L(S))), e }, t.unstable_shouldYield = R, t.unstable_wrapCallback = function (e) { var t = p; return function () { var n = p; p = t; try { return e.apply(this, arguments) } finally { p = n } } } }, 194: (e, t, n) => { "use strict"; e.exports = n(731) }, 735: (e, t) => { "use strict"; t.ConcurrentRoot = 1, t.ContinuousEventPriority = 4, t.DefaultEventPriority = 16, t.DiscreteEventPriority = 1 }, 935: (e, t, n) => { e.exports = function (e) { var t = {}, r = n(540), i = n(982), a = Object.assign; function o(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), c = Symbol.for("react.portal"), u = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), p = Symbol.for("react.provider"), f = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), y = Symbol.for("react.memo"), b = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var x = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var A = Symbol.iterator; function S(e) { return null === e || "object" != typeof e ? null : "function" == typeof (e = A && e[A] || e["@@iterator"]) ? e : null } function M(e) { if (null == e) return null; if ("function" == typeof e) return e.displayName || e.name || null; if ("string" == typeof e) return e; switch (e) { case u: return "Fragment"; case c: return "Portal"; case h: return "Profiler"; case d: return "StrictMode"; case g: return "Suspense"; case v: return "SuspenseList" }if ("object" == typeof e) switch (e.$$typeof) { case f: return (e.displayName || "Context") + ".Consumer"; case p: return (e._context.displayName || "Context") + ".Provider"; case m: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case y: return null !== (t = e.displayName || null) ? t : M(e.type) || "Memo"; case b: t = e._payload, e = e._init; try { return M(e(t)) } catch (e) { } }return null } function w(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return M(t); case 8: return t === d ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" == typeof t) return t.displayName || t.name || null; if ("string" == typeof t) return t }return null } function _(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { !!(4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function E(e) { if (_(e) !== e) throw Error(o(188)) } function C(e) { var t = e.alternate; if (!t) { if (null === (t = _(e))) throw Error(o(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var a = i.alternate; if (null === a) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === a.child) { for (a = i.child; a;) { if (a === n) return E(i), e; if (a === r) return E(i), t; a = a.sibling } throw Error(o(188)) } if (n.return !== r.return) n = i, r = a; else { for (var s = !1, l = i.child; l;) { if (l === n) { s = !0, n = i, r = a; break } if (l === r) { s = !0, r = i, n = a; break } l = l.sibling } if (!s) { for (l = a.child; l;) { if (l === n) { s = !0, n = a, r = i; break } if (l === r) { s = !0, r = a, n = i; break } l = l.sibling } if (!s) throw Error(o(189)) } } if (n.alternate !== r) throw Error(o(190)) } if (3 !== n.tag) throw Error(o(188)); return n.stateNode.current === n ? e : t } function T(e) { return null !== (e = C(e)) ? R(e) : null } function R(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = R(e); if (null !== t) return t; e = e.sibling } return null } function B(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { if (4 !== e.tag) { var t = B(e); if (null !== t) return t } e = e.sibling } return null } var I, P = Array.isArray, L = e.getPublicInstance, D = e.getRootHostContext, k = e.getChildHostContext, N = e.prepareForCommit, F = e.resetAfterCommit, O = e.createInstance, U = e.appendInitialChild, z = e.finalizeInitialChildren, H = e.prepareUpdate, G = e.shouldSetTextContent, j = e.createTextInstance, V = e.scheduleTimeout, W = e.cancelTimeout, X = e.noTimeout, J = e.isPrimaryRenderer, Y = e.supportsMutation, Q = e.supportsPersistence, K = e.supportsHydration, q = e.getInstanceFromNode, Z = e.preparePortalMount, $ = e.getCurrentEventPriority, ee = e.detachDeletedInstance, te = e.supportsMicrotasks, ne = e.scheduleMicrotask, re = e.supportsTestSelectors, ie = e.findFiberRoot, ae = e.getBoundingRect, oe = e.getTextContent, se = e.isHiddenSubtree, le = e.matchAccessibilityRole, ce = e.setFocusIfFocusable, ue = e.setupIntersectionObserver, de = e.appendChild, he = e.appendChildToContainer, pe = e.commitTextUpdate, fe = e.commitMount, me = e.commitUpdate, ge = e.insertBefore, ve = e.insertInContainerBefore, ye = e.removeChild, be = e.removeChildFromContainer, xe = e.resetTextContent, Ae = e.hideInstance, Se = e.hideTextInstance, Me = e.unhideInstance, we = e.unhideTextInstance, _e = e.clearContainer, Ee = e.cloneInstance, Ce = e.createContainerChildSet, Te = e.appendChildToContainerChildSet, Re = e.finalizeContainerChildren, Be = e.replaceContainerChildren, Ie = e.cloneHiddenInstance, Pe = e.cloneHiddenTextInstance, Le = e.canHydrateInstance, De = e.canHydrateTextInstance, ke = e.canHydrateSuspenseInstance, Ne = e.isSuspenseInstancePending, Fe = e.isSuspenseInstanceFallback, Oe = e.registerSuspenseInstanceRetry, Ue = e.getNextHydratableSibling, ze = e.getFirstHydratableChild, He = e.getFirstHydratableChildWithinContainer, Ge = e.getFirstHydratableChildWithinSuspenseInstance, je = e.hydrateInstance, Ve = e.hydrateTextInstance, We = e.hydrateSuspenseInstance, Xe = e.getNextHydratableInstanceAfterSuspenseInstance, Je = e.commitHydratedContainer, Ye = e.commitHydratedSuspenseInstance, Qe = e.clearSuspenseBoundary, Ke = e.clearSuspenseBoundaryFromContainer, qe = e.shouldDeleteUnhydratedTailInstances, Ze = e.didNotMatchHydratedContainerTextInstance, $e = e.didNotMatchHydratedTextInstance; function et(e) { if (void 0 === I) try { throw Error() } catch (e) { var t = e.stack.trim().match(/\n( *(at )?)/); I = t && t[1] || "" } return "\n" + I + e } var tt = !1; function nt(e, t) { if (!e || tt) return ""; tt = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" == typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (e) { var r = e } Reflect.construct(e, [], t) } else { try { t.call() } catch (e) { r = e } e.call(t.prototype) } else { try { throw Error() } catch (e) { r = e } e() } } catch (t) { if (t && r && "string" == typeof t.stack) { for (var i = t.stack.split("\n"), a = r.stack.split("\n"), o = i.length - 1, s = a.length - 1; 1 <= o && 0 <= s && i[o] !== a[s];)s--; for (; 1 <= o && 0 <= s; o--, s--)if (i[o] !== a[s]) { if (1 !== o || 1 !== s) do { if (o--, 0 > --s || i[o] !== a[s]) { var l = "\n" + i[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= o && 0 <= s); break } } } finally { tt = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? et(e) : "" } var rt = Object.prototype.hasOwnProperty, it = [], at = -1; function ot(e) { return { current: e } } function st(e) { 0 > at || (e.current = it[at], it[at] = null, at--) } function lt(e, t) { at++, it[at] = e.current, e.current = t } var ct = {}, ut = ot(ct), dt = ot(!1), ht = ct; function pt(e, t) { var n = e.type.contextTypes; if (!n) return ct; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, a = {}; for (i in n) a[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = a), a } function ft(e) { return null != e.childContextTypes } function mt() { st(dt), st(ut) } function gt(e, t, n) { if (ut.current !== ct) throw Error(o(168)); lt(ut, t), lt(dt, n) } function vt(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" != typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(o(108, w(e) || "Unknown", i)); return a({}, n, r) } function yt(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ct, ht = ut.current, lt(ut, e), lt(dt, dt.current), !0 } function bt(e, t, n) { var r = e.stateNode; if (!r) throw Error(o(169)); n ? (e = vt(e, t, ht), r.__reactInternalMemoizedMergedChildContext = e, st(dt), st(ut), lt(ut, e)) : st(dt), lt(dt, n) } var xt = Math.clz32 ? Math.clz32 : function (e) { return 0 == (e >>>= 0) ? 32 : 31 - (At(e) / St | 0) | 0 }, At = Math.log, St = Math.LN2, Mt = 64, wt = 4194304; function _t(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Et(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, a = e.pingedLanes, o = 268435455 & n; if (0 !== o) { var s = o & ~i; 0 !== s ? r = _t(s) : 0 != (a &= o) && (r = _t(a)) } else 0 != (o = n & ~i) ? r = _t(o) : 0 !== a && (r = _t(a)); if (0 === r) return 0; if (0 !== t && t !== r && !(t & i) && ((i = r & -r) >= (a = t & -t) || 16 === i && 4194240 & a)) return t; if (4 & r && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - xt(t)), r |= e[n], t &= ~i; return r } function Ct(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function Tt(e) { return 0 != (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function Rt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Bt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - xt(t)] = n } function It(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - xt(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var Pt = 0; function Lt(e) { return 1 < (e &= -e) ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1 } var Dt = i.unstable_scheduleCallback, kt = i.unstable_cancelCallback, Nt = i.unstable_shouldYield, Ft = i.unstable_requestPaint, Ot = i.unstable_now, Ut = i.unstable_ImmediatePriority, zt = i.unstable_UserBlockingPriority, Ht = i.unstable_NormalPriority, Gt = i.unstable_IdlePriority, jt = null, Vt = null, Wt = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, Xt = null, Jt = !1, Yt = !1; function Qt(e) { null === Xt ? Xt = [e] : Xt.push(e) } function Kt() { if (!Yt && null !== Xt) { Yt = !0; var e = 0, t = Pt; try { var n = Xt; for (Pt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Xt = null, Jt = !1 } catch (t) { throw null !== Xt && (Xt = Xt.slice(e + 1)), Dt(Ut, Kt), t } finally { Pt = t, Yt = !1 } } return null } var qt = s.ReactCurrentBatchConfig; function Zt(e, t) { if (Wt(e, t)) return !0; if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!rt.call(t, i) || !Wt(e[i], t[i])) return !1 } return !0 } function $t(e) { switch (e.tag) { case 5: return et(e.type); case 16: return et("Lazy"); case 13: return et("Suspense"); case 19: return et("SuspenseList"); case 0: case 2: case 15: return nt(e.type, !1); case 11: return nt(e.type.render, !1); case 1: return nt(e.type, !0); default: return "" } } function en(e, t) { if (e && e.defaultProps) { for (var n in t = a({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var tn = ot(null), nn = null, rn = null, an = null; function on() { an = rn = nn = null } function sn(e, t, n) { J ? (lt(tn, t._currentValue), t._currentValue = n) : (lt(tn, t._currentValue2), t._currentValue2 = n) } function ln(e) { var t = tn.current; st(tn), J ? e._currentValue = t : e._currentValue2 = t } function cn(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function un(e, t) { nn = e, an = rn = null, null !== (e = e.dependencies) && null !== e.firstContext && (!!(e.lanes & t) && (Ni = !0), e.firstContext = null) } function dn(e) { var t = J ? e._currentValue : e._currentValue2; if (an !== e) if (e = { context: e, memoizedValue: t, next: null }, null === rn) { if (null === nn) throw Error(o(308)); rn = e, nn.dependencies = { lanes: 0, firstContext: e } } else rn = rn.next = e; return t } var hn = null, pn = !1; function fn(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function mn(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function gn(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function vn(e, t) { var n = e.updateQueue; null !== n && (n = n.shared, null !== Ya && 1 & e.mode && !(2 & Ja) ? (null === (e = n.interleaved) ? (t.next = t, null === hn ? hn = [n] : hn.push(n)) : (t.next = e.next, e.next = t), n.interleaved = t) : (null === (e = n.pending) ? t.next = t : (t.next = e.next, e.next = t), n.pending = t)) } function yn(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, It(e, n) } } function bn(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, a = null; if (null !== (n = n.firstBaseUpdate)) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === a ? i = a = o : a = a.next = o, n = n.next } while (null !== n); null === a ? i = a = t : a = a.next = t } else i = a = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: a, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function xn(e, t, n, r) { var i = e.updateQueue; pn = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, l = i.shared.pending; if (null !== l) { i.shared.pending = null; var c = l, u = c.next; c.next = null, null === s ? o = u : s.next = u, s = c; var d = e.alternate; null !== d && (l = (d = d.updateQueue).lastBaseUpdate) !== s && (null === l ? d.firstBaseUpdate = u : l.next = u, d.lastBaseUpdate = c) } if (null !== o) { var h = i.baseState; for (s = 0, d = u = c = null, l = o; ;) { var p = l.lane, f = l.eventTime; if ((r & p) === p) { null !== d && (d = d.next = { eventTime: f, lane: 0, tag: l.tag, payload: l.payload, callback: l.callback, next: null }); e: { var m = e, g = l; switch (p = t, f = n, g.tag) { case 1: if ("function" == typeof (m = g.payload)) { h = m.call(f, h, p); break e } h = m; break e; case 3: m.flags = -65537 & m.flags | 128; case 0: if (null == (p = "function" == typeof (m = g.payload) ? m.call(f, h, p) : m)) break e; h = a({}, h, p); break e; case 2: pn = !0 } } null !== l.callback && 0 !== l.lane && (e.flags |= 64, null === (p = i.effects) ? i.effects = [l] : p.push(l)) } else f = { eventTime: f, lane: p, tag: l.tag, payload: l.payload, callback: l.callback, next: null }, null === d ? (u = d = f, c = h) : d = d.next = f, s |= p; if (null === (l = l.next)) { if (null === (l = i.shared.pending)) break; l = (p = l).next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null } } if (null === d && (c = h), i.baseState = c, i.firstBaseUpdate = u, i.lastBaseUpdate = d, null !== (t = i.shared.interleaved)) { i = t; do { s |= i.lane, i = i.next } while (i !== t) } else null === o && (i.shared.lanes = 0); to |= s, e.lanes = s, e.memoizedState = h } } function An(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" != typeof i) throw Error(o(191, i)); i.call(r) } } } var Sn = (new r.Component).refs; function Mn(e, t, n, r) { n = null == (n = n(r, t = e.memoizedState)) ? t : a({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var wn = { isMounted: function (e) { return !!(e = e._reactInternals) && _(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Ao(), i = So(e), a = gn(r, i); a.payload = t, null != n && (a.callback = n), vn(e, a), null !== (t = Mo(e, i, r)) && yn(t, e, i) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Ao(), i = So(e), a = gn(r, i); a.tag = 1, a.payload = t, null != n && (a.callback = n), vn(e, a), null !== (t = Mo(e, i, r)) && yn(t, e, i) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Ao(), r = So(e), i = gn(n, r); i.tag = 2, null != t && (i.callback = t), vn(e, i), null !== (t = Mo(e, r, n)) && yn(t, e, r) } }; function _n(e, t, n, r, i, a, o) { return "function" == typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, a, o) : !(t.prototype && t.prototype.isPureReactComponent && Zt(n, r) && Zt(i, a)) } function En(e, t, n) { var r = !1, i = ct, a = t.contextType; return "object" == typeof a && null !== a ? a = dn(a) : (i = ft(t) ? ht : ut.current, a = (r = null != (r = t.contextTypes)) ? pt(e, i) : ct), t = new t(n, a), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = wn, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = a), t } function Cn(e, t, n, r) { e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && wn.enqueueReplaceState(t, t.state, null) } function Tn(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = Sn, fn(e); var a = t.contextType; "object" == typeof a && null !== a ? i.context = dn(a) : (a = ft(t) ? ht : ut.current, i.context = pt(e, a)), i.state = e.memoizedState, "function" == typeof (a = t.getDerivedStateFromProps) && (Mn(e, t, a, n), i.state = e.memoizedState), "function" == typeof t.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (t = i.state, "function" == typeof i.componentWillMount && i.componentWillMount(), "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && wn.enqueueReplaceState(i, i.state, null), xn(e, n, i, r), i.state = e.memoizedState), "function" == typeof i.componentDidMount && (e.flags |= 4194308) } var Rn = [], Bn = 0, In = null, Pn = 0, Ln = [], Dn = 0, kn = null, Nn = 1, Fn = ""; function On(e, t) { Rn[Bn++] = Pn, Rn[Bn++] = In, In = e, Pn = t } function Un(e, t, n) { Ln[Dn++] = Nn, Ln[Dn++] = Fn, Ln[Dn++] = kn, kn = e; var r = Nn; e = Fn; var i = 32 - xt(r) - 1; r &= ~(1 << i), n += 1; var a = 32 - xt(t) + i; if (30 < a) { var o = i - i % 5; a = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Nn = 1 << 32 - xt(t) + i | n << i | r, Fn = a + e } else Nn = 1 << a | n << i | r, Fn = e } function zn(e) { null !== e.return && (On(e, 1), Un(e, 1, 0)) } function Hn(e) { for (; e === In;)In = Rn[--Bn], Rn[Bn] = null, Pn = Rn[--Bn], Rn[Bn] = null; for (; e === kn;)kn = Ln[--Dn], Ln[Dn] = null, Fn = Ln[--Dn], Ln[Dn] = null, Nn = Ln[--Dn], Ln[Dn] = null } var Gn = null, jn = null, Vn = !1, Wn = !1, Xn = null; function Jn(e, t) { var n = Zo(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Yn(e, t) { switch (e.tag) { case 5: return null !== (t = Le(t, e.type, e.pendingProps)) && (e.stateNode = t, Gn = e, jn = ze(t), !0); case 6: return null !== (t = De(t, e.pendingProps)) && (e.stateNode = t, Gn = e, jn = null, !0); case 13: if (null !== (t = ke(t))) { var n = null !== kn ? { id: Nn, overflow: Fn } : null; return e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Zo(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, Gn = e, jn = null, !0 } return !1; default: return !1 } } function Qn(e) { return !(!(1 & e.mode) || 128 & e.flags) } function Kn(e) { if (Vn) { var t = jn; if (t) { var n = t; if (!Yn(e, t)) { if (Qn(e)) throw Error(o(418)); t = Ue(n); var r = Gn; t && Yn(e, t) ? Jn(r, n) : (e.flags = -4097 & e.flags | 2, Vn = !1, Gn = e) } } else { if (Qn(e)) throw Error(o(418)); e.flags = -4097 & e.flags | 2, Vn = !1, Gn = e } } } function qn(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; Gn = e } function Zn(e) { if (!K || e !== Gn) return !1; if (!Vn) return qn(e), Vn = !0, !1; if (3 !== e.tag && (5 !== e.tag || qe(e.type) && !G(e.type, e.memoizedProps))) { var t = jn; if (t) { if (Qn(e)) { for (e = jn; e;)e = Ue(e); throw Error(o(418)) } for (; t;)Jn(e, t), t = Ue(t) } } if (qn(e), 13 === e.tag) { if (!K) throw Error(o(316)); if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317)); jn = Xe(e) } else jn = Gn ? Ue(e.stateNode) : null; return !0 } function $n() { K && (jn = Gn = null, Wn = Vn = !1) } function er(e) { null === Xn ? Xn = [e] : Xn.push(e) } function tr(e, t, n) { if (null !== (e = n.ref) && "function" != typeof e && "object" != typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(o(309)); var r = n.stateNode } if (!r) throw Error(o(147, e)); var i = r, a = "" + e; return null !== t && null !== t.ref && "function" == typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function (e) { var t = i.refs; t === Sn && (t = i.refs = {}), null === e ? delete t[a] : t[a] = e }, t._stringRef = a, t) } if ("string" != typeof e) throw Error(o(284)); if (!n._owner) throw Error(o(290, e)) } return e } function nr(e, t) { throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function rr(e) { return (0, e._init)(e._payload) } function ir(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = es(e, t)).index = 0, e.sibling = null, e } function a(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function s(t) { return e && null === t.alternate && (t.flags |= 2), t } function d(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = is(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function h(e, t, n, r) { var a = n.type; return a === u ? f(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === a || "object" == typeof a && null !== a && a.$$typeof === b && rr(a) === t.type) ? ((r = i(t, n.props)).ref = tr(e, t, n), r.return = e, r) : ((r = ts(n.type, n.key, n.props, null, e.mode, r)).ref = tr(e, t, n), r.return = e, r) } function p(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = as(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function f(e, t, n, r, a) { return null === t || 7 !== t.tag ? ((t = ns(n, e.mode, r, a)).return = e, t) : ((t = i(t, n)).return = e, t) } function m(e, t, n) { if ("string" == typeof t && "" !== t || "number" == typeof t) return (t = is("" + t, e.mode, n)).return = e, t; if ("object" == typeof t && null !== t) { switch (t.$$typeof) { case l: return (n = ts(t.type, t.key, t.props, null, e.mode, n)).ref = tr(e, null, t), n.return = e, n; case c: return (t = as(t, e.mode, n)).return = e, t; case b: return m(e, (0, t._init)(t._payload), n) }if (P(t) || S(t)) return (t = ns(t, e.mode, n, null)).return = e, t; nr(e, t) } return null } function g(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" == typeof n && "" !== n || "number" == typeof n) return null !== i ? null : d(e, t, "" + n, r); if ("object" == typeof n && null !== n) { switch (n.$$typeof) { case l: return n.key === i ? h(e, t, n, r) : null; case c: return n.key === i ? p(e, t, n, r) : null; case b: return g(e, t, (i = n._init)(n._payload), r) }if (P(n) || S(n)) return null !== i ? null : f(e, t, n, r, null); nr(e, n) } return null } function v(e, t, n, r, i) { if ("string" == typeof r && "" !== r || "number" == typeof r) return d(t, e = e.get(n) || null, "" + r, i); if ("object" == typeof r && null !== r) { switch (r.$$typeof) { case l: return h(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case c: return p(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case b: return v(e, t, n, (0, r._init)(r._payload), i) }if (P(r) || S(r)) return f(t, e = e.get(n) || null, r, i, null); nr(t, r) } return null } function y(i, o, s, l) { for (var c = null, u = null, d = o, h = o = 0, p = null; null !== d && h < s.length; h++) { d.index > h ? (p = d, d = null) : p = d.sibling; var f = g(i, d, s[h], l); if (null === f) { null === d && (d = p); break } e && d && null === f.alternate && t(i, d), o = a(f, o, h), null === u ? c = f : u.sibling = f, u = f, d = p } if (h === s.length) return n(i, d), Vn && On(i, h), c; if (null === d) { for (; h < s.length; h++)null !== (d = m(i, s[h], l)) && (o = a(d, o, h), null === u ? c = d : u.sibling = d, u = d); return Vn && On(i, h), c } for (d = r(i, d); h < s.length; h++)null !== (p = v(d, i, h, s[h], l)) && (e && null !== p.alternate && d.delete(null === p.key ? h : p.key), o = a(p, o, h), null === u ? c = p : u.sibling = p, u = p); return e && d.forEach((function (e) { return t(i, e) })), Vn && On(i, h), c } function x(i, s, l, c) { var u = S(l); if ("function" != typeof u) throw Error(o(150)); if (null == (l = u.call(l))) throw Error(o(151)); for (var d = u = null, h = s, p = s = 0, f = null, y = l.next(); null !== h && !y.done; p++, y = l.next()) { h.index > p ? (f = h, h = null) : f = h.sibling; var b = g(i, h, y.value, c); if (null === b) { null === h && (h = f); break } e && h && null === b.alternate && t(i, h), s = a(b, s, p), null === d ? u = b : d.sibling = b, d = b, h = f } if (y.done) return n(i, h), Vn && On(i, p), u; if (null === h) { for (; !y.done; p++, y = l.next())null !== (y = m(i, y.value, c)) && (s = a(y, s, p), null === d ? u = y : d.sibling = y, d = y); return Vn && On(i, p), u } for (h = r(i, h); !y.done; p++, y = l.next())null !== (y = v(h, i, p, y.value, c)) && (e && null !== y.alternate && h.delete(null === y.key ? p : y.key), s = a(y, s, p), null === d ? u = y : d.sibling = y, d = y); return e && h.forEach((function (e) { return t(i, e) })), Vn && On(i, p), u } return function e(r, a, o, d) { if ("object" == typeof o && null !== o && o.type === u && null === o.key && (o = o.props.children), "object" == typeof o && null !== o) { switch (o.$$typeof) { case l: e: { for (var h = o.key, p = a; null !== p;) { if (p.key === h) { if ((h = o.type) === u) { if (7 === p.tag) { n(r, p.sibling), (a = i(p, o.props.children)).return = r, r = a; break e } } else if (p.elementType === h || "object" == typeof h && null !== h && h.$$typeof === b && rr(h) === p.type) { n(r, p.sibling), (a = i(p, o.props)).ref = tr(r, p, o), a.return = r, r = a; break e } n(r, p); break } t(r, p), p = p.sibling } o.type === u ? ((a = ns(o.props.children, r.mode, d, o.key)).return = r, r = a) : ((d = ts(o.type, o.key, o.props, null, r.mode, d)).ref = tr(r, a, o), d.return = r, r = d) } return s(r); case c: e: { for (p = o.key; null !== a;) { if (a.key === p) { if (4 === a.tag && a.stateNode.containerInfo === o.containerInfo && a.stateNode.implementation === o.implementation) { n(r, a.sibling), (a = i(a, o.children || [])).return = r, r = a; break e } n(r, a); break } t(r, a), a = a.sibling } (a = as(o, r.mode, d)).return = r, r = a } return s(r); case b: return e(r, a, (p = o._init)(o._payload), d) }if (P(o)) return y(r, a, o, d); if (S(o)) return x(r, a, o, d); nr(r, o) } return "string" == typeof o && "" !== o || "number" == typeof o ? (o = "" + o, null !== a && 6 === a.tag ? (n(r, a.sibling), (a = i(a, o)).return = r, r = a) : (n(r, a), (a = is(o, r.mode, d)).return = r, r = a), s(r)) : n(r, a) } } var ar = ir(!0), or = ir(!1), sr = {}, lr = ot(sr), cr = ot(sr), ur = ot(sr); function dr(e) { if (e === sr) throw Error(o(174)); return e } function hr(e, t) { lt(ur, t), lt(cr, e), lt(lr, sr), e = D(t), st(lr), lt(lr, e) } function pr() { st(lr), st(cr), st(ur) } function fr(e) { var t = dr(ur.current), n = dr(lr.current); n !== (t = k(n, e.type, t)) && (lt(cr, e), lt(lr, t)) } function mr(e) { cr.current === e && (st(lr), st(cr)) } var gr = ot(0); function vr(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || Ne(n) || Fe(n))) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (128 & t.flags) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var yr = []; function br() { for (var e = 0; e < yr.length; e++) { var t = yr[e]; J ? t._workInProgressVersionPrimary = null : t._workInProgressVersionSecondary = null } yr.length = 0 } var xr = s.ReactCurrentDispatcher, Ar = s.ReactCurrentBatchConfig, Sr = 0, Mr = null, wr = null, _r = null, Er = !1, Cr = !1, Tr = 0, Rr = 0; function Br() { throw Error(o(321)) } function Ir(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Wt(e[n], t[n])) return !1; return !0 } function Pr(e, t, n, r, i, a) { if (Sr = a, Mr = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, xr.current = null === e || null === e.memoizedState ? fi : mi, e = n(r, i), Cr) { a = 0; do { if (Cr = !1, Tr = 0, 25 <= a) throw Error(o(301)); a += 1, _r = wr = null, t.updateQueue = null, xr.current = gi, e = n(r, i) } while (Cr) } if (xr.current = pi, t = null !== wr && null !== wr.next, Sr = 0, _r = wr = Mr = null, Er = !1, t) throw Error(o(300)); return e } function Lr() { var e = 0 !== Tr; return Tr = 0, e } function Dr() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === _r ? Mr.memoizedState = _r = e : _r = _r.next = e, _r } function kr() { if (null === wr) { var e = Mr.alternate; e = null !== e ? e.memoizedState : null } else e = wr.next; var t = null === _r ? Mr.memoizedState : _r.next; if (null !== t) _r = t, wr = e; else { if (null === e) throw Error(o(310)); e = { memoizedState: (wr = e).memoizedState, baseState: wr.baseState, baseQueue: wr.baseQueue, queue: wr.queue, next: null }, null === _r ? Mr.memoizedState = _r = e : _r = _r.next = e } return _r } function Nr(e, t) { return "function" == typeof t ? t(e) : t } function Fr(e) { var t = kr(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = wr, i = r.baseQueue, a = n.pending; if (null !== a) { if (null !== i) { var s = i.next; i.next = a.next, a.next = s } r.baseQueue = i = a, n.pending = null } if (null !== i) { a = i.next, r = r.baseState; var l = s = null, c = null, u = a; do { var d = u.lane; if ((Sr & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, s = r) : c = c.next = h, Mr.lanes |= d, to |= d } u = u.next } while (null !== u && u !== a); null === c ? s = r : c.next = l, Wt(r, t.memoizedState) || (Ni = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { a = i.lane, Mr.lanes |= a, to |= a, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Or(e) { var t = kr(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, a = t.memoizedState; if (null !== i) { n.pending = null; var s = i = i.next; do { a = e(a, s.action), s = s.next } while (s !== i); Wt(a, t.memoizedState) || (Ni = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a } return [a, r] } function Ur() { } function zr(e, t) { var n = Mr, r = kr(), i = t(), a = !Wt(r.memoizedState, i); if (a && (r.memoizedState = i, Ni = !0), r = r.queue, qr(jr.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== _r && 1 & _r.memoizedState.tag) { if (n.flags |= 2048, Xr(9, Gr.bind(null, n, r, i, t), void 0, null), null === Ya) throw Error(o(349)); 30 & Sr || Hr(n, t, i) } return i } function Hr(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = Mr.updateQueue) ? (t = { lastEffect: null, stores: null }, Mr.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Gr(e, t, n, r) { t.value = n, t.getSnapshot = r, Vr(t) && Mo(e, 1, -1) } function jr(e, t, n) { return n((function () { Vr(t) && Mo(e, 1, -1) })) } function Vr(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Wt(e, n) } catch (e) { return !0 } } function Wr(e) { var t = Dr(); return "function" == typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Nr, lastRenderedState: e }, t.queue = e, e = e.dispatch = li.bind(null, Mr, e), [t.memoizedState, e] } function Xr(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = Mr.updateQueue) ? (t = { lastEffect: null, stores: null }, Mr.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function Jr() { return kr().memoizedState } function Yr(e, t, n, r) { var i = Dr(); Mr.flags |= e, i.memoizedState = Xr(1 | t, n, void 0, void 0 === r ? null : r) } function Qr(e, t, n, r) { var i = kr(); r = void 0 === r ? null : r; var a = void 0; if (null !== wr) { var o = wr.memoizedState; if (a = o.destroy, null !== r && Ir(r, o.deps)) return void (i.memoizedState = Xr(t, n, a, r)) } Mr.flags |= e, i.memoizedState = Xr(1 | t, n, a, r) } function Kr(e, t) { return Yr(8390656, 8, e, t) } function qr(e, t) { return Qr(2048, 8, e, t) } function Zr(e, t) { return Qr(4, 2, e, t) } function $r(e, t) { return Qr(4, 4, e, t) } function ei(e, t) { return "function" == typeof t ? (e = e(), t(e), function () { t(null) }) : null != t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function ti(e, t, n) { return n = null != n ? n.concat([e]) : null, Qr(4, 4, ei.bind(null, t, e), n) } function ni() { } function ri(e, t) { var n = kr(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && Ir(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function ii(e, t) { var n = kr(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && Ir(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function ai(e, t) { var n = Pt; Pt = 0 !== n && 4 > n ? n : 4, e(!0); var r = Ar.transition; Ar.transition = {}; try { e(!1), t() } finally { Pt = n, Ar.transition = r } } function oi() { return kr().memoizedState } function si(e, t, n) { var r = So(e); n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, ci(e) ? ui(t, n) : (di(e, t, n), null !== (e = Mo(e, r, n = Ao())) && hi(e, t, r)) } function li(e, t, n) { var r = So(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (ci(e)) ui(t, i); else { di(e, t, i); var a = e.alternate; if (0 === e.lanes && (null === a || 0 === a.lanes) && null !== (a = t.lastRenderedReducer)) try { var o = t.lastRenderedState, s = a(o, n); if (i.hasEagerState = !0, i.eagerState = s, Wt(s, o)) return } catch (e) { } null !== (e = Mo(e, r, n = Ao())) && hi(e, t, r) } } function ci(e) { var t = e.alternate; return e === Mr || null !== t && t === Mr } function ui(e, t) { Cr = Er = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function di(e, t, n) { null !== Ya && 1 & e.mode && !(2 & Ja) ? (null === (e = t.interleaved) ? (n.next = n, null === hn ? hn = [t] : hn.push(t)) : (n.next = e.next, e.next = n), t.interleaved = n) : (null === (e = t.pending) ? n.next = n : (n.next = e.next, e.next = n), t.pending = n) } function hi(e, t, n) { if (4194240 & n) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, It(e, n) } } var pi = { readContext: dn, useCallback: Br, useContext: Br, useEffect: Br, useImperativeHandle: Br, useInsertionEffect: Br, useLayoutEffect: Br, useMemo: Br, useReducer: Br, useRef: Br, useState: Br, useDebugValue: Br, useDeferredValue: Br, useTransition: Br, useMutableSource: Br, useSyncExternalStore: Br, useId: Br, unstable_isNewReconciler: !1 }, fi = { readContext: dn, useCallback: function (e, t) { return Dr().memoizedState = [e, void 0 === t ? null : t], e }, useContext: dn, useEffect: Kr, useImperativeHandle: function (e, t, n) { return n = null != n ? n.concat([e]) : null, Yr(4194308, 4, ei.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Yr(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Yr(4, 2, e, t) }, useMemo: function (e, t) { var n = Dr(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Dr(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = si.bind(null, Mr, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, Dr().memoizedState = e }, useState: Wr, useDebugValue: ni, useDeferredValue: function (e) { var t = Wr(e), n = t[0], r = t[1]; return Kr((function () { var t = Ar.transition; Ar.transition = {}; try { r(e) } finally { Ar.transition = t } }), [e]), n }, useTransition: function () { var e = Wr(!1), t = e[0]; return e = ai.bind(null, e[1]), Dr().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = Mr, i = Dr(); if (Vn) { if (void 0 === n) throw Error(o(407)); n = n() } else { if (n = t(), null === Ya) throw Error(o(349)); 30 & Sr || Hr(r, t, n) } i.memoizedState = n; var a = { value: n, getSnapshot: t }; return i.queue = a, Kr(jr.bind(null, r, a, e), [e]), r.flags |= 2048, Xr(9, Gr.bind(null, r, a, n, t), void 0, null), n }, useId: function () { var e = Dr(), t = Ya.identifierPrefix; if (Vn) { var n = Fn; t = ":" + t + "R" + (n = (Nn & ~(1 << 32 - xt(Nn) - 1)).toString(32) + n), 0 < (n = Tr++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = Rr++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, mi = { readContext: dn, useCallback: ri, useContext: dn, useEffect: qr, useImperativeHandle: ti, useInsertionEffect: Zr, useLayoutEffect: $r, useMemo: ii, useReducer: Fr, useRef: Jr, useState: function () { return Fr(Nr) }, useDebugValue: ni, useDeferredValue: function (e) { var t = Fr(Nr), n = t[0], r = t[1]; return qr((function () { var t = Ar.transition; Ar.transition = {}; try { r(e) } finally { Ar.transition = t } }), [e]), n }, useTransition: function () { return [Fr(Nr)[0], kr().memoizedState] }, useMutableSource: Ur, useSyncExternalStore: zr, useId: oi, unstable_isNewReconciler: !1 }, gi = { readContext: dn, useCallback: ri, useContext: dn, useEffect: qr, useImperativeHandle: ti, useInsertionEffect: Zr, useLayoutEffect: $r, useMemo: ii, useReducer: Or, useRef: Jr, useState: function () { return Or(Nr) }, useDebugValue: ni, useDeferredValue: function (e) { var t = Or(Nr), n = t[0], r = t[1]; return qr((function () { var t = Ar.transition; Ar.transition = {}; try { r(e) } finally { Ar.transition = t } }), [e]), n }, useTransition: function () { return [Or(Nr)[0], kr().memoizedState] }, useMutableSource: Ur, useSyncExternalStore: zr, useId: oi, unstable_isNewReconciler: !1 }; function vi(e, t) { try { var n = "", r = t; do { n += $t(r), r = r.return } while (r); var i = n } catch (e) { i = "\nError generating stack: " + e.message + "\n" + e.stack } return { value: e, source: t, stack: i } } function yi(e, t) { try { console.error(t.value) } catch (e) { setTimeout((function () { throw e })) } } var bi, xi, Ai, Si, Mi = "function" == typeof WeakMap ? WeakMap : Map; function wi(e, t, n) { (n = gn(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { uo || (uo = !0, ho = r), yi(0, t) }, n } function _i(e, t, n) { (n = gn(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" == typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { yi(0, t) } } var a = e.stateNode; return null !== a && "function" == typeof a.componentDidCatch && (n.callback = function () { yi(0, t), "function" != typeof r && (null === po ? po = new Set([this]) : po.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function Ei(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new Mi; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Xo.bind(null, e, t, n), t.then(e, e)) } function Ci(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function Ti(e, t, n, r, i) { return 1 & e.mode ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = gn(-1, 1)).tag = 2, vn(n, t))), n.lanes |= 1), e) } function Ri(e) { e.flags |= 4 } function Bi(e, t) { if (null !== e && e.child === t.child) return !0; if (16 & t.flags) return !1; for (e = t.child; null !== e;) { if (12854 & e.flags || 12854 & e.subtreeFlags) return !1; e = e.sibling } return !0 } if (Y) bi = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) U(e, n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, xi = function () { }, Ai = function (e, t, n, r, i) { if ((e = e.memoizedProps) !== r) { var a = t.stateNode, o = dr(lr.current); n = H(a, n, e, r, i, o), (t.updateQueue = n) && Ri(t) } }, Si = function (e, t, n, r) { n !== r && Ri(t) }; else if (Q) { bi = function (e, t, n, r) { for (var i = t.child; null !== i;) { if (5 === i.tag) { var a = i.stateNode; n && r && (a = Ie(a, i.type, i.memoizedProps, i)), U(e, a) } else if (6 === i.tag) a = i.stateNode, n && r && (a = Pe(a, i.memoizedProps, i)), U(e, a); else if (4 !== i.tag) if (22 === i.tag && null !== i.memoizedState) null !== (a = i.child) && (a.return = i), bi(e, i, !0, !0); else if (null !== i.child) { i.child.return = i, i = i.child; continue } if (i === t) break; for (; null === i.sibling;) { if (null === i.return || i.return === t) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }; var Ii = function (e, t, n, r) { for (var i = t.child; null !== i;) { if (5 === i.tag) { var a = i.stateNode; n && r && (a = Ie(a, i.type, i.memoizedProps, i)), Te(e, a) } else if (6 === i.tag) a = i.stateNode, n && r && (a = Pe(a, i.memoizedProps, i)), Te(e, a); else if (4 !== i.tag) if (22 === i.tag && null !== i.memoizedState) null !== (a = i.child) && (a.return = i), Ii(e, i, !0, !0); else if (null !== i.child) { i.child.return = i, i = i.child; continue } if (i === t) break; for (; null === i.sibling;) { if (null === i.return || i.return === t) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }; xi = function (e, t) { var n = t.stateNode; if (!Bi(e, t)) { e = n.containerInfo; var r = Ce(e); Ii(r, t, !1, !1), n.pendingChildren = r, Ri(t), Re(e, r) } }, Ai = function (e, t, n, r, i) { var a = e.stateNode, o = e.memoizedProps; if ((e = Bi(e, t)) && o === r) t.stateNode = a; else { var s = t.stateNode, l = dr(lr.current), c = null; o !== r && (c = H(s, n, o, r, i, l)), e && null === c ? t.stateNode = a : (a = Ee(a, c, n, o, r, t, e, s), z(a, n, r, i, l) && Ri(t), t.stateNode = a, e ? Ri(t) : bi(a, t, !1, !1)) } }, Si = function (e, t, n, r) { n !== r ? (e = dr(ur.current), n = dr(lr.current), t.stateNode = j(r, e, n, t), Ri(t)) : t.stateNode = e.stateNode } } else xi = function () { }, Ai = function () { }, Si = function () { }; function Pi(e, t) { if (!Vn) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Li(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Di(e, t, n) { var r = t.pendingProps; switch (Hn(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Li(t), null; case 1: case 17: return ft(t.type) && mt(), Li(t), null; case 3: return r = t.stateNode, pr(), st(dt), st(ut), br(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (Zn(t) ? Ri(t) : null === e || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024, null !== Xn && (To(Xn), Xn = null))), xi(e, t), Li(t), null; case 5: mr(t), n = dr(ur.current); var i = t.type; if (null !== e && null != t.stateNode) Ai(e, t, i, r, n), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(o(166)); return Li(t), null } if (e = dr(lr.current), Zn(t)) { if (!K) throw Error(o(175)); e = je(t.stateNode, t.type, t.memoizedProps, n, e, t, !Wn), t.updateQueue = e, null !== e && Ri(t) } else { var a = O(i, r, n, e, t); bi(a, t, !1, !1), t.stateNode = a, z(a, i, r, n, e) && Ri(t) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Li(t), null; case 6: if (e && null != t.stateNode) Si(e, t, e.memoizedProps, r); else { if ("string" != typeof r && null === t.stateNode) throw Error(o(166)); if (e = dr(ur.current), n = dr(lr.current), Zn(t)) { if (!K) throw Error(o(176)); if (e = t.stateNode, r = t.memoizedProps, (n = Ve(e, r, t, !Wn)) && null !== (i = Gn)) switch (a = !!(1 & i.mode), i.tag) { case 3: Ze(i.stateNode.containerInfo, e, r, a); break; case 5: $e(i.type, i.memoizedProps, i.stateNode, e, r, a) }n && Ri(t) } else t.stateNode = j(r, e, n, t) } return Li(t), null; case 13: if (st(gr), r = t.memoizedState, Vn && null !== jn && 1 & t.mode && !(128 & t.flags)) { for (e = jn; e;)e = Ue(e); return $n(), t.flags |= 98560, t } if (null !== r && null !== r.dehydrated) { if (r = Zn(t), null === e) { if (!r) throw Error(o(318)); if (!K) throw Error(o(344)); if (!(e = null !== (e = t.memoizedState) ? e.dehydrated : null)) throw Error(o(317)); We(e, t) } else $n(), !(128 & t.flags) && (t.memoizedState = null), t.flags |= 4; return Li(t), null } return null !== Xn && (To(Xn), Xn = null), 128 & t.flags ? (t.lanes = n, t) : (r = null !== r, n = !1, null === e ? Zn(t) : n = null !== e.memoizedState, r && !n && (t.child.flags |= 8192, 1 & t.mode && (null === e || 1 & gr.current ? 0 === $a && ($a = 3) : No())), null !== t.updateQueue && (t.flags |= 4), Li(t), null); case 4: return pr(), xi(e, t), null === e && Z(t.stateNode.containerInfo), Li(t), null; case 10: return ln(t.type._context), Li(t), null; case 19: if (st(gr), null === (i = t.memoizedState)) return Li(t), null; if (r = !!(128 & t.flags), null === (a = i.rendering)) if (r) Pi(i, !1); else { if (0 !== $a || null !== e && 128 & e.flags) for (e = t.child; null !== e;) { if (null !== (a = vr(e))) { for (t.flags |= 128, Pi(i, !1), null !== (e = a.updateQueue) && (t.updateQueue = e, t.flags |= 4), t.subtreeFlags = 0, e = n, r = t.child; null !== r;)i = e, (n = r).flags &= 14680066, null === (a = n.alternate) ? (n.childLanes = 0, n.lanes = i, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = a.childLanes, n.lanes = a.lanes, n.child = a.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = a.memoizedProps, n.memoizedState = a.memoizedState, n.updateQueue = a.updateQueue, n.type = a.type, i = a.dependencies, n.dependencies = null === i ? null : { lanes: i.lanes, firstContext: i.firstContext }), r = r.sibling; return lt(gr, 1 & gr.current | 2), t.child } e = e.sibling } null !== i.tail && Ot() > so && (t.flags |= 128, r = !0, Pi(i, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = vr(a))) { if (t.flags |= 128, r = !0, null !== (e = e.updateQueue) && (t.updateQueue = e, t.flags |= 4), Pi(i, !0), null === i.tail && "hidden" === i.tailMode && !a.alternate && !Vn) return Li(t), null } else 2 * Ot() - i.renderingStartTime > so && 1073741824 !== n && (t.flags |= 128, r = !0, Pi(i, !1), t.lanes = 4194304); i.isBackwards ? (a.sibling = t.child, t.child = a) : (null !== (e = i.last) ? e.sibling = a : t.child = a, i.last = a) } return null !== i.tail ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = Ot(), t.sibling = null, e = gr.current, lt(gr, r ? 1 & e | 2 : 1 & e), t) : (Li(t), null); case 22: case 23: return Po(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 1 & t.mode ? !!(1073741824 & qa) && (Li(t), Y && 6 & t.subtreeFlags && (t.flags |= 8192)) : Li(t), null; case 24: case 25: return null }throw Error(o(156, t.tag)) } var ki = s.ReactCurrentOwner, Ni = !1; function Fi(e, t, n, r) { t.child = null === e ? or(t, null, n, r) : ar(t, e.child, n, r) } function Oi(e, t, n, r, i) { n = n.render; var a = t.ref; return un(t, i), r = Pr(e, t, n, r, a, i), n = Lr(), null === e || Ni ? (Vn && n && zn(t), t.flags |= 1, Fi(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, ia(e, t, i)) } function Ui(e, t, n, r, i) { if (null === e) { var a = n.type; return "function" != typeof a || $o(a) || void 0 !== a.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = ts(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = a, zi(e, t, a, r, i)) } if (a = e.child, !(e.lanes & i)) { var o = a.memoizedProps; if ((n = null !== (n = n.compare) ? n : Zt)(o, r) && e.ref === t.ref) return ia(e, t, i) } return t.flags |= 1, (e = es(a, r)).ref = t.ref, e.return = t, t.child = e } function zi(e, t, n, r, i) { if (null !== e && Zt(e.memoizedProps, r) && e.ref === t.ref) { if (Ni = !1, !(e.lanes & i)) return t.lanes = e.lanes, ia(e, t, i); 131072 & e.flags && (Ni = !0) } return ji(e, t, n, r, i) } function Hi(e, t, n) { var r = t.pendingProps, i = r.children, a = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (1 & t.mode) { if (!(1073741824 & n)) return e = null !== a ? a.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null }, t.updateQueue = null, lt(Za, qa), qa |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null }, r = null !== a ? a.baseLanes : n, lt(Za, qa), qa |= r } else t.memoizedState = { baseLanes: 0, cachePool: null }, lt(Za, qa), qa |= n; else null !== a ? (r = a.baseLanes | n, t.memoizedState = null) : r = n, lt(Za, qa), qa |= r; return Fi(e, t, i, n), t.child } function Gi(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function ji(e, t, n, r, i) { var a = ft(n) ? ht : ut.current; return a = pt(t, a), un(t, i), n = Pr(e, t, n, r, a, i), r = Lr(), null === e || Ni ? (Vn && r && zn(t), t.flags |= 1, Fi(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, ia(e, t, i)) } function Vi(e, t, n, r, i) { if (ft(n)) { var a = !0; yt(t) } else a = !1; if (un(t, i), null === t.stateNode) null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), En(t, n, r), Tn(t, n, r, i), r = !0; else if (null === e) { var o = t.stateNode, s = t.memoizedProps; o.props = s; var l = o.context, c = n.contextType; c = "object" == typeof c && null !== c ? dn(c) : pt(t, c = ft(n) ? ht : ut.current); var u = n.getDerivedStateFromProps, d = "function" == typeof u || "function" == typeof o.getSnapshotBeforeUpdate; d || "function" != typeof o.UNSAFE_componentWillReceiveProps && "function" != typeof o.componentWillReceiveProps || (s !== r || l !== c) && Cn(t, o, r, c), pn = !1; var h = t.memoizedState; o.state = h, xn(t, r, o, i), l = t.memoizedState, s !== r || h !== l || dt.current || pn ? ("function" == typeof u && (Mn(t, n, u, r), l = t.memoizedState), (s = pn || _n(t, n, s, r, h, l, c)) ? (d || "function" != typeof o.UNSAFE_componentWillMount && "function" != typeof o.componentWillMount || ("function" == typeof o.componentWillMount && o.componentWillMount(), "function" == typeof o.UNSAFE_componentWillMount && o.UNSAFE_componentWillMount()), "function" == typeof o.componentDidMount && (t.flags |= 4194308)) : ("function" == typeof o.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = c, r = s) : ("function" == typeof o.componentDidMount && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, mn(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : en(t.type, s), o.props = c, d = t.pendingProps, h = o.context, l = "object" == typeof (l = n.contextType) && null !== l ? dn(l) : pt(t, l = ft(n) ? ht : ut.current); var p = n.getDerivedStateFromProps; (u = "function" == typeof p || "function" == typeof o.getSnapshotBeforeUpdate) || "function" != typeof o.UNSAFE_componentWillReceiveProps && "function" != typeof o.componentWillReceiveProps || (s !== d || h !== l) && Cn(t, o, r, l), pn = !1, h = t.memoizedState, o.state = h, xn(t, r, o, i); var f = t.memoizedState; s !== d || h !== f || dt.current || pn ? ("function" == typeof p && (Mn(t, n, p, r), f = t.memoizedState), (c = pn || _n(t, n, c, r, h, f, l) || !1) ? (u || "function" != typeof o.UNSAFE_componentWillUpdate && "function" != typeof o.componentWillUpdate || ("function" == typeof o.componentWillUpdate && o.componentWillUpdate(r, f, l), "function" == typeof o.UNSAFE_componentWillUpdate && o.UNSAFE_componentWillUpdate(r, f, l)), "function" == typeof o.componentDidUpdate && (t.flags |= 4), "function" == typeof o.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" != typeof o.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" != typeof o.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), o.props = r, o.state = f, o.context = l, r = c) : ("function" != typeof o.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" != typeof o.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return Wi(e, t, n, r, a, i) } function Wi(e, t, n, r, i, a) { Gi(e, t); var o = !!(128 & t.flags); if (!r && !o) return i && bt(t, n, !1), ia(e, t, a); r = t.stateNode, ki.current = t; var s = o && "function" != typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && o ? (t.child = ar(t, e.child, null, a), t.child = ar(t, null, s, a)) : Fi(e, t, s, a), t.memoizedState = r.state, i && bt(t, n, !0), t.child } function Xi(e) { var t = e.stateNode; t.pendingContext ? gt(0, t.pendingContext, t.pendingContext !== t.context) : t.context && gt(0, t.context, !1), hr(e, t.containerInfo) } function Ji(e, t, n, r, i) { return $n(), er(i), t.flags |= 256, Fi(e, t, n, r), t.child } var Yi = { dehydrated: null, treeContext: null, retryLane: 0 }; function Qi(e) { return { baseLanes: e, cachePool: null } } function Ki(e, t, n) { var r, i = t.pendingProps, a = gr.current, s = !1, l = !!(128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && !!(2 & a)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), lt(gr, 1 & a), null === e) return Kn(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (1 & t.mode ? Fe(e) ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (a = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, a = { mode: "hidden", children: a }, 1 & i || null === s ? s = rs(a, i, 0, null) : (s.childLanes = 0, s.pendingProps = a), e = ns(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Qi(n), t.memoizedState = Yi, e) : qi(t, a)); if (null !== (a = e.memoizedState)) { if (null !== (r = a.dehydrated)) { if (l) return 256 & t.flags ? (t.flags &= -257, ea(e, t, n, Error(o(422)))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (s = i.fallback, a = t.mode, i = rs({ mode: "visible", children: i.children }, a, 0, null), (s = ns(s, a, n, null)).flags |= 2, i.return = t, s.return = t, i.sibling = s, t.child = i, 1 & t.mode && ar(t, e.child, null, n), t.child.memoizedState = Qi(n), t.memoizedState = Yi, s); if (1 & t.mode) if (Fe(r)) t = ea(e, t, n, Error(o(419))); else if (i = !!(n & e.childLanes), Ni || i) { if (null !== (i = Ya)) { switch (n & -n) { case 4: s = 2; break; case 16: s = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: s = 32; break; case 536870912: s = 268435456; break; default: s = 0 }0 !== (i = s & (i.suspendedLanes | n) ? 0 : s) && i !== a.retryLane && (a.retryLane = i, Mo(e, i, -1)) } No(), t = ea(e, t, n, Error(o(421))) } else Ne(r) ? (t.flags |= 128, t.child = e.child, t = Yo.bind(null, e), Oe(r, t), t = null) : (n = a.treeContext, K && (jn = Ge(r), Gn = t, Vn = !0, Xn = null, Wn = !1, null !== n && (Ln[Dn++] = Nn, Ln[Dn++] = Fn, Ln[Dn++] = kn, Nn = n.id, Fn = n.overflow, kn = t)), (t = qi(t, t.pendingProps.children)).flags |= 4096); else t = ea(e, t, n, null); return t } return s ? (i = $i(e, t, i.children, i.fallback, n), s = t.child, a = e.child.memoizedState, s.memoizedState = null === a ? Qi(n) : { baseLanes: a.baseLanes | n, cachePool: null }, s.childLanes = e.childLanes & ~n, t.memoizedState = Yi, i) : (n = Zi(e, t, i.children, n), t.memoizedState = null, n) } return s ? (i = $i(e, t, i.children, i.fallback, n), s = t.child, a = e.child.memoizedState, s.memoizedState = null === a ? Qi(n) : { baseLanes: a.baseLanes | n, cachePool: null }, s.childLanes = e.childLanes & ~n, t.memoizedState = Yi, i) : (n = Zi(e, t, i.children, n), t.memoizedState = null, n) } function qi(e, t) { return (t = rs({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function Zi(e, t, n, r) { var i = e.child; return e = i.sibling, n = es(i, { mode: "visible", children: n }), !(1 & t.mode) && (n.lanes = r), n.return = t, n.sibling = null, null !== e && (null === (r = t.deletions) ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n } function $i(e, t, n, r, i) { var a = t.mode, o = (e = e.child).sibling, s = { mode: "hidden", children: n }; return 1 & a || t.child === e ? (n = es(e, s)).subtreeFlags = 14680064 & e.subtreeFlags : ((n = t.child).childLanes = 0, n.pendingProps = s, t.deletions = null), null !== o ? r = es(o, r) : (r = ns(r, a, i, null)).flags |= 2, r.return = t, n.return = t, n.sibling = r, t.child = n, r } function ea(e, t, n, r) { return null !== r && er(r), ar(t, e.child, null, n), (e = qi(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function ta(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), cn(e.return, t, n) } function na(e, t, n, r, i) { var a = e.memoizedState; null === a ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (a.isBackwards = t, a.rendering = null, a.renderingStartTime = 0, a.last = r, a.tail = n, a.tailMode = i) } function ra(e, t, n) { var r = t.pendingProps, i = r.revealOrder, a = r.tail; if (Fi(e, t, r.children, n), 2 & (r = gr.current)) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 128 & e.flags) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && ta(e, n, t); else if (19 === e.tag) ta(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (lt(gr, r), 1 & t.mode) switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === vr(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), na(t, !1, i, n, a); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === vr(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } na(t, !0, n, null, a); break; case "together": na(t, !1, null, null, void 0); break; default: t.memoizedState = null } else t.memoizedState = null; return t.child } function ia(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), to |= t.lanes, !(n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(o(153)); if (null !== t.child) { for (n = es(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = es(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function aa(e, t) { switch (Hn(t), t.tag) { case 1: return ft(t.type) && mt(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return pr(), st(dt), st(ut), br(), 65536 & (e = t.flags) && !(128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return mr(t), null; case 13: if (st(gr), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(o(340)); $n() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return st(gr), null; case 4: return pr(), null; case 10: return ln(t.type._context), null; case 22: case 23: return Po(), null; default: return null } } var oa = !1, sa = !1, la = "function" == typeof WeakSet ? WeakSet : Set, ca = null; function ua(e, t) { var n = e.ref; if (null !== n) if ("function" == typeof n) try { n(null) } catch (n) { Wo(e, t, n) } else n.current = null } function da(e, t, n) { try { n() } catch (n) { Wo(e, t, n) } } var ha = !1; function pa(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var a = i.destroy; i.destroy = void 0, void 0 !== a && da(t, n, a) } i = i.next } while (i !== r) } } function fa(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ma(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e = 5 === e.tag ? L(n) : n, "function" == typeof t ? t(e) : t.current = e } } function ga(e, t, n) { if (Vt && "function" == typeof Vt.onCommitFiberUnmount) try { Vt.onCommitFiberUnmount(jt, t) } catch (e) { } switch (t.tag) { case 0: case 11: case 14: case 15: if (null !== (e = t.updateQueue) && null !== (e = e.lastEffect)) { var r = e = e.next; do { var i = r, a = i.destroy; i = i.tag, void 0 !== a && (2 & i || 4 & i) && da(t, n, a), r = r.next } while (r !== e) } break; case 1: if (ua(t, n), "function" == typeof (e = t.stateNode).componentWillUnmount) try { e.props = t.memoizedProps, e.state = t.memoizedState, e.componentWillUnmount() } catch (e) { Wo(t, n, e) } break; case 5: ua(t, n); break; case 4: Y ? wa(e, t, n) : Q && Q && (t = t.stateNode.containerInfo, n = Ce(t), Be(t, n)) } } function va(e, t, n) { for (var r = t; ;)if (ga(e, r, n), null === r.child || Y && 4 === r.tag) { if (r === t) break; for (; null === r.sibling;) { if (null === r.return || r.return === t) return; r = r.return } r.sibling.return = r.return, r = r.sibling } else r.child.return = r, r = r.child } function ya(e) { var t = e.alternate; null !== t && (e.alternate = null, ya(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && null !== (t = e.stateNode) && ee(t), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function ba(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function xa(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || ba(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function Aa(e) { if (Y) { e: { for (var t = e.return; null !== t;) { if (ba(t)) break e; t = t.return } throw Error(o(160)) } var n = t; switch (n.tag) { case 5: t = n.stateNode, 32 & n.flags && (xe(t), n.flags &= -33), Ma(e, n = xa(e), t); break; case 3: case 4: t = n.stateNode.containerInfo, Sa(e, n = xa(e), t); break; default: throw Error(o(161)) } } } function Sa(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? ve(n, e, t) : he(n, e); else if (4 !== r && null !== (e = e.child)) for (Sa(e, t, n), e = e.sibling; null !== e;)Sa(e, t, n), e = e.sibling } function Ma(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? ge(n, e, t) : de(n, e); else if (4 !== r && null !== (e = e.child)) for (Ma(e, t, n), e = e.sibling; null !== e;)Ma(e, t, n), e = e.sibling } function wa(e, t, n) { for (var r, i, a = t, s = !1; ;) { if (!s) { s = a.return; e: for (; ;) { if (null === s) throw Error(o(160)); switch (r = s.stateNode, s.tag) { case 5: i = !1; break e; case 3: case 4: r = r.containerInfo, i = !0; break e }s = s.return } s = !0 } if (5 === a.tag || 6 === a.tag) va(e, a, n), i ? be(r, a.stateNode) : ye(r, a.stateNode); else if (18 === a.tag) i ? Ke(r, a.stateNode) : Qe(r, a.stateNode); else if (4 === a.tag) { if (null !== a.child) { r = a.stateNode.containerInfo, i = !0, a.child.return = a, a = a.child; continue } } else if (ga(e, a, n), null !== a.child) { a.child.return = a, a = a.child; continue } if (a === t) break; for (; null === a.sibling;) { if (null === a.return || a.return === t) return; 4 === (a = a.return).tag && (s = !1) } a.sibling.return = a.return, a = a.sibling } } function _a(e, t) { if (Y) { switch (t.tag) { case 0: case 11: case 14: case 15: return pa(3, t, t.return), fa(3, t), void pa(5, t, t.return); case 1: case 12: case 17: return; case 5: var n = t.stateNode; if (null != n) { var r = t.memoizedProps; e = null !== e ? e.memoizedProps : r; var i = t.type, a = t.updateQueue; t.updateQueue = null, null !== a && me(n, a, i, e, r, t) } return; case 6: if (null === t.stateNode) throw Error(o(162)); return n = t.memoizedProps, void pe(t.stateNode, null !== e ? e.memoizedProps : n, n); case 3: return void (K && null !== e && e.memoizedState.isDehydrated && Je(t.stateNode.containerInfo)); case 13: case 19: return void Ea(t) }throw Error(o(163)) } switch (t.tag) { case 0: case 11: case 14: case 15: return pa(3, t, t.return), fa(3, t), void pa(5, t, t.return); case 12: case 22: case 23: return; case 13: case 19: return void Ea(t); case 3: K && null !== e && e.memoizedState.isDehydrated && Je(t.stateNode.containerInfo) }e: if (Q) { switch (t.tag) { case 1: case 5: case 6: break e; case 3: case 4: t = t.stateNode, Be(t.containerInfo, t.pendingChildren); break e }throw Error(o(163)) } } function Ea(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new la), t.forEach((function (t) { var r = Qo.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function Ca(e, t, n) { ca = e, Ta(e, t, n) } function Ta(e, t, n) { for (var r = !!(1 & e.mode); null !== ca;) { var i = ca, a = i.child; if (22 === i.tag && r) { var o = null !== i.memoizedState || oa; if (!o) { var s = i.alternate, l = null !== s && null !== s.memoizedState || sa; s = oa; var c = sa; if (oa = o, (sa = l) && !c) for (ca = i; null !== ca;)l = (o = ca).child, 22 === o.tag && null !== o.memoizedState ? Ia(i) : null !== l ? (l.return = o, ca = l) : Ia(i); for (; null !== a;)ca = a, Ta(a, t, n), a = a.sibling; ca = i, oa = s, sa = c } Ra(e) } else 8772 & i.subtreeFlags && null !== a ? (a.return = i, ca = a) : Ra(e) } } function Ra(e) { for (; null !== ca;) { var t = ca; if (8772 & t.flags) { var n = t.alternate; try { if (8772 & t.flags) switch (t.tag) { case 0: case 11: case 15: sa || fa(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !sa) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : en(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var a = t.updateQueue; null !== a && An(t, a, r); break; case 3: var s = t.updateQueue; if (null !== s) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: n = L(t.child.stateNode); break; case 1: n = t.child.stateNode }An(t, s, n) } break; case 5: var l = t.stateNode; null === n && 4 & t.flags && fe(l, t.type, t.memoizedProps, t); break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: break; case 13: if (K && null === t.memoizedState) { var c = t.alternate; if (null !== c) { var u = c.memoizedState; if (null !== u) { var d = u.dehydrated; null !== d && Ye(d) } } } break; default: throw Error(o(163)) }sa || 512 & t.flags && ma(t) } catch (e) { Wo(t, t.return, e) } } if (t === e) { ca = null; break } if (null !== (n = t.sibling)) { n.return = t.return, ca = n; break } ca = t.return } } function Ba(e) { for (; null !== ca;) { var t = ca; if (t === e) { ca = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, ca = n; break } ca = t.return } } function Ia(e) { for (; null !== ca;) { var t = ca; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { fa(4, t) } catch (e) { Wo(t, n, e) } break; case 1: var r = t.stateNode; if ("function" == typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (e) { Wo(t, i, e) } } var a = t.return; try { ma(t) } catch (e) { Wo(t, a, e) } break; case 5: var o = t.return; try { ma(t) } catch (e) { Wo(t, o, e) } } } catch (e) { Wo(t, t.return, e) } if (t === e) { ca = null; break } var s = t.sibling; if (null !== s) { s.return = t.return, ca = s; break } ca = t.return } } var Pa = 0, La = 1, Da = 2, ka = 3, Na = 4; if ("function" == typeof Symbol && Symbol.for) { var Fa = Symbol.for; Pa = Fa("selector.component"), La = Fa("selector.has_pseudo_class"), Da = Fa("selector.role"), ka = Fa("selector.test_id"), Na = Fa("selector.text") } function Oa(e) { var t = q(e); if (null != t) { if ("string" != typeof t.memoizedProps["data-testname"]) throw Error(o(364)); return t } if (null === (e = ie(e))) throw Error(o(362)); return e.stateNode.current } function Ua(e, t) { switch (t.$$typeof) { case Pa: if (e.type === t.value) return !0; break; case La: e: { t = t.value, e = [e, 0]; for (var n = 0; n < e.length;) { var r = e[n++], i = e[n++], a = t[i]; if (5 !== r.tag || !se(r)) { for (; null != a && Ua(r, a);)a = t[++i]; if (i === t.length) { t = !0; break e } for (r = r.child; null !== r;)e.push(r, i), r = r.sibling } } t = !1 } return t; case Da: if (5 === e.tag && le(e.stateNode, t.value)) return !0; break; case Na: if ((5 === e.tag || 6 === e.tag) && null !== (e = oe(e)) && 0 <= e.indexOf(t.value)) return !0; break; case ka: if (5 === e.tag && "string" == typeof (e = e.memoizedProps["data-testname"]) && e.toLowerCase() === t.value.toLowerCase()) return !0; break; default: throw Error(o(365)) }return !1 } function za(e) { switch (e.$$typeof) { case Pa: return "<" + (M(e.value) || "Unknown") + ">"; case La: return ":has(" + (za(e) || "") + ")"; case Da: return '[role="' + e.value + '"]'; case Na: return '"' + e.value + '"'; case ka: return '[data-testname="' + e.value + '"]'; default: throw Error(o(365)) } } function Ha(e, t) { var n = []; e = [e, 0]; for (var r = 0; r < e.length;) { var i = e[r++], a = e[r++], o = t[a]; if (5 !== i.tag || !se(i)) { for (; null != o && Ua(i, o);)o = t[++a]; if (a === t.length) n.push(i); else for (i = i.child; null !== i;)e.push(i, a), i = i.sibling } } return n } function Ga(e, t) { if (!re) throw Error(o(363)); e = Ha(e = Oa(e), t), t = [], e = Array.from(e); for (var n = 0; n < e.length;) { var r = e[n++]; if (5 === r.tag) se(r) || t.push(r.stateNode); else for (r = r.child; null !== r;)e.push(r), r = r.sibling } return t } var ja = Math.ceil, Va = s.ReactCurrentDispatcher, Wa = s.ReactCurrentOwner, Xa = s.ReactCurrentBatchConfig, Ja = 0, Ya = null, Qa = null, Ka = 0, qa = 0, Za = ot(0), $a = 0, eo = null, to = 0, no = 0, ro = 0, io = null, ao = null, oo = 0, so = 1 / 0; function lo() { so = Ot() + 500 } var co, uo = !1, ho = null, po = null, fo = !1, mo = null, go = 0, vo = 0, yo = null, bo = -1, xo = 0; function Ao() { return 6 & Ja ? Ot() : -1 !== bo ? bo : bo = Ot() } function So(e) { return 1 & e.mode ? 2 & Ja && 0 !== Ka ? Ka & -Ka : null !== qt.transition ? (0 === xo && (e = Mt, !(4194240 & (Mt <<= 1)) && (Mt = 64), xo = e), xo) : 0 !== (e = Pt) ? e : $() : 1 } function Mo(e, t, n) { if (50 < vo) throw vo = 0, yo = null, Error(o(185)); var r = wo(e, t); return null === r ? null : (Bt(r, t, n), 2 & Ja && r === Ya || (r === Ya && (!(2 & Ja) && (no |= t), 4 === $a && Ro(r, Ka)), _o(r, n), 1 === t && 0 === Ja && !(1 & e.mode) && (lo(), Jt && Kt())), r) } function wo(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } function _o(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, a = e.pendingLanes; 0 < a;) { var o = 31 - xt(a), s = 1 << o, l = i[o]; -1 === l ? s & n && !(s & r) || (i[o] = Ct(s, t)) : l <= t && (e.expiredLanes |= s), a &= ~s } }(e, t); var r = Et(e, e === Ya ? Ka : 0); if (0 === r) null !== n && kt(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && kt(n), 1 === t) 0 === e.tag ? function (e) { Jt = !0, Qt(e) }(Bo.bind(null, e)) : Qt(Bo.bind(null, e)), te ? ne((function () { 0 === Ja && Kt() })) : Dt(Ut, Kt), n = null; else { switch (Lt(r)) { case 1: n = Ut; break; case 4: n = zt; break; case 16: default: n = Ht; break; case 536870912: n = Gt }n = Ko(n, Eo.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function Eo(e, t) { if (bo = -1, xo = 0, 6 & Ja) throw Error(o(327)); var n = e.callbackNode; if (jo() && e.callbackNode !== n) return null; var r = Et(e, e === Ya ? Ka : 0); if (0 === r) return null; if (30 & r || r & e.expiredLanes || t) t = Fo(e, r); else { t = r; var i = Ja; Ja |= 2; var a = ko(); for (Ya === e && Ka === t || (lo(), Lo(e, t)); ;)try { Uo(); break } catch (t) { Do(e, t) } on(), Va.current = a, Ja = i, null !== Qa ? t = 0 : (Ya = null, Ka = 0, t = $a) } if (0 !== t) { if (2 === t && 0 !== (i = Tt(e)) && (r = i, t = Co(e, i)), 1 === t) throw n = eo, Lo(e, 0), Ro(e, r), _o(e, Ot()), n; if (6 === t) Ro(e, r); else { if (i = e.current.alternate, !(30 & r || function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], a = i.getSnapshot; i = i.value; try { if (!Wt(a(), i)) return !1 } catch (e) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) || (t = Fo(e, r), 2 === t && (a = Tt(e), 0 !== a && (r = a, t = Co(e, a))), 1 !== t))) throw n = eo, Lo(e, 0), Ro(e, r), _o(e, Ot()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(o(345)); case 2: case 5: Go(e, ao); break; case 3: if (Ro(e, r), (130023424 & r) === r && 10 < (t = oo + 500 - Ot())) { if (0 !== Et(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { Ao(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = V(Go.bind(null, e, ao), t); break } Go(e, ao); break; case 4: if (Ro(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - xt(r); a = 1 << s, (s = t[s]) > i && (i = s), r &= ~a } if (r = i, 10 < (r = (120 > (r = Ot() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * ja(r / 1960)) - r)) { e.timeoutHandle = V(Go.bind(null, e, ao), r); break } Go(e, ao); break; default: throw Error(o(329)) } } } return _o(e, Ot()), e.callbackNode === n ? Eo.bind(null, e) : null } function Co(e, t) { var n = io; return e.current.memoizedState.isDehydrated && (Lo(e, t).flags |= 256), 2 !== (e = Fo(e, t)) && (t = ao, ao = n, null !== t && To(t)), e } function To(e) { null === ao ? ao = e : ao.push.apply(ao, e) } function Ro(e, t) { for (t &= ~ro, t &= ~no, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - xt(t), r = 1 << n; e[n] = -1, t &= ~r } } function Bo(e) { if (6 & Ja) throw Error(o(327)); jo(); var t = Et(e, 0); if (!(1 & t)) return _o(e, Ot()), null; var n = Fo(e, t); if (0 !== e.tag && 2 === n) { var r = Tt(e); 0 !== r && (t = r, n = Co(e, r)) } if (1 === n) throw n = eo, Lo(e, 0), Ro(e, t), _o(e, Ot()), n; if (6 === n) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Go(e, ao), _o(e, Ot()), null } function Io(e) { null !== mo && 0 === mo.tag && !(6 & Ja) && jo(); var t = Ja; Ja |= 1; var n = Xa.transition, r = Pt; try { if (Xa.transition = null, Pt = 1, e) return e() } finally { Pt = r, Xa.transition = n, !(6 & (Ja = t)) && Kt() } } function Po() { qa = Za.current, st(Za) } function Lo(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== X && (e.timeoutHandle = X, W(n)), null !== Qa) for (n = Qa.return; null !== n;) { var r = n; switch (Hn(r), r.tag) { case 1: null != (r = r.type.childContextTypes) && mt(); break; case 3: pr(), st(dt), st(ut), br(); break; case 5: mr(r); break; case 4: pr(); break; case 13: case 19: st(gr); break; case 10: ln(r.type._context); break; case 22: case 23: Po() }n = n.return } if (Ya = e, Qa = e = es(e.current, null), Ka = qa = t, $a = 0, eo = null, ro = no = to = 0, ao = io = null, null !== hn) { for (t = 0; t < hn.length; t++)if (null !== (r = (n = hn[t]).interleaved)) { n.interleaved = null; var i = r.next, a = n.pending; if (null !== a) { var o = a.next; a.next = i, r.next = o } n.pending = r } hn = null } return e } function Do(e, t) { for (; ;) { var n = Qa; try { if (on(), xr.current = pi, Er) { for (var r = Mr.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } Er = !1 } if (Sr = 0, _r = wr = Mr = null, Cr = !1, Tr = 0, Wa.current = null, null === n || null === n.return) { $a = 1, eo = t, Qa = null; break } e: { var a = e, s = n.return, l = n, c = t; if (t = Ka, l.flags |= 32768, null !== c && "object" == typeof c && "function" == typeof c.then) { var u = c, d = l, h = d.tag; if (!(1 & d.mode || 0 !== h && 11 !== h && 15 !== h)) { var p = d.alternate; p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null) } var f = Ci(s); if (null !== f) { f.flags &= -257, Ti(f, s, l, 0, t), 1 & f.mode && Ei(a, u, t), c = u; var m = (t = f).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (!(1 & t)) { Ei(a, u, t), No(); break e } c = Error(o(426)) } else if (Vn && 1 & l.mode) { var v = Ci(s); if (null !== v) { !(65536 & v.flags) && (v.flags |= 256), Ti(v, s, l, 0, t), er(c); break e } } a = c, 4 !== $a && ($a = 2), null === io ? io = [a] : io.push(a), c = vi(c, l), l = s; do { switch (l.tag) { case 3: l.flags |= 65536, t &= -t, l.lanes |= t, bn(l, wi(0, c, t)); break e; case 1: a = c; var y = l.type, b = l.stateNode; if (!(128 & l.flags || "function" != typeof y.getDerivedStateFromError && (null === b || "function" != typeof b.componentDidCatch || null !== po && po.has(b)))) { l.flags |= 65536, t &= -t, l.lanes |= t, bn(l, _i(l, a, t)); break e } }l = l.return } while (null !== l) } Ho(n) } catch (e) { t = e, Qa === n && null !== n && (Qa = n = n.return); continue } break } } function ko() { var e = Va.current; return Va.current = pi, null === e ? pi : e } function No() { 0 !== $a && 3 !== $a && 2 !== $a || ($a = 4), null === Ya || !(268435455 & to) && !(268435455 & no) || Ro(Ya, Ka) } function Fo(e, t) { var n = Ja; Ja |= 2; var r = ko(); for (Ya === e && Ka === t || Lo(e, t); ;)try { Oo(); break } catch (t) { Do(e, t) } if (on(), Ja = n, Va.current = r, null !== Qa) throw Error(o(261)); return Ya = null, Ka = 0, $a } function Oo() { for (; null !== Qa;)zo(Qa) } function Uo() { for (; null !== Qa && !Nt();)zo(Qa) } function zo(e) { var t = co(e.alternate, e, qa); e.memoizedProps = e.pendingProps, null === t ? Ho(e) : Qa = t, Wa.current = null } function Ho(e) { var t = e; do { var n = t.alternate; if (e = t.return, 32768 & t.flags) { if (null !== (n = aa(n, t))) return n.flags &= 32767, void (Qa = n); if (null === e) return $a = 6, void (Qa = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } else if (null !== (n = Di(n, t, qa))) return void (Qa = n); if (null !== (t = t.sibling)) return void (Qa = t); Qa = t = e } while (null !== t); 0 === $a && ($a = 5) } function Go(e, t) { var n = Pt, r = Xa.transition; try { Xa.transition = null, Pt = 1, function (e, t, n) { do { jo() } while (null !== mo); if (6 & Ja) throw Error(o(327)); var r = e.finishedWork, i = e.finishedLanes; if (null === r) return null; if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var a = r.lanes | r.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - xt(n), a = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~a } }(e, a), e === Ya && (Qa = Ya = null, Ka = 0), !(2064 & r.subtreeFlags) && !(2064 & r.flags) || fo || (fo = !0, Ko(Ht, (function () { return jo(), null }))), a = !!(15990 & r.flags), 15990 & r.subtreeFlags || a) { a = Xa.transition, Xa.transition = null; var s = Pt; Pt = 1; var l = Ja; Ja |= 4, Wa.current = null, function (e, t) { for (N(e.containerInfo), ca = t; null !== ca;)if (t = (e = ca).child, 1028 & e.subtreeFlags && null !== t) t.return = e, ca = t; else for (; null !== ca;) { e = ca; try { var n = e.alternate; if (1024 & e.flags) switch (e.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== n) { var r = n.memoizedProps, i = n.memoizedState, a = e.stateNode, s = a.getSnapshotBeforeUpdate(e.elementType === e.type ? r : en(e.type, r), i); a.__reactInternalSnapshotBeforeUpdate = s } break; case 3: Y && _e(e.stateNode.containerInfo); break; default: throw Error(o(163)) } } catch (t) { Wo(e, e.return, t) } if (null !== (t = e.sibling)) { t.return = e.return, ca = t; break } ca = e.return } n = ha, ha = !1 }(e, r), function (e, t) { for (ca = t; null !== ca;) { var n = (t = ca).deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var a = e; Y ? wa(a, i, t) : va(a, i, t); var o = i.alternate; null !== o && (o.return = null), i.return = null } catch (e) { Wo(i, t, e) } } if (n = t.child, 12854 & t.subtreeFlags && null !== n) n.return = t, ca = n; else for (; null !== ca;) { t = ca; try { var s = t.flags; if (32 & s && Y && xe(t.stateNode), 512 & s) { var l = t.alternate; if (null !== l) { var c = l.ref; null !== c && ("function" == typeof c ? c(null) : c.current = null) } } if (8192 & s) switch (t.tag) { case 13: if (null !== t.memoizedState) { var u = t.alternate; null !== u && null !== u.memoizedState || (oo = Ot()) } break; case 22: var d = null !== t.memoizedState, h = t.alternate, p = null !== h && null !== h.memoizedState; if (n = t, Y) e: if (r = n, i = d, a = null, Y) for (var f = r; ;) { if (5 === f.tag) { if (null === a) { a = f; var m = f.stateNode; i ? Ae(m) : Me(f.stateNode, f.memoizedProps) } } else if (6 === f.tag) { if (null === a) { var g = f.stateNode; i ? Se(g) : we(g, f.memoizedProps) } } else if ((22 !== f.tag && 23 !== f.tag || null === f.memoizedState || f === r) && null !== f.child) { f.child.return = f, f = f.child; continue } if (f === r) break; for (; null === f.sibling;) { if (null === f.return || f.return === r) break e; a === f && (a = null), f = f.return } a === f && (a = null), f.sibling.return = f.return, f = f.sibling } if (d && !p && 1 & n.mode) { ca = n; for (var v = n.child; null !== v;) { for (n = ca = v; null !== ca;) { var y = (r = ca).child; switch (r.tag) { case 0: case 11: case 14: case 15: pa(4, r, r.return); break; case 1: ua(r, r.return); var b = r.stateNode; if ("function" == typeof b.componentWillUnmount) { var x = r.return; try { b.props = r.memoizedProps, b.state = r.memoizedState, b.componentWillUnmount() } catch (e) { Wo(r, x, e) } } break; case 5: ua(r, r.return); break; case 22: if (null !== r.memoizedState) { Ba(n); continue } }null !== y ? (y.return = r, ca = y) : Ba(n) } v = v.sibling } } }switch (4102 & s) { case 2: Aa(t), t.flags &= -3; break; case 6: Aa(t), t.flags &= -3, _a(t.alternate, t); break; case 4096: t.flags &= -4097; break; case 4100: t.flags &= -4097, _a(t.alternate, t); break; case 4: _a(t.alternate, t) } } catch (e) { Wo(t, t.return, e) } if (null !== (n = t.sibling)) { n.return = t.return, ca = n; break } ca = t.return } } }(e, r), F(e.containerInfo), e.current = r, Ca(r, e, i), Ft(), Ja = l, Pt = s, Xa.transition = a } else e.current = r; if (fo && (fo = !1, mo = e, go = i), 0 === (a = e.pendingLanes) && (po = null), function (e) { if (Vt && "function" == typeof Vt.onCommitFiberRoot) try { Vt.onCommitFiberRoot(jt, e, void 0, !(128 & ~e.current.flags)) } catch (e) { } }(r.stateNode), _o(e, Ot()), null !== t) for (n = e.onRecoverableError, r = 0; r < t.length; r++)n(t[r]); if (uo) throw uo = !1, e = ho, ho = null, e; !!(1 & go) && 0 !== e.tag && jo(), 1 & (a = e.pendingLanes) ? e === yo ? vo++ : (vo = 0, yo = e) : vo = 0, Kt() }(e, t, n) } finally { Xa.transition = r, Pt = n } return null } function jo() { if (null !== mo) { var e = Lt(go), t = Xa.transition, n = Pt; try { if (Xa.transition = null, Pt = 16 > e ? 16 : e, null === mo) var r = !1; else { if (e = mo, mo = null, go = 0, 6 & Ja) throw Error(o(331)); var i = Ja; for (Ja |= 4, ca = e.current; null !== ca;) { var a = ca, s = a.child; if (16 & ca.flags) { var l = a.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for (ca = u; null !== ca;) { var d = ca; switch (d.tag) { case 0: case 11: case 15: pa(8, d, a) }var h = d.child; if (null !== h) h.return = d, ca = h; else for (; null !== ca;) { var p = (d = ca).sibling, f = d.return; if (ya(d), d === u) { ca = null; break } if (null !== p) { p.return = f, ca = p; break } ca = f } } } var m = a.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var v = g.sibling; g.sibling = null, g = v } while (null !== g) } } ca = a } } if (2064 & a.subtreeFlags && null !== s) s.return = a, ca = s; else e: for (; null !== ca;) { if (2048 & (a = ca).flags) switch (a.tag) { case 0: case 11: case 15: pa(9, a, a.return) }var y = a.sibling; if (null !== y) { y.return = a.return, ca = y; break e } ca = a.return } } var b = e.current; for (ca = b; null !== ca;) { var x = (s = ca).child; if (2064 & s.subtreeFlags && null !== x) x.return = s, ca = x; else e: for (s = b; null !== ca;) { if (2048 & (l = ca).flags) try { switch (l.tag) { case 0: case 11: case 15: fa(9, l) } } catch (e) { Wo(l, l.return, e) } if (l === s) { ca = null; break e } var A = l.sibling; if (null !== A) { A.return = l.return, ca = A; break e } ca = l.return } } if (Ja = i, Kt(), Vt && "function" == typeof Vt.onPostCommitFiberRoot) try { Vt.onPostCommitFiberRoot(jt, e) } catch (e) { } r = !0 } return r } finally { Pt = n, Xa.transition = t } } return !1 } function Vo(e, t, n) { vn(e, t = wi(0, t = vi(n, t), 1)), t = Ao(), null !== (e = wo(e, 1)) && (Bt(e, 1, t), _o(e, t)) } function Wo(e, t, n) { if (3 === e.tag) Vo(e, e, n); else for (; null !== t;) { if (3 === t.tag) { Vo(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" == typeof t.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === po || !po.has(r))) { vn(t, e = _i(t, e = vi(n, e), 1)), e = Ao(), null !== (t = wo(t, 1)) && (Bt(t, 1, e), _o(t, e)); break } } t = t.return } } function Xo(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = Ao(), e.pingedLanes |= e.suspendedLanes & n, Ya === e && (Ka & n) === n && (4 === $a || 3 === $a && (130023424 & Ka) === Ka && 500 > Ot() - oo ? Lo(e, 0) : ro |= n), _o(e, t) } function Jo(e, t) { 0 === t && (1 & e.mode ? (t = wt, !(130023424 & (wt <<= 1)) && (wt = 4194304)) : t = 1); var n = Ao(); null !== (e = wo(e, t)) && (Bt(e, t, n), _o(e, n)) } function Yo(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Jo(e, n) } function Qo(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(o(314)) }null !== r && r.delete(t), Jo(e, n) } function Ko(e, t) { return Dt(e, t) } function qo(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Zo(e, t, n, r) { return new qo(e, t, n, r) } function $o(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function es(e, t) { var n = e.alternate; return null === n ? ((n = Zo(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function ts(e, t, n, r, i, a) { var s = 2; if (r = e, "function" == typeof e) $o(e) && (s = 1); else if ("string" == typeof e) s = 5; else e: switch (e) { case u: return ns(n.children, i, a, t); case d: s = 8, i |= 8; break; case h: return (e = Zo(12, n, t, 2 | i)).elementType = h, e.lanes = a, e; case g: return (e = Zo(13, n, t, i)).elementType = g, e.lanes = a, e; case v: return (e = Zo(19, n, t, i)).elementType = v, e.lanes = a, e; case x: return rs(n, i, a, t); default: if ("object" == typeof e && null !== e) switch (e.$$typeof) { case p: s = 10; break e; case f: s = 9; break e; case m: s = 11; break e; case y: s = 14; break e; case b: s = 16, r = null; break e }throw Error(o(130, null == e ? e : typeof e, "")) }return (t = Zo(s, n, t, i)).elementType = e, t.type = r, t.lanes = a, t } function ns(e, t, n, r) { return (e = Zo(7, e, r, t)).lanes = n, e } function rs(e, t, n, r) { return (e = Zo(22, e, r, t)).elementType = x, e.lanes = n, e.stateNode = {}, e } function is(e, t, n) { return (e = Zo(6, e, null, t)).lanes = n, e } function as(e, t, n) { return (t = Zo(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function os(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = X, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Rt(0), this.expirationTimes = Rt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Rt(0), this.identifierPrefix = r, this.onRecoverableError = i, K && (this.mutableSourceEagerHydrationData = null) } function ss(e, t, n, r, i, a, o, s, l) { return e = new os(e, t, n, s, l), 1 === t ? (t = 1, !0 === a && (t |= 8)) : t = 0, a = Zo(3, null, null, t), e.current = a, a.stateNode = e, a.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null }, fn(a), e } function ls(e) { if (!e) return ct; e: { if (_(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (ft(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(o(171)) } if (1 === e.tag) { var n = e.type; if (ft(n)) return vt(e, n, t) } return t } function cs(e) { var t = e._reactInternals; if (void 0 === t) { if ("function" == typeof e.render) throw Error(o(188)); throw e = Object.keys(e).join(","), Error(o(268, e)) } return null === (e = T(t)) ? null : e.stateNode } function us(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function ds(e, t) { us(e, t), (e = e.alternate) && us(e, t) } function hs(e) { return null === (e = T(e)) ? null : e.stateNode } function ps() { return null } return co = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || dt.current) Ni = !0; else { if (!(e.lanes & n || 128 & t.flags)) return Ni = !1, function (e, t, n) { switch (t.tag) { case 3: Xi(t), $n(); break; case 5: fr(t); break; case 1: ft(t.type) && yt(t); break; case 4: hr(t, t.stateNode.containerInfo); break; case 10: sn(0, t.type._context, t.memoizedProps.value); break; case 13: var r = t.memoizedState; if (null !== r) return null !== r.dehydrated ? (lt(gr, 1 & gr.current), t.flags |= 128, null) : n & t.child.childLanes ? Ki(e, t, n) : (lt(gr, 1 & gr.current), null !== (e = ia(e, t, n)) ? e.sibling : null); lt(gr, 1 & gr.current); break; case 19: if (r = !!(n & t.childLanes), 128 & e.flags) { if (r) return ra(e, t, n); t.flags |= 128 } var i = t.memoizedState; if (null !== i && (i.rendering = null, i.tail = null, i.lastEffect = null), lt(gr, gr.current), r) break; return null; case 22: case 23: return t.lanes = 0, Hi(e, t, n) }return ia(e, t, n) }(e, t, n); Ni = !!(131072 & e.flags) } else Ni = !1, Vn && 1048576 & t.flags && Un(t, Pn, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), e = t.pendingProps; var i = pt(t, ut.current); un(t, n), i = Pr(null, t, r, e, i, n); var a = Lr(); return t.flags |= 1, "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ft(r) ? (a = !0, yt(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, fn(t), i.updater = wn, t.stateNode = i, i._reactInternals = t, Tn(t, r, e, n), t = Wi(null, t, r, !0, a, n)) : (t.tag = 0, Vn && a && zn(t), Fi(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" == typeof e) return $o(e) ? 1 : 0; if (null != e) { if ((e = e.$$typeof) === m) return 11; if (e === y) return 14 } return 2 }(r), e = en(r, e), i) { case 0: t = ji(null, t, r, e, n); break e; case 1: t = Vi(null, t, r, e, n); break e; case 11: t = Oi(null, t, r, e, n); break e; case 14: t = Ui(null, t, r, en(r.type, e), n); break e }throw Error(o(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, ji(e, t, r, i = t.elementType === r ? i : en(r, i), n); case 1: return r = t.type, i = t.pendingProps, Vi(e, t, r, i = t.elementType === r ? i : en(r, i), n); case 3: e: { if (Xi(t), null === e) throw Error(o(387)); r = t.pendingProps, i = (a = t.memoizedState).element, mn(e, t), xn(t, r, null, n); var s = t.memoizedState; if (r = s.element, K && a.isDehydrated) { if (a = { element: r, isDehydrated: !1, cache: s.cache, transitions: s.transitions }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) { t = Ji(e, t, r, n, i = Error(o(423))); break e } if (r !== i) { t = Ji(e, t, r, n, i = Error(o(424))); break e } for (K && (jn = He(t.stateNode.containerInfo), Gn = t, Vn = !0, Xn = null, Wn = !1), n = or(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if ($n(), r === i) { t = ia(e, t, n); break e } Fi(e, t, r, n) } t = t.child } return t; case 5: return fr(t), null === e && Kn(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, s = i.children, G(r, i) ? s = null : null !== a && G(r, a) && (t.flags |= 32), Gi(e, t), Fi(e, t, s, n), t.child; case 6: return null === e && Kn(t), null; case 13: return Ki(e, t, n); case 4: return hr(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = ar(t, null, r, n) : Fi(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, Oi(e, t, r, i = t.elementType === r ? i : en(r, i), n); case 7: return Fi(e, t, t.pendingProps, n), t.child; case 8: case 12: return Fi(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, sn(0, r, s = i.value), null !== a) if (Wt(a.value, s)) { if (a.children === i.children && !dt.current) { t = ia(e, t, n); break e } } else for (null !== (a = t.child) && (a.return = t); null !== a;) { var l = a.dependencies; if (null !== l) { s = a.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === a.tag) { (c = gn(-1, n & -n)).tag = 2; var u = a.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), cn(a.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === a.tag) s = a.type === t.type ? null : a.child; else if (18 === a.tag) { if (null === (s = a.return)) throw Error(o(341)); s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), cn(s, n, t), s = a.sibling } else s = a.child; if (null !== s) s.return = a; else for (s = a; null !== s;) { if (s === t) { s = null; break } if (null !== (a = s.sibling)) { a.return = s.return, s = a; break } s = s.return } a = s } Fi(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, un(t, n), r = r(i = dn(i)), t.flags |= 1, Fi(e, t, r, n), t.child; case 14: return i = en(r = t.type, t.pendingProps), Ui(e, t, r, i = en(r.type, i), n); case 15: return zi(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : en(r, i), null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), t.tag = 1, ft(r) ? (e = !0, yt(t)) : e = !1, un(t, n), En(t, r, i), Tn(t, r, i, n), Wi(null, t, r, !0, e, n); case 19: return ra(e, t, n); case 22: return Hi(e, t, n) }throw Error(o(156, t.tag)) }, t.attemptContinuousHydration = function (e) { 13 === e.tag && (Mo(e, 134217728, Ao()), ds(e, 134217728)) }, t.attemptHydrationAtCurrentPriority = function (e) { if (13 === e.tag) { var t = Ao(), n = So(e); Mo(e, n, t), ds(e, n) } }, t.attemptSynchronousHydration = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = _t(t.pendingLanes); 0 !== n && (It(t, 1 | n), _o(t, Ot()), !(6 & Ja) && (lo(), Kt())) } break; case 13: var r = Ao(); Io((function () { return Mo(e, 1, r) })), ds(e, 1) } }, t.batchedUpdates = function (e, t) { var n = Ja; Ja |= 1; try { return e(t) } finally { 0 === (Ja = n) && (lo(), Jt && Kt()) } }, t.createComponentSelector = function (e) { return { $$typeof: Pa, value: e } }, t.createContainer = function (e, t, n, r, i, a, o) { return ss(e, t, !1, null, 0, r, 0, a, o) }, t.createHasPseudoClassSelector = function (e) { return { $$typeof: La, value: e } }, t.createHydrationContainer = function (e, t, n, r, i, a, o, s, l) { return (e = ss(n, r, !0, e, 0, a, 0, s, l)).context = ls(null), n = e.current, (a = gn(r = Ao(), i = So(n))).callback = null != t ? t : null, vn(n, a), e.current.lanes = i, Bt(e, i, r), _o(e, r), e }, t.createPortal = function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: c, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }, t.createRoleSelector = function (e) { return { $$typeof: Da, value: e } }, t.createTestNameSelector = function (e) { return { $$typeof: ka, value: e } }, t.createTextSelector = function (e) { return { $$typeof: Na, value: e } }, t.deferredUpdates = function (e) { var t = Pt, n = Xa.transition; try { return Xa.transition = null, Pt = 16, e() } finally { Pt = t, Xa.transition = n } }, t.discreteUpdates = function (e, t, n, r, i) { var a = Pt, o = Xa.transition; try { return Xa.transition = null, Pt = 1, e(t, n, r, i) } finally { Pt = a, Xa.transition = o, 0 === Ja && lo() } }, t.findAllNodes = Ga, t.findBoundingRects = function (e, t) { if (!re) throw Error(o(363)); t = Ga(e, t), e = []; for (var n = 0; n < t.length; n++)e.push(ae(t[n])); for (t = e.length - 1; 0 < t; t--)for (var r = (n = e[t]).x, i = r + n.width, a = n.y, s = a + n.height, l = t - 1; 0 <= l; l--)if (t !== l) { var c = e[l], u = c.x, d = u + c.width, h = c.y, p = h + c.height; if (r >= u && a >= h && i <= d && s <= p) { e.splice(t, 1); break } if (!(r !== u || n.width !== c.width || p < a || h > s)) { h > a && (c.height += h - a, c.y = a), p < s && (c.height = s - h), e.splice(t, 1); break } if (!(a !== h || n.height !== c.height || d < r || u > i)) { u > r && (c.width += u - r, c.x = r), d < i && (c.width = i - u), e.splice(t, 1); break } } return e }, t.findHostInstance = cs, t.findHostInstanceWithNoPortals = function (e) { return null === (e = null !== (e = C(e)) ? B(e) : null) ? null : e.stateNode }, t.findHostInstanceWithWarning = function (e) { return cs(e) }, t.flushControlled = function (e) { var t = Ja; Ja |= 1; var n = Xa.transition, r = Pt; try { Xa.transition = null, Pt = 1, e() } finally { Pt = r, Xa.transition = n, 0 === (Ja = t) && (lo(), Kt()) } }, t.flushPassiveEffects = jo, t.flushSync = Io, t.focusWithin = function (e, t) { if (!re) throw Error(o(363)); for (t = Ha(e = Oa(e), t), t = Array.from(t), e = 0; e < t.length;) { var n = t[e++]; if (!se(n)) { if (5 === n.tag && ce(n.stateNode)) return !0; for (n = n.child; null !== n;)t.push(n), n = n.sibling } } return !1 }, t.getCurrentUpdatePriority = function () { return Pt }, t.getFindAllNodesFailureDescription = function (e, t) { if (!re) throw Error(o(363)); var n = 0, r = []; e = [Oa(e), 0]; for (var i = 0; i < e.length;) { var a = e[i++], s = e[i++], l = t[s]; if ((5 !== a.tag || !se(a)) && (Ua(a, l) && (r.push(za(l)), ++s > n && (n = s)), s < t.length)) for (a = a.child; null !== a;)e.push(a, s), a = a.sibling } if (n < t.length) { for (e = []; n < t.length; n++)e.push(za(t[n])); return "findAllNodes was able to match part of the selector:\n  " + r.join(" > ") + "\n\nNo matching component was found for:\n  " + e.join(" > ") } return null }, t.getPublicRootInstance = function (e) { return (e = e.current).child ? 5 === e.child.tag ? L(e.child.stateNode) : e.child.stateNode : null }, t.injectIntoDevTools = function (e) { if (e = { bundleType: e.bundleType, version: e.version, rendererPackageName: e.rendererPackageName, rendererConfig: e.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: s.ReactCurrentDispatcher, findHostInstanceByFiber: hs, findFiberByHostInstance: e.findFiberByHostInstance || ps, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, "undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) e = !1; else { var t = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (t.isDisabled || !t.supportsFiber) e = !0; else { try { jt = t.inject(e), Vt = t } catch (e) { } e = !!t.checkDCE } } return e }, t.isAlreadyRendering = function () { return !1 }, t.observeVisibleRects = function (e, t, n, r) { if (!re) throw Error(o(363)); e = Ga(e, t); var i = ue(e, n, r).disconnect; return { disconnect: function () { i() } } }, t.registerMutableSourceForHydration = function (e, t) { var n = t._getVersion; n = n(t._source), null == e.mutableSourceEagerHydrationData ? e.mutableSourceEagerHydrationData = [t, n] : e.mutableSourceEagerHydrationData.push(t, n) }, t.runWithPriority = function (e, t) { var n = Pt; try { return Pt = e, t() } finally { Pt = n } }, t.shouldError = function () { return null }, t.shouldSuspend = function () { return !1 }, t.updateContainer = function (e, t, n, r) { var i = t.current, a = Ao(), o = So(i); return n = ls(n), null === t.context ? t.context = n : t.pendingContext = n, (t = gn(a, o)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), vn(i, t), null !== (e = Mo(i, o, a)) && yn(e, i, o), o }, t } }, 772: (e, t, n) => { "use strict"; e.exports = n(735) }, 845: (e, t, n) => { "use strict"; e.exports = n(935) }, 20: (e, t, n) => { "use strict"; var r = n(540), i = Symbol.for("react.element"), a = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, a = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) o.call(t, r) && !l.hasOwnProperty(r) && (a[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === a[r] && (a[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: a, _owner: s.current } } t.Fragment = a, t.jsx = c, t.jsxs = c }, 287: (e, t) => { "use strict"; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.iterator, f = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function v(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || f } function y() { } function b(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || f } v.prototype.isReactComponent = {}, v.prototype.setState = function (e, t) { if ("object" != typeof e && "function" != typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, v.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, y.prototype = v.prototype; var x = b.prototype = new y; x.constructor = b, m(x, v.prototype), x.isPureReactComponent = !0; var A = Array.isArray, S = Object.prototype.hasOwnProperty, M = { current: null }, w = { key: !0, ref: !0, __self: !0, __source: !0 }; function _(e, t, r) { var i, a = {}, o = null, s = null; if (null != t) for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (o = "" + t.key), t) S.call(t, i) && !w.hasOwnProperty(i) && (a[i] = t[i]); var l = arguments.length - 2; if (1 === l) a.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; a.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === a[i] && (a[i] = l[i]); return { $$typeof: n, type: e, key: o, ref: s, props: a, _owner: M.current } } function E(e) { return "object" == typeof e && null !== e && e.$$typeof === n } var C = /\/+/g; function T(e, t) { return "object" == typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function R(e, t, i, a, o) { var s = typeof e; "undefined" !== s && "boolean" !== s || (e = null); var l = !1; if (null === e) l = !0; else switch (s) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return o = o(l = e), e = "" === a ? "." + T(l, 0) : a, A(o) ? (i = "", null != e && (i = e.replace(C, "$&/") + "/"), R(o, t, i, "", (function (e) { return e }))) : null != o && (E(o) && (o = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(o, i + (!o.key || l && l.key === o.key ? "" : ("" + o.key).replace(C, "$&/") + "/") + e)), t.push(o)), 1; if (l = 0, a = "" === a ? "." : a + ":", A(e)) for (var c = 0; c < e.length; c++) { var u = a + T(s = e[c], c); l += R(s, t, i, u, o) } else if (u = function (e) { return null === e || "object" != typeof e ? null : "function" == typeof (e = p && e[p] || e["@@iterator"]) ? e : null }(e), "function" == typeof u) for (e = u.call(e), c = 0; !(s = e.next()).done;)l += R(s = s.value, t, i, u = a + T(s, c++), o); else if ("object" === s) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function B(e, t, n) { if (null == e) return e; var r = [], i = 0; return R(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function I(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var P = { current: null }, L = { transition: null }, D = { ReactCurrentDispatcher: P, ReactCurrentBatchConfig: L, ReactCurrentOwner: M }; function k() { throw Error("act(...) is not supported in production builds of React.") } t.Children = { map: B, forEach: function (e, t, n) { B(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return B(e, (function () { t++ })), t }, toArray: function (e) { return B(e, (function (e) { return e })) || [] }, only: function (e) { if (!E(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = v, t.Fragment = i, t.Profiler = o, t.PureComponent = b, t.StrictMode = a, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D, t.act = k, t.cloneElement = function (e, t, r) { if (null == e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = m({}, e.props), a = e.key, o = e.ref, s = e._owner; if (null != t) { if (void 0 !== t.ref && (o = t.ref, s = M.current), void 0 !== t.key && (a = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) S.call(t, c) && !w.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: a, ref: o, props: i, _owner: s } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: s, _context: e }, e.Consumer = e }, t.createElement = _, t.createFactory = function (e) { var t = _.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = E, t.lazy = function (e) { return { $$typeof: h, _payload: { _status: -1, _result: e }, _init: I } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = L.transition; L.transition = {}; try { e() } finally { L.transition = t } }, t.unstable_act = k, t.useCallback = function (e, t) { return P.current.useCallback(e, t) }, t.useContext = function (e) { return P.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return P.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return P.current.useEffect(e, t) }, t.useId = function () { return P.current.useId() }, t.useImperativeHandle = function (e, t, n) { return P.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return P.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return P.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return P.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return P.current.useReducer(e, t, n) }, t.useRef = function (e) { return P.current.useRef(e) }, t.useState = function (e) { return P.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return P.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return P.current.useTransition() }, t.version = "18.3.1" }, 540: (e, t, n) => { "use strict"; e.exports = n(287) }, 848: (e, t, n) => { "use strict"; e.exports = n(20) }, 463: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < a(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var s = 2 * (r + 1) - 1, l = e[s], c = s + 1, u = e[c]; if (0 > a(l, n)) c < i && 0 > a(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s); else { if (!(c < i && 0 > a(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function a(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" == typeof performance && "function" == typeof performance.now) { var o = performance; t.unstable_now = function () { return o.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var c = [], u = [], d = 1, h = null, p = 3, f = !1, m = !1, g = !1, v = "function" == typeof setTimeout ? setTimeout : null, y = "function" == typeof clearTimeout ? clearTimeout : null, b = "undefined" != typeof setImmediate ? setImmediate : null; function x(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function A(e) { if (g = !1, x(e), !m) if (null !== r(c)) m = !0, L(S); else { var t = r(u); null !== t && D(A, t.startTime - e) } } function S(e, n) { m = !1, g && (g = !1, y(E), E = -1), f = !0; var a = p; try { for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !R());) { var o = h.callback; if ("function" == typeof o) { h.callback = null, p = h.priorityLevel; var s = o(h.expirationTime <= n); n = t.unstable_now(), "function" == typeof s ? h.callback = s : h === r(c) && i(c), x(n) } else i(c); h = r(c) } if (null !== h) var l = !0; else { var d = r(u); null !== d && D(A, d.startTime - n), l = !1 } return l } finally { h = null, p = a, f = !1 } } "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var M, w = !1, _ = null, E = -1, C = 5, T = -1; function R() { return !(t.unstable_now() - T < C) } function B() { if (null !== _) { var e = t.unstable_now(); T = e; var n = !0; try { n = _(!0, e) } finally { n ? M() : (w = !1, _ = null) } } else w = !1 } if ("function" == typeof b) M = function () { b(B) }; else if ("undefined" != typeof MessageChannel) { var I = new MessageChannel, P = I.port2; I.port1.onmessage = B, M = function () { P.postMessage(null) } } else M = function () { v(B, 0) }; function L(e) { _ = e, w || (w = !0, M()) } function D(e, n) { E = v((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || f || (m = !0, L(S)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return p }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (p) { case 1: case 2: case 3: var t = 3; break; default: t = p }var n = p; p = t; try { return e() } finally { p = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = p; p = e; try { return t() } finally { p = n } }, t.unstable_scheduleCallback = function (e, i, a) { var o = t.unstable_now(); switch (a = "object" == typeof a && null !== a && "number" == typeof (a = a.delay) && 0 < a ? o + a : o, e) { case 1: var s = -1; break; case 2: s = 250; break; case 5: s = 1073741823; break; case 4: s = 1e4; break; default: s = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: a, expirationTime: s = a + s, sortIndex: -1 }, a > o ? (e.sortIndex = a, n(u, e), null === r(c) && e === r(u) && (g ? (y(E), E = -1) : g = !0, D(A, a - o))) : (e.sortIndex = s, n(c, e), m || f || (m = !0, L(S))), e }, t.unstable_shouldYield = R, t.unstable_wrapCallback = function (e) { var t = p; return function () { var n = p; p = t; try { return e.apply(this, arguments) } finally { p = n } } } }, 982: (e, t, n) => { "use strict"; e.exports = n(463) }, 72: e => { "use strict"; var t = []; function n(e) { for (var n = -1, r = 0; r < t.length; r++)if (t[r].identifier === e) { n = r; break } return n } function r(e, r) { for (var a = {}, o = [], s = 0; s < e.length; s++) { var l = e[s], c = r.base ? l[0] + r.base : l[0], u = a[c] || 0, d = "".concat(c, " ").concat(u); a[c] = u + 1; var h = n(d), p = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] }; if (-1 !== h) t[h].references++, t[h].updater(p); else { var f = i(p, r); r.byIndex = s, t.splice(s, 0, { identifier: d, updater: f, references: 1 }) } o.push(d) } return o } function i(e, t) { var n = t.domAPI(t); return n.update(e), function (t) { if (t) { if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return; n.update(e = t) } else n.remove() } } e.exports = function (e, i) { var a = r(e = e || [], i = i || {}); return function (e) { e = e || []; for (var o = 0; o < a.length; o++) { var s = n(a[o]); t[s].references-- } for (var l = r(e, i), c = 0; c < a.length; c++) { var u = n(a[c]); 0 === t[u].references && (t[u].updater(), t.splice(u, 1)) } a = l } } }, 659: e => { "use strict"; var t = {}; e.exports = function (e, n) { var r = function (e) { if (void 0 === t[e]) { var n = document.querySelector(e); if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try { n = n.contentDocument.head } catch (e) { n = null } t[e] = n } return t[e] }(e); if (!r) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); r.appendChild(n) } }, 159: e => { "use strict"; e.exports = function (e) { var t = document.createElement("style"); return e.setAttributes(t, e.attributes), e.insert(t, e.options), t } }, 56: (e, t, n) => { "use strict"; e.exports = function (e) { var t = n.nc; t && e.setAttribute("nonce", t) } }, 825: e => { "use strict"; e.exports = function (e) { if ("undefined" == typeof document) return { update: function () { }, remove: function () { } }; var t = e.insertStyleElement(e); return { update: function (n) { !function (e, t, n) { var r = ""; n.supports && (r += "@supports (".concat(n.supports, ") {")), n.media && (r += "@media ".concat(n.media, " {")); var i = void 0 !== n.layer; i && (r += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")), r += n.css, i && (r += "}"), n.media && (r += "}"), n.supports && (r += "}"); var a = n.sourceMap; a && "undefined" != typeof btoa && (r += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))), " */")), t.styleTagTransform(r, e, t.options) }(t, e, n) }, remove: function () { !function (e) { if (null === e.parentNode) return !1; e.parentNode.removeChild(e) }(t) } } } }, 113: e => { "use strict"; e.exports = function (e, t) { if (t.styleSheet) t.styleSheet.cssText = e; else { for (; t.firstChild;)t.removeChild(t.firstChild); t.appendChild(document.createTextNode(e)) } } }, 63: (e, t, n) => { "use strict"; var r = n(540), i = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, a = r.useState, o = r.useEffect, s = r.useLayoutEffect, l = r.useDebugValue; function c(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !i(e, n) } catch (e) { return !0 } } var u = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), r = a({ inst: { value: n, getSnapshot: t } }), i = r[0].inst, u = r[1]; return s((function () { i.value = n, i.getSnapshot = t, c(i) && u({ inst: i }) }), [e, n, t]), o((function () { return c(i) && u({ inst: i }), e((function () { c(i) && u({ inst: i }) })) }), [e]), l(n), n }; t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : u }, 940: (e, t, n) => { "use strict"; var r = n(540), i = n(888), a = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, o = i.useSyncExternalStore, s = r.useRef, l = r.useEffect, c = r.useMemo, u = r.useDebugValue; t.useSyncExternalStoreWithSelector = function (e, t, n, r, i) { var d = s(null); if (null === d.current) { var h = { hasValue: !1, value: null }; d.current = h } else h = d.current; d = c((function () { function e(e) { if (!l) { if (l = !0, o = e, e = r(e), void 0 !== i && h.hasValue) { var t = h.value; if (i(t, e)) return s = t } return s = e } if (t = s, a(o, e)) return t; var n = r(e); return void 0 !== i && i(t, n) ? t : (o = e, s = n) } var o, s, l = !1, c = void 0 === n ? null : n; return [function () { return e(t()) }, null === c ? void 0 : function () { return e(c()) }] }), [t, n, r, i]); var p = o(e, d[0], d[1]); return l((function () { h.hasValue = !0, h.value = p }), [p]), u(p), p } }, 888: (e, t, n) => { "use strict"; e.exports = n(63) }, 242: (e, t, n) => { "use strict"; e.exports = n(940) }, 985: (e, t, n) => { "use strict"; e.exports = n.p + "block_game_clone/f5c442719112209deeaa.wasm" } }, r = {}; function i(e) { var t = r[e]; if (void 0 !== t) return t.exports; var a = r[e] = { id: e, exports: {} }; return n[e](a, a.exports, i), a.exports } i.m = n, i.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return i.d(t, { a: t }), t }, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, i.t = function (n, r) { if (1 & r && (n = this(n)), 8 & r) return n; if ("object" == typeof n && n) { if (4 & r && n.__esModule) return n; if (16 & r && "function" == typeof n.then) return n } var a = Object.create(null); i.r(a); var o = {}; e = e || [null, t({}), t([]), t(t)]; for (var s = 2 & r && n; "object" == typeof s && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach((e => o[e] = () => n[e])); return o.default = () => n, i.d(a, o), a }, i.d = (e, t) => { for (var n in t) i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, i.p = "/", i.b = document.baseURI || self.location.href, i.nc = void 0, (() => {
    "use strict"; var e = {}; i.r(e), i.d(e, { ACESFilmicToneMapping: () => hc, AddEquation: () => Il, AddOperation: () => sc, AdditiveAnimationBlendMode: () => Ku, AdditiveBlending: () => Cl, AgXToneMapping: () => fc, AlphaFormat: () => Qc, AlwaysCompare: () => Od, AlwaysDepth: () => Zl, AlwaysStencilFunc: () => Bd, AmbientLight: () => wS, AnimationAction: () => pM, AnimationClip: () => YA, AnimationLoader: () => rS, AnimationMixer: () => mM, AnimationObjectGroup: () => hM, AnimationUtils: () => kA, ArcCurve: () => ex, ArrayCamera: () => ey, ArrowHelper: () => lw, AttachedBindMode: () => gc, Audio: () => qS, AudioAnalyser: () => rM, AudioContext: () => OS, AudioListener: () => KS, AudioLoader: () => US, AxesHelper: () => cw, BackSide: () => Ml, BasicDepthPacking: () => ed, BasicShadowMap: () => yl, BatchedMesh: () => wb, Bone: () => Xy, BooleanKeyframeTrack: () => HA, Box2: () => RM, Box3: () => Wh, Box3Helper: () => rw, BoxGeometry: () => em, BoxHelper: () => nw, BufferAttribute: () => Mf, BufferGeometry: () => zf, BufferGeometryLoader: () => IS, ByteType: () => Oc, Cache: () => KA, Camera: () => om, CameraHelper: () => $M, CanvasTexture: () => qb, CapsuleGeometry: () => Ax, CatmullRomCurve3: () => ox, CineonToneMapping: () => dc, CircleGeometry: () => Sx, ClampToEdgeWrapping: () => _c, Clock: () => VS, Color: () => df, ColorKeyframeTrack: () => GA, ColorManagement: () => wh, CompressedArrayTexture: () => Qb, CompressedCubeTexture: () => Kb, CompressedTexture: () => Yb, CompressedTextureLoader: () => iS, ConeGeometry: () => wx, ConstantAlphaFactor: () => Ql, ConstantColorFactor: () => Jl, Controls: () => dw, CubeCamera: () => hm, CubeReflectionMapping: () => bc, CubeRefractionMapping: () => xc, CubeTexture: () => pm, CubeTextureLoader: () => oS, CubeUVReflectionMapping: () => Mc, CubicBezierCurve: () => ux, CubicBezierCurve3: () => dx, CubicInterpolant: () => FA, CullFaceBack: () => ml, CullFaceFront: () => gl, CullFaceFrontBack: () => vl, CullFaceNone: () => fl, Curve: () => Zb, CurvePath: () => yx, CustomBlending: () => Bl, CustomToneMapping: () => pc, CylinderGeometry: () => Mx, Cylindrical: () => EM, Data3DTexture: () => Uh, DataArrayTexture: () => Fh, DataTexture: () => Jy, DataTextureLoader: () => sS, DataUtils: () => xf, DecrementStencilOp: () => bd, DecrementWrapStencilOp: () => Ad, DefaultLoadingManager: () => ZA, DepthFormat: () => eu, DepthStencilFormat: () => tu, DepthTexture: () => og, DetachedBindMode: () => vc, DirectionalLight: () => MS, DirectionalLightHelper: () => KM, DiscreteInterpolant: () => UA, DisplayP3ColorSpace: () => cd, DodecahedronGeometry: () => Ex, DoubleSide: () => wl, DstAlphaFactor: () => Gl, DstColorFactor: () => Vl, DynamicCopyUsage: () => Xd, DynamicDrawUsage: () => zd, DynamicReadUsage: () => jd, EdgesGeometry: () => Ix, EllipseCurve: () => $b, EqualCompare: () => Ld, EqualDepth: () => tc, EqualStencilFunc: () => _d, EquirectangularReflectionMapping: () => Ac, EquirectangularRefractionMapping: () => Sc, Euler: () => Tp, EventDispatcher: () => Zd, ExtrudeGeometry: () => oA, FileLoader: () => nS, Float16BufferAttribute: () => If, Float32BufferAttribute: () => Pf, FloatType: () => jc, Fog: () => hy, FogExp2: () => dy, FramebufferTexture: () => Jb, FrontSide: () => Sl, Frustum: () => Am, GLBufferAttribute: () => xM, GLSL1: () => Yd, GLSL3: () => Qd, GreaterCompare: () => kd, GreaterDepth: () => rc, GreaterEqualCompare: () => Fd, GreaterEqualDepth: () => nc, GreaterEqualStencilFunc: () => Rd, GreaterStencilFunc: () => Cd, GridHelper: () => WM, Group: () => ty, HalfFloatType: () => Vc, HemisphereLight: () => uS, HemisphereLightHelper: () => VM, IcosahedronGeometry: () => lA, ImageBitmapLoader: () => NS, ImageLoader: () => aS, ImageUtils: () => Th, IncrementStencilOp: () => yd, IncrementWrapStencilOp: () => xd, InstancedBufferAttribute: () => qy, InstancedBufferGeometry: () => BS, InstancedInterleavedBuffer: () => bM, InstancedMesh: () => ab, Int16BufferAttribute: () => Cf, Int32BufferAttribute: () => Rf, Int8BufferAttribute: () => wf, IntType: () => Hc, InterleavedBuffer: () => fy, InterleavedBufferAttribute: () => gy, Interpolant: () => NA, InterpolateDiscrete: () => ju, InterpolateLinear: () => Vu, InterpolateSmooth: () => Wu, InvertStencilOp: () => Sd, KeepStencilOp: () => gd, KeyframeTrack: () => zA, LOD: () => ky, LatheGeometry: () => xx, Layers: () => Rp, LessCompare: () => Pd, LessDepth: () => $l, LessEqualCompare: () => Dd, LessEqualDepth: () => ec, LessEqualStencilFunc: () => Ed, LessStencilFunc: () => wd, Light: () => cS, LightProbe: () => CS, Line: () => Lb, Line3: () => PM, LineBasicMaterial: () => _b, LineCurve: () => hx, LineCurve3: () => px, LineDashedMaterial: () => RA, LineLoop: () => Ob, LineSegments: () => Fb, LinearDisplayP3ColorSpace: () => ud, LinearFilter: () => Pc, LinearInterpolant: () => OA, LinearMipMapLinearFilter: () => Nc, LinearMipMapNearestFilter: () => Dc, LinearMipmapLinearFilter: () => kc, LinearMipmapNearestFilter: () => Lc, LinearSRGBColorSpace: () => ld, LinearToneMapping: () => cc, LinearTransfer: () => dd, Loader: () => $A, LoaderUtils: () => RS, LoadingManager: () => qA, LoopOnce: () => zu, LoopPingPong: () => Gu, LoopRepeat: () => Hu, LuminanceAlphaFormat: () => $c, LuminanceFormat: () => Zc, MOUSE: () => hl, Material: () => ff, MaterialLoader: () => TS, MathUtils: () => ch, Matrix2: () => CM, Matrix3: () => dh, Matrix4: () => yp, MaxEquation: () => kl, Mesh: () => Zf, MeshBasicMaterial: () => mf, MeshDepthMaterial: () => Wv, MeshDistanceMaterial: () => Xv, MeshLambertMaterial: () => CA, MeshMatcapMaterial: () => TA, MeshNormalMaterial: () => EA, MeshPhongMaterial: () => wA, MeshPhysicalMaterial: () => MA, MeshStandardMaterial: () => SA, MeshToonMaterial: () => _A, MinEquation: () => Dl, MirroredRepeatWrapping: () => Ec, MixOperation: () => oc, MultiplyBlending: () => Rl, MultiplyOperation: () => ac, NearestFilter: () => Cc, NearestMipMapLinearFilter: () => Ic, NearestMipMapNearestFilter: () => Rc, NearestMipmapLinearFilter: () => Bc, NearestMipmapNearestFilter: () => Tc, NeutralToneMapping: () => mc, NeverCompare: () => Id, NeverDepth: () => ql, NeverStencilFunc: () => Md, NoBlending: () => _l, NoColorSpace: () => od, NoToneMapping: () => lc, NormalAnimationBlendMode: () => Qu, NormalBlending: () => El, NotEqualCompare: () => Nd, NotEqualDepth: () => ic, NotEqualStencilFunc: () => Td, NumberKeyframeTrack: () => jA, Object3D: () => Wp, ObjectLoader: () => PS, ObjectSpaceNormalMap: () => ad, OctahedronGeometry: () => cA, OneFactor: () => Fl, OneMinusConstantAlphaFactor: () => Kl, OneMinusConstantColorFactor: () => Yl, OneMinusDstAlphaFactor: () => jl, OneMinusDstColorFactor: () => Wl, OneMinusSrcAlphaFactor: () => Hl, OneMinusSrcColorFactor: () => Ul, OrthographicCamera: () => Fm, P3Primaries: () => fd, PCFShadowMap: () => bl, PCFSoftShadowMap: () => xl, PMREMGenerator: () => Ym, Path: () => bx, PerspectiveCamera: () => um, Plane: () => ym, PlaneGeometry: () => wm, PlaneHelper: () => iw, PointLight: () => AS, PointLightHelper: () => zM, Points: () => Vb, PointsMaterial: () => Ub, PolarGridHelper: () => XM, PolyhedronGeometry: () => _x, PositionalAudio: () => nM, PropertyBinding: () => dM, PropertyMixer: () => iM, QuadraticBezierCurve: () => fx, QuadraticBezierCurve3: () => mx, Quaternion: () => Hh, QuaternionKeyframeTrack: () => WA, QuaternionLinearInterpolant: () => VA, RED_GREEN_RGTC2_Format: () => Ou, RED_RGTC1_Format: () => Nu, REVISION: () => dl, RGBADepthPacking: () => td, RGBAFormat: () => qc, RGBAIntegerFormat: () => su, RGBA_ASTC_10x10_Format: () => Bu, RGBA_ASTC_10x5_Format: () => Cu, RGBA_ASTC_10x6_Format: () => Tu, RGBA_ASTC_10x8_Format: () => Ru, RGBA_ASTC_12x10_Format: () => Iu, RGBA_ASTC_12x12_Format: () => Pu, RGBA_ASTC_4x4_Format: () => bu, RGBA_ASTC_5x4_Format: () => xu, RGBA_ASTC_5x5_Format: () => Au, RGBA_ASTC_6x5_Format: () => Su, RGBA_ASTC_6x6_Format: () => Mu, RGBA_ASTC_8x5_Format: () => wu, RGBA_ASTC_8x6_Format: () => _u, RGBA_ASTC_8x8_Format: () => Eu, RGBA_BPTC_Format: () => Lu, RGBA_ETC2_EAC_Format: () => yu, RGBA_PVRTC_2BPPV1_Format: () => mu, RGBA_PVRTC_4BPPV1_Format: () => fu, RGBA_S3TC_DXT1_Format: () => cu, RGBA_S3TC_DXT3_Format: () => uu, RGBA_S3TC_DXT5_Format: () => du, RGBDepthPacking: () => nd, RGBFormat: () => Kc, RGBIntegerFormat: () => ou, RGB_BPTC_SIGNED_Format: () => Du, RGB_BPTC_UNSIGNED_Format: () => ku, RGB_ETC1_Format: () => gu, RGB_ETC2_Format: () => vu, RGB_PVRTC_2BPPV1_Format: () => pu, RGB_PVRTC_4BPPV1_Format: () => hu, RGB_S3TC_DXT1_Format: () => lu, RGDepthPacking: () => rd, RGFormat: () => iu, RGIntegerFormat: () => au, RawShaderMaterial: () => AA, Ray: () => vp, Raycaster: () => SM, Rec709Primaries: () => pd, RectAreaLight: () => _S, RedFormat: () => nu, RedIntegerFormat: () => ru, ReinhardToneMapping: () => uc, RenderTarget: () => kh, RepeatWrapping: () => wc, ReplaceStencilOp: () => vd, ReverseSubtractEquation: () => Ll, RingGeometry: () => uA, SIGNED_RED_GREEN_RGTC2_Format: () => Uu, SIGNED_RED_RGTC1_Format: () => Fu, SRGBColorSpace: () => sd, SRGBTransfer: () => hd, Scene: () => py, ShaderChunk: () => _m, ShaderLib: () => Cm, ShaderMaterial: () => am, ShadowMaterial: () => xA, Shape: () => Px, ShapeGeometry: () => dA, ShapePath: () => uw, ShapeUtils: () => rA, ShortType: () => Uc, Skeleton: () => Ky, SkeletonHelper: () => OM, SkinnedMesh: () => Wy, Source: () => Bh, Sphere: () => cp, SphereGeometry: () => hA, Spherical: () => _M, SphericalHarmonics3: () => ES, SplineCurve: () => gx, SpotLight: () => gS, SpotLightHelper: () => DM, Sprite: () => Iy, SpriteMaterial: () => vy, SrcAlphaFactor: () => zl, SrcAlphaSaturateFactor: () => Xl, SrcColorFactor: () => Ol, StaticCopyUsage: () => Wd, StaticDrawUsage: () => Ud, StaticReadUsage: () => Gd, StereoCamera: () => jS, StreamCopyUsage: () => Jd, StreamDrawUsage: () => Hd, StreamReadUsage: () => Vd, StringKeyframeTrack: () => XA, SubtractEquation: () => Pl, SubtractiveBlending: () => Tl, TOUCH: () => pl, TangentSpaceNormalMap: () => id, TetrahedronGeometry: () => pA, Texture: () => Lh, TextureLoader: () => lS, TextureUtils: () => qv, TorusGeometry: () => fA, TorusKnotGeometry: () => mA, Triangle: () => of, TriangleFanDrawMode: () => $u, TriangleStripDrawMode: () => Zu, TrianglesDrawMode: () => qu, TubeGeometry: () => gA, UVMapping: () => yc, Uint16BufferAttribute: () => Tf, Uint32BufferAttribute: () => Bf, Uint8BufferAttribute: () => _f, Uint8ClampedBufferAttribute: () => Ef, Uniform: () => gM, UniformsGroup: () => yM, UniformsLib: () => Em, UniformsUtils: () => im, UnsignedByteType: () => Fc, UnsignedInt248Type: () => Jc, UnsignedInt5999Type: () => Yc, UnsignedIntType: () => Gc, UnsignedShort4444Type: () => Wc, UnsignedShort5551Type: () => Xc, UnsignedShortType: () => zc, VSMShadowMap: () => Al, Vector2: () => uh, Vector3: () => Gh, Vector4: () => Dh, VectorKeyframeTrack: () => JA, VideoTexture: () => Xb, WebGL3DRenderTarget: () => zh, WebGLArrayRenderTarget: () => Oh, WebGLCoordinateSystem: () => Kd, WebGLCubeRenderTarget: () => fm, WebGLMultipleRenderTargets: () => hw, WebGLRenderTarget: () => Nh, WebGLRenderer: () => uy, WebGLUtils: () => $v, WebGPUCoordinateSystem: () => qd, WireframeGeometry: () => vA, WrapAroundEnding: () => Yu, ZeroCurvatureEnding: () => Xu, ZeroFactor: () => Nl, ZeroSlopeEnding: () => Ju, ZeroStencilOp: () => md, createCanvasElement: () => vh }); var t = {}; i.r(t), i.d(t, { default: () => fB, initSync: () => hB, new_game: () => cB, next_game_state: () => uB }); var n = i(540), r = i.t(n, 2), a = i(338), o = i(72), s = i.n(o), l = i(825), c = i.n(l), u = i(659), d = i.n(u), h = i(56), p = i.n(h), f = i(159), m = i.n(f), g = i(113), v = i.n(g), y = i(702), b = {}; b.styleTagTransform = v(), b.setAttributes = p(), b.insert = d().bind(null, "head"), b.domAPI = c(), b.insertStyleElement = m(), s()(y.A, b); const x = y.A && y.A.locals ? y.A.locals : void 0, A = { p1: "#03adfc", p2: "#008000" }; function S(e) { var t, n, r = ""; if ("string" == typeof e || "number" == typeof e) r += e; else if ("object" == typeof e) if (Array.isArray(e)) { var i = e.length; for (t = 0; t < i; t++)e[t] && (n = S(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } const M = function () { for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = S(e)) && (r && (r += " "), r += t); return r }; function w(e, t, n = void 0) { const r = {}; for (const i in e) { const a = e[i]; let o = "", s = !0; for (let e = 0; e < a.length; e += 1) { const r = a[e]; r && (o += (!0 === s ? "" : " ") + t(r), s = !1, n && n[r] && (o += " " + n[r])) } r[i] = o } return r } function _() { return _ = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, _.apply(null, arguments) } function E(e) { var t = Object.create(null); return function (n) { return void 0 === t[n] && (t[n] = e(n)), t[n] } } var C = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, T = E((function (e) { return C.test(e) || 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) < 91 })), R = function () { function e(e) { var t = this; this._insertTag = function (e) { var n; n = 0 === t.tags.length ? t.insertionPoint ? t.insertionPoint.nextSibling : t.prepend ? t.container.firstChild : t.before : t.tags[t.tags.length - 1].nextSibling, t.container.insertBefore(e, n), t.tags.push(e) }, this.isSpeedy = void 0 === e.speedy || e.speedy, this.tags = [], this.ctr = 0, this.nonce = e.nonce, this.key = e.key, this.container = e.container, this.prepend = e.prepend, this.insertionPoint = e.insertionPoint, this.before = null } var t = e.prototype; return t.hydrate = function (e) { e.forEach(this._insertTag) }, t.insert = function (e) { this.ctr % (this.isSpeedy ? 65e3 : 1) == 0 && this._insertTag(function (e) { var t = document.createElement("style"); return t.setAttribute("data-emotion", e.key), void 0 !== e.nonce && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t }(this)); var t = this.tags[this.tags.length - 1]; if (this.isSpeedy) { var n = function (e) { if (e.sheet) return e.sheet; for (var t = 0; t < document.styleSheets.length; t++)if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t] }(t); try { n.insertRule(e, n.cssRules.length) } catch (e) { } } else t.appendChild(document.createTextNode(e)); this.ctr++ }, t.flush = function () { this.tags.forEach((function (e) { var t; return null == (t = e.parentNode) ? void 0 : t.removeChild(e) })), this.tags = [], this.ctr = 0 }, e }(), B = Math.abs, I = String.fromCharCode, P = Object.assign; function L(e) { return e.trim() } function D(e, t, n) { return e.replace(t, n) } function k(e, t) { return e.indexOf(t) } function N(e, t) { return 0 | e.charCodeAt(t) } function F(e, t, n) { return e.slice(t, n) } function O(e) { return e.length } function U(e) { return e.length } function z(e, t) { return t.push(e), e } var H = 1, G = 1, j = 0, V = 0, W = 0, X = ""; function J(e, t, n, r, i, a, o) { return { value: e, root: t, parent: n, type: r, props: i, children: a, line: H, column: G, length: o, return: "" } } function Y(e, t) { return P(J("", null, null, "", null, null, 0), e, { length: -e.length }, t) } function Q() { return W = V > 0 ? N(X, --V) : 0, G--, 10 === W && (G = 1, H--), W } function K() { return W = V < j ? N(X, V++) : 0, G++, 10 === W && (G = 1, H++), W } function q() { return N(X, V) } function Z() { return V } function $(e, t) { return F(X, e, t) } function ee(e) { switch (e) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1 }return 0 } function te(e) { return H = G = 1, j = O(X = e), V = 0, [] } function ne(e) { return X = "", e } function re(e) { return L($(V - 1, oe(91 === e ? e + 2 : 40 === e ? e + 1 : e))) } function ie(e) { for (; (W = q()) && W < 33;)K(); return ee(e) > 2 || ee(W) > 3 ? "" : " " } function ae(e, t) { for (; --t && K() && !(W < 48 || W > 102 || W > 57 && W < 65 || W > 70 && W < 97);); return $(e, Z() + (t < 6 && 32 == q() && 32 == K())) } function oe(e) { for (; K();)switch (W) { case e: return V; case 34: case 39: 34 !== e && 39 !== e && oe(W); break; case 40: 41 === e && oe(e); break; case 92: K() }return V } function se(e, t) { for (; K() && e + W !== 57 && (e + W !== 84 || 47 !== q());); return "/*" + $(t, V - 1) + "*" + I(47 === e ? e : K()) } function le(e) { for (; !ee(q());)K(); return $(e, V) } var ce = "-ms-", ue = "-moz-", de = "-webkit-", he = "comm", pe = "rule", fe = "decl", me = "@keyframes"; function ge(e, t) { for (var n = "", r = U(e), i = 0; i < r; i++)n += t(e[i], i, e, t) || ""; return n } function ve(e, t, n, r) { switch (e.type) { case "@layer": if (e.children.length) break; case "@import": case fe: return e.return = e.return || e.value; case he: return ""; case me: return e.return = e.value + "{" + ge(e.children, r) + "}"; case pe: e.value = e.props.join(",") }return O(n = ge(e.children, r)) ? e.return = e.value + "{" + n + "}" : "" } function ye(e) { return ne(be("", null, null, null, [""], e = te(e), 0, [0], e)) } function be(e, t, n, r, i, a, o, s, l) { for (var c = 0, u = 0, d = o, h = 0, p = 0, f = 0, m = 1, g = 1, v = 1, y = 0, b = "", x = i, A = a, S = r, M = b; g;)switch (f = y, y = K()) { case 40: if (108 != f && 58 == N(M, d - 1)) { -1 != k(M += D(re(y), "&", "&\f"), "&\f") && (v = -1); break } case 34: case 39: case 91: M += re(y); break; case 9: case 10: case 13: case 32: M += ie(f); break; case 92: M += ae(Z() - 1, 7); continue; case 47: switch (q()) { case 42: case 47: z(Ae(se(K(), Z()), t, n), l); break; default: M += "/" }break; case 123 * m: s[c++] = O(M) * v; case 125 * m: case 59: case 0: switch (y) { case 0: case 125: g = 0; case 59 + u: -1 == v && (M = D(M, /\f/g, "")), p > 0 && O(M) - d && z(p > 32 ? Se(M + ";", r, n, d - 1) : Se(D(M, " ", "") + ";", r, n, d - 2), l); break; case 59: M += ";"; default: if (z(S = xe(M, t, n, c, u, i, s, b, x = [], A = [], d), a), 123 === y) if (0 === u) be(M, t, S, S, x, a, d, s, A); else switch (99 === h && 110 === N(M, 3) ? 100 : h) { case 100: case 108: case 109: case 115: be(e, S, S, r && z(xe(e, S, S, 0, 0, i, s, b, i, x = [], d), A), i, A, d, s, r ? x : A); break; default: be(M, S, S, S, [""], A, 0, s, A) } }c = u = p = 0, m = v = 1, b = M = "", d = o; break; case 58: d = 1 + O(M), p = f; default: if (m < 1) if (123 == y) --m; else if (125 == y && 0 == m++ && 125 == Q()) continue; switch (M += I(y), y * m) { case 38: v = u > 0 ? 1 : (M += "\f", -1); break; case 44: s[c++] = (O(M) - 1) * v, v = 1; break; case 64: 45 === q() && (M += re(K())), h = q(), u = d = O(b = M += le(Z())), y++; break; case 45: 45 === f && 2 == O(M) && (m = 0) } }return a } function xe(e, t, n, r, i, a, o, s, l, c, u) { for (var d = i - 1, h = 0 === i ? a : [""], p = U(h), f = 0, m = 0, g = 0; f < r; ++f)for (var v = 0, y = F(e, d + 1, d = B(m = o[f])), b = e; v < p; ++v)(b = L(m > 0 ? h[v] + " " + y : D(y, /&\f/g, h[v]))) && (l[g++] = b); return J(e, t, n, 0 === i ? pe : s, l, c, u) } function Ae(e, t, n) { return J(e, t, n, he, I(W), F(e, 2, -2), 0) } function Se(e, t, n, r) { return J(e, t, n, fe, F(e, 0, r), F(e, r + 1, -1), r) } var Me = function (e, t, n) { for (var r = 0, i = 0; r = i, i = q(), 38 === r && 12 === i && (t[n] = 1), !ee(i);)K(); return $(e, V) }, we = new WeakMap, _e = function (e) { if ("rule" === e.type && e.parent && !(e.length < 1)) { for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; "rule" !== n.type;)if (!(n = n.parent)) return; if ((1 !== e.props.length || 58 === t.charCodeAt(0) || we.get(n)) && !r) { we.set(e, !0); for (var i = [], a = function (e, t) { return ne(function (e, t) { var n = -1, r = 44; do { switch (ee(r)) { case 0: 38 === r && 12 === q() && (t[n] = 1), e[n] += Me(V - 1, t, n); break; case 2: e[n] += re(r); break; case 4: if (44 === r) { e[++n] = 58 === q() ? "&\f" : "", t[n] = e[n].length; break } default: e[n] += I(r) } } while (r = K()); return e }(te(e), t)) }(t, i), o = n.props, s = 0, l = 0; s < a.length; s++)for (var c = 0; c < o.length; c++, l++)e.props[l] = i[s] ? a[s].replace(/&\f/g, o[c]) : o[c] + " " + a[s] } } }, Ee = function (e) { if ("decl" === e.type) { var t = e.value; 108 === t.charCodeAt(0) && 98 === t.charCodeAt(2) && (e.return = "", e.value = "") } }; function Ce(e, t) { switch (function (e, t) { return 45 ^ N(e, 0) ? (((t << 2 ^ N(e, 0)) << 2 ^ N(e, 1)) << 2 ^ N(e, 2)) << 2 ^ N(e, 3) : 0 }(e, t)) { case 5103: return de + "print-" + e + e; case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921: case 5572: case 6356: case 5844: case 3191: case 6645: case 3005: case 6391: case 5879: case 5623: case 6135: case 4599: case 4855: case 4215: case 6389: case 5109: case 5365: case 5621: case 3829: return de + e + e; case 5349: case 4246: case 4810: case 6968: case 2756: return de + e + ue + e + ce + e + e; case 6828: case 4268: return de + e + ce + e + e; case 6165: return de + e + ce + "flex-" + e + e; case 5187: return de + e + D(e, /(\w+).+(:[^]+)/, de + "box-$1$2" + ce + "flex-$1$2") + e; case 5443: return de + e + ce + "flex-item-" + D(e, /flex-|-self/, "") + e; case 4675: return de + e + ce + "flex-line-pack" + D(e, /align-content|flex-|-self/, "") + e; case 5548: return de + e + ce + D(e, "shrink", "negative") + e; case 5292: return de + e + ce + D(e, "basis", "preferred-size") + e; case 6060: return de + "box-" + D(e, "-grow", "") + de + e + ce + D(e, "grow", "positive") + e; case 4554: return de + D(e, /([^-])(transform)/g, "$1" + de + "$2") + e; case 6187: return D(D(D(e, /(zoom-|grab)/, de + "$1"), /(image-set)/, de + "$1"), e, "") + e; case 5495: case 3959: return D(e, /(image-set\([^]*)/, de + "$1$`$1"); case 4968: return D(D(e, /(.+:)(flex-)?(.*)/, de + "box-pack:$3" + ce + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + de + e + e; case 4095: case 3583: case 4068: case 2532: return D(e, /(.+)-inline(.+)/, de + "$1$2") + e; case 8116: case 7059: case 5753: case 5535: case 5445: case 5701: case 4933: case 4677: case 5533: case 5789: case 5021: case 4765: if (O(e) - 1 - t > 6) switch (N(e, t + 1)) { case 109: if (45 !== N(e, t + 4)) break; case 102: return D(e, /(.+:)(.+)-([^]+)/, "$1" + de + "$2-$3$1" + ue + (108 == N(e, t + 3) ? "$3" : "$2-$3")) + e; case 115: return ~k(e, "stretch") ? Ce(D(e, "stretch", "fill-available"), t) + e : e }break; case 4949: if (115 !== N(e, t + 1)) break; case 6444: switch (N(e, O(e) - 3 - (~k(e, "!important") && 10))) { case 107: return D(e, ":", ":" + de) + e; case 101: return D(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + de + (45 === N(e, 14) ? "inline-" : "") + "box$3$1" + de + "$2$3$1" + ce + "$2box$3") + e }break; case 5936: switch (N(e, t + 11)) { case 114: return de + e + ce + D(e, /[svh]\w+-[tblr]{2}/, "tb") + e; case 108: return de + e + ce + D(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e; case 45: return de + e + ce + D(e, /[svh]\w+-[tblr]{2}/, "lr") + e }return de + e + ce + e + e }return e } var Te = [function (e, t, n, r) { if (e.length > -1 && !e.return) switch (e.type) { case fe: e.return = Ce(e.value, e.length); break; case me: return ge([Y(e, { value: D(e.value, "@", "@" + de) })], r); case pe: if (e.length) return function (e, t) { return e.map(t).join("") }(e.props, (function (t) { switch (function (e) { return (e = /(::plac\w+|:read-\w+)/.exec(e)) ? e[0] : e }(t)) { case ":read-only": case ":read-write": return ge([Y(e, { props: [D(t, /:(read-\w+)/, ":-moz-$1")] })], r); case "::placeholder": return ge([Y(e, { props: [D(t, /:(plac\w+)/, ":" + de + "input-$1")] }), Y(e, { props: [D(t, /:(plac\w+)/, ":-moz-$1")] }), Y(e, { props: [D(t, /:(plac\w+)/, ce + "input-$1")] })], r) }return "" })) } }], Re = function (e) { var t = e.key; if ("css" === t) { var n = document.querySelectorAll("style[data-emotion]:not([data-s])"); Array.prototype.forEach.call(n, (function (e) { -1 !== e.getAttribute("data-emotion").indexOf(" ") && (document.head.appendChild(e), e.setAttribute("data-s", "")) })) } var r, i, a = e.stylisPlugins || Te, o = {}, s = []; r = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + t + ' "]'), (function (e) { for (var t = e.getAttribute("data-emotion").split(" "), n = 1; n < t.length; n++)o[t[n]] = !0; s.push(e) })); var l, c, u, d, h = [ve, (d = function (e) { l.insert(e) }, function (e) { e.root || (e = e.return) && d(e) })], p = (c = [_e, Ee].concat(a, h), u = U(c), function (e, t, n, r) { for (var i = "", a = 0; a < u; a++)i += c[a](e, t, n, r) || ""; return i }); i = function (e, t, n, r) { l = n, function (e) { ge(ye(e), p) }(e ? e + "{" + t.styles + "}" : t.styles), r && (f.inserted[t.name] = !0) }; var f = { key: t, sheet: new R({ key: t, container: r, nonce: e.nonce, speedy: e.speedy, prepend: e.prepend, insertionPoint: e.insertionPoint }), nonce: e.nonce, inserted: o, registered: {}, insert: i }; return f.sheet.hydrate(s), f }, Be = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, scale: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, Ie = /[A-Z]|^ms/g, Pe = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Le = function (e) { return 45 === e.charCodeAt(1) }, De = function (e) { return null != e && "boolean" != typeof e }, ke = E((function (e) { return Le(e) ? e : e.replace(Ie, "-$&").toLowerCase() })), Ne = function (e, t) { switch (e) { case "animation": case "animationName": if ("string" == typeof t) return t.replace(Pe, (function (e, t, n) { return Oe = { name: t, styles: n, next: Oe }, t })) }return 1 === Be[e] || Le(e) || "number" != typeof t || 0 === t ? t : t + "px" }; function Fe(e, t, n) { if (null == n) return ""; var r = n; if (void 0 !== r.__emotion_styles) return r; switch (typeof n) { case "boolean": return ""; case "object": var i = n; if (1 === i.anim) return Oe = { name: i.name, styles: i.styles, next: Oe }, i.name; var a = n; if (void 0 !== a.styles) { var o = a.next; if (void 0 !== o) for (; void 0 !== o;)Oe = { name: o.name, styles: o.styles, next: Oe }, o = o.next; return a.styles + ";" } return function (e, t, n) { var r = ""; if (Array.isArray(n)) for (var i = 0; i < n.length; i++)r += Fe(e, t, n[i]) + ";"; else for (var a in n) { var o = n[a]; if ("object" != typeof o) { var s = o; null != t && void 0 !== t[s] ? r += a + "{" + t[s] + "}" : De(s) && (r += ke(a) + ":" + Ne(a, s) + ";") } else if (!Array.isArray(o) || "string" != typeof o[0] || null != t && void 0 !== t[o[0]]) { var l = Fe(e, t, o); switch (a) { case "animation": case "animationName": r += ke(a) + ":" + l + ";"; break; default: r += a + "{" + l + "}" } } else for (var c = 0; c < o.length; c++)De(o[c]) && (r += ke(a) + ":" + Ne(a, o[c]) + ";") } return r }(e, t, n); case "function": if (void 0 !== e) { var s = Oe, l = n(e); return Oe = s, Fe(e, t, l) } }var c = n; if (null == t) return c; var u = t[c]; return void 0 !== u ? u : c } var Oe, Ue = /label:\s*([^\s;{]+)\s*(;|$)/g; function ze(e, t, n) { if (1 === e.length && "object" == typeof e[0] && null !== e[0] && void 0 !== e[0].styles) return e[0]; var r = !0, i = ""; Oe = void 0; var a = e[0]; null == a || void 0 === a.raw ? (r = !1, i += Fe(n, t, a)) : i += a[0]; for (var o = 1; o < e.length; o++)i += Fe(n, t, e[o]), r && (i += a[o]); Ue.lastIndex = 0; for (var s, l = ""; null !== (s = Ue.exec(i));)l += "-" + s[1]; var c = function (e) { for (var t, n = 0, r = 0, i = e.length; i >= 4; ++r, i -= 4)t = 1540483477 * (65535 & (t = 255 & e.charCodeAt(r) | (255 & e.charCodeAt(++r)) << 8 | (255 & e.charCodeAt(++r)) << 16 | (255 & e.charCodeAt(++r)) << 24)) + (59797 * (t >>> 16) << 16), n = 1540483477 * (65535 & (t ^= t >>> 24)) + (59797 * (t >>> 16) << 16) ^ 1540483477 * (65535 & n) + (59797 * (n >>> 16) << 16); switch (i) { case 3: n ^= (255 & e.charCodeAt(r + 2)) << 16; case 2: n ^= (255 & e.charCodeAt(r + 1)) << 8; case 1: n = 1540483477 * (65535 & (n ^= 255 & e.charCodeAt(r))) + (59797 * (n >>> 16) << 16) }return (((n = 1540483477 * (65535 & (n ^= n >>> 13)) + (59797 * (n >>> 16) << 16)) ^ n >>> 15) >>> 0).toString(36) }(i) + l; return { name: c, styles: i, next: Oe } } var He = !!r.useInsertionEffect && r.useInsertionEffect, Ge = He || function (e) { return e() }, je = He || n.useLayoutEffect, Ve = n.createContext("undefined" != typeof HTMLElement ? Re({ key: "css" }) : null), We = (Ve.Provider, function (e) { return (0, n.forwardRef)((function (t, r) { var i = (0, n.useContext)(Ve); return e(t, i, r) })) }), Xe = n.createContext({}), Je = function (e, t, n) { var r = e.key + "-" + t.name; !1 === n && void 0 === e.registered[r] && (e.registered[r] = t.styles) }, Ye = function (e, t, n) { Je(e, t, n); var r = e.key + "-" + t.name; if (void 0 === e.inserted[t.name]) { var i = t; do { e.insert(t === i ? "." + r : "", i, e.sheet, !0), i = i.next } while (void 0 !== i) } }, Qe = T, Ke = function (e) { return "theme" !== e }, qe = function (e) { return "string" == typeof e && e.charCodeAt(0) > 96 ? Qe : Ke }, Ze = function (e, t, n) { var r; if (t) { var i = t.shouldForwardProp; r = e.__emotion_forwardProp && i ? function (t) { return e.__emotion_forwardProp(t) && i(t) } : i } return "function" != typeof r && n && (r = e.__emotion_forwardProp), r }, $e = function (e) { var t = e.cache, n = e.serialized, r = e.isStringTag; return Je(t, n, r), Ge((function () { return Ye(t, n, r) })), null }, et = function e(t, r) { var i, a, o = t.__emotion_real === t, s = o && t.__emotion_base || t; void 0 !== r && (i = r.label, a = r.target); var l = Ze(t, r, o), c = l || qe(s), u = !c("as"); return function () { var d = arguments, h = o && void 0 !== t.__emotion_styles ? t.__emotion_styles.slice(0) : []; if (void 0 !== i && h.push("label:" + i + ";"), null == d[0] || void 0 === d[0].raw) h.push.apply(h, d); else { h.push(d[0][0]); for (var p = d.length, f = 1; f < p; f++)h.push(d[f], d[0][f]) } var m = We((function (e, t, r) { var i, o, d, p, f = u && e.as || s, m = "", g = [], v = e; if (null == e.theme) { for (var y in v = {}, e) v[y] = e[y]; v.theme = n.useContext(Xe) } "string" == typeof e.className ? (i = t.registered, o = g, d = e.className, p = "", d.split(" ").forEach((function (e) { void 0 !== i[e] ? o.push(i[e] + ";") : e && (p += e + " ") })), m = p) : null != e.className && (m = e.className + " "); var b = ze(h.concat(g), t.registered, v); m += t.key + "-" + b.name, void 0 !== a && (m += " " + a); var x = u && void 0 === l ? qe(f) : c, A = {}; for (var S in e) u && "as" === S || x(S) && (A[S] = e[S]); return A.className = m, r && (A.ref = r), n.createElement(n.Fragment, null, n.createElement($e, { cache: t, serialized: b, isStringTag: "string" == typeof f }), n.createElement(f, A)) })); return m.displayName = void 0 !== i ? i : "Styled(" + ("string" == typeof s ? s : s.displayName || s.name || "Component") + ")", m.defaultProps = t.defaultProps, m.__emotion_real = m, m.__emotion_base = s, m.__emotion_styles = h, m.__emotion_forwardProp = l, Object.defineProperty(m, "toString", { value: function () { return "." + a } }), m.withComponent = function (t, n) { return e(t, _({}, r, n, { shouldForwardProp: Ze(m, n, !0) })).apply(void 0, h) }, m } }.bind(); function tt(e, t) { return et(e, t) } ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"].forEach((function (e) { et[e] = et(e) })); const nt = []; function rt(e) { return nt[0] = e, ze(nt) } function it(e) { if ("object" != typeof e || null === e) return !1; const t = Object.getPrototypeOf(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) } function at(e) { if (!it(e)) return e; const t = {}; return Object.keys(e).forEach((n => { t[n] = at(e[n]) })), t } function ot(e, t, n = { clone: !0 }) { const r = n.clone ? { ...e } : e; return it(e) && it(t) && Object.keys(t).forEach((i => { it(t[i]) && Object.prototype.hasOwnProperty.call(e, i) && it(e[i]) ? r[i] = ot(e[i], t[i], n) : n.clone ? r[i] = it(t[i]) ? at(t[i]) : t[i] : r[i] = t[i] })), r } function st(e) { const { values: t = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, unit: n = "px", step: r = 5, ...i } = e, a = (e => { const t = Object.keys(e).map((t => ({ key: t, val: e[t] }))) || []; return t.sort(((e, t) => e.val - t.val)), t.reduce(((e, t) => ({ ...e, [t.key]: t.val })), {}) })(t), o = Object.keys(a); function s(e) { return `@media (min-width:${"number" == typeof t[e] ? t[e] : e}${n})` } function l(e) { return `@media (max-width:${("number" == typeof t[e] ? t[e] : e) - r / 100}${n})` } function c(e, i) { const a = o.indexOf(i); return `@media (min-width:${"number" == typeof t[e] ? t[e] : e}${n}) and (max-width:${(-1 !== a && "number" == typeof t[o[a]] ? t[o[a]] : i) - r / 100}${n})` } return { keys: o, values: a, up: s, down: l, between: c, only: function (e) { return o.indexOf(e) + 1 < o.length ? c(e, o[o.indexOf(e) + 1]) : s(e) }, not: function (e) { const t = o.indexOf(e); return 0 === t ? s(o[1]) : t === o.length - 1 ? l(o[t]) : c(e, o[o.indexOf(e) + 1]).replace("@media", "@media not all and") }, unit: n, ...i } } const lt = { borderRadius: 4 }, ct = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, ut = { keys: ["xs", "sm", "md", "lg", "xl"], up: e => `@media (min-width:${ct[e]}px)` }, dt = { containerQueries: e => ({ up: t => { let n = "number" == typeof t ? t : ct[t] || t; return "number" == typeof n && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})` } }) }; function ht(e, t, n) { const r = e.theme || {}; if (Array.isArray(t)) { const e = r.breakpoints || ut; return t.reduce(((r, i, a) => (r[e.up(e.keys[a])] = n(t[a]), r)), {}) } if ("object" == typeof t) { const e = r.breakpoints || ut; return Object.keys(t).reduce(((i, a) => { if (o = e.keys, "@" === (s = a) || s.startsWith("@") && (o.some((e => s.startsWith(`@${e}`))) || s.match(/^@\d/))) { const e = function (e, t) { const n = t.match(/^@([^/]+)?\/?(.+)?$/); if (!n) return null; const [, r, i] = n, a = Number.isNaN(+r) ? r || 0 : +r; return e.containerQueries(i).up(a) }(r.containerQueries ? r : dt, a); e && (i[e] = n(t[a], a)) } else if (Object.keys(e.values || ct).includes(a)) i[e.up(a)] = n(t[a], a); else { const e = a; i[e] = t[e] } var o, s; return i }), {}) } return n(t) } function pt(e, ...t) { const n = new URL(`https://mui.com/production-error/?code=${e}`); return t.forEach((e => n.searchParams.append("args[]", e))), `Minified MUI error #${e}; visit ${n} for the full message.` } function ft(e) { if ("string" != typeof e) throw new Error(pt(7)); return e.charAt(0).toUpperCase() + e.slice(1) } function mt(e, t, n = !0) { if (!t || "string" != typeof t) return null; if (e && e.vars && n) { const n = `vars.${t}`.split(".").reduce(((e, t) => e && e[t] ? e[t] : null), e); if (null != n) return n } return t.split(".").reduce(((e, t) => e && null != e[t] ? e[t] : null), e) } function gt(e, t, n, r = n) { let i; return i = "function" == typeof e ? e(n) : Array.isArray(e) ? e[n] || r : mt(e, n) || r, t && (i = t(i, r, e)), i } const vt = function (e) { const { prop: t, cssProperty: n = e.prop, themeKey: r, transform: i } = e, a = e => { if (null == e[t]) return null; const a = e[t], o = mt(e.theme, r) || {}; return ht(e, a, (e => { let r = gt(o, i, e); return e === r && "string" == typeof e && (r = gt(o, i, `${t}${"default" === e ? "" : ft(e)}`, e)), !1 === n ? r : { [n]: r } })) }; return a.propTypes = {}, a.filterProps = [t], a }, yt = function (e, t) { return t ? ot(e, t, { clone: !1 }) : e }, bt = { m: "margin", p: "padding" }, xt = { t: "Top", r: "Right", b: "Bottom", l: "Left", x: ["Left", "Right"], y: ["Top", "Bottom"] }, At = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" }, St = function () { const e = {}; return t => (void 0 === e[t] && (e[t] = (e => { if (e.length > 2) { if (!At[e]) return [e]; e = At[e] } const [t, n] = e.split(""), r = bt[t], i = xt[n] || ""; return Array.isArray(i) ? i.map((e => r + e)) : [r + i] })(t)), e[t]) }(), Mt = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], wt = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], _t = [...Mt, ...wt]; function Et(e, t, n, r) { const i = mt(e, t, !0) ?? n; return "number" == typeof i || "string" == typeof i ? e => "string" == typeof e ? e : "string" == typeof i ? `calc(${e} * ${i})` : i * e : Array.isArray(i) ? e => { if ("string" == typeof e) return e; const t = Math.abs(e), n = i[t]; return e >= 0 ? n : "number" == typeof n ? -n : `-${n}` } : "function" == typeof i ? i : () => { } } function Ct(e) { return Et(e, "spacing", 8) } function Tt(e, t) { return "string" == typeof t || null == t ? t : e(t) } function Rt(e, t) { const n = Ct(e.theme); return Object.keys(e).map((r => function (e, t, n, r) { if (!t.includes(n)) return null; const i = function (e, t) { return n => e.reduce(((e, r) => (e[r] = Tt(t, n), e)), {}) }(St(n), r); return ht(e, e[n], i) }(e, t, r, n))).reduce(yt, {}) } function Bt(e) { return Rt(e, Mt) } function It(e) { return Rt(e, wt) } function Pt(e) { return Rt(e, _t) } function Lt(e = 8, t = Ct({ spacing: e })) { if (e.mui) return e; const n = (...e) => (0 === e.length ? [1] : e).map((e => { const n = t(e); return "number" == typeof n ? `${n}px` : n })).join(" "); return n.mui = !0, n } Bt.propTypes = {}, Bt.filterProps = Mt, It.propTypes = {}, It.filterProps = wt, Pt.propTypes = {}, Pt.filterProps = _t; const Dt = function (...e) { const t = e.reduce(((e, t) => (t.filterProps.forEach((n => { e[n] = t })), e)), {}), n = e => Object.keys(e).reduce(((n, r) => t[r] ? yt(n, t[r](e)) : n), {}); return n.propTypes = {}, n.filterProps = e.reduce(((e, t) => e.concat(t.filterProps)), []), n }; function kt(e) { return "number" != typeof e ? e : `${e}px solid` } function Nt(e, t) { return vt({ prop: e, themeKey: "borders", transform: t }) } const Ft = Nt("border", kt), Ot = Nt("borderTop", kt), Ut = Nt("borderRight", kt), zt = Nt("borderBottom", kt), Ht = Nt("borderLeft", kt), Gt = Nt("borderColor"), jt = Nt("borderTopColor"), Vt = Nt("borderRightColor"), Wt = Nt("borderBottomColor"), Xt = Nt("borderLeftColor"), Jt = Nt("outline", kt), Yt = Nt("outlineColor"), Qt = e => { if (void 0 !== e.borderRadius && null !== e.borderRadius) { const t = Et(e.theme, "shape.borderRadius", 4), n = e => ({ borderRadius: Tt(t, e) }); return ht(e, e.borderRadius, n) } return null }; Qt.propTypes = {}, Qt.filterProps = ["borderRadius"], Dt(Ft, Ot, Ut, zt, Ht, Gt, jt, Vt, Wt, Xt, Qt, Jt, Yt); const Kt = e => { if (void 0 !== e.gap && null !== e.gap) { const t = Et(e.theme, "spacing", 8), n = e => ({ gap: Tt(t, e) }); return ht(e, e.gap, n) } return null }; Kt.propTypes = {}, Kt.filterProps = ["gap"]; const qt = e => { if (void 0 !== e.columnGap && null !== e.columnGap) { const t = Et(e.theme, "spacing", 8), n = e => ({ columnGap: Tt(t, e) }); return ht(e, e.columnGap, n) } return null }; qt.propTypes = {}, qt.filterProps = ["columnGap"]; const Zt = e => { if (void 0 !== e.rowGap && null !== e.rowGap) { const t = Et(e.theme, "spacing", 8), n = e => ({ rowGap: Tt(t, e) }); return ht(e, e.rowGap, n) } return null }; function $t(e, t) { return "grey" === t ? t : e } function en(e) { return e <= 1 && 0 !== e ? 100 * e + "%" : e } Zt.propTypes = {}, Zt.filterProps = ["rowGap"], Dt(Kt, qt, Zt, vt({ prop: "gridColumn" }), vt({ prop: "gridRow" }), vt({ prop: "gridAutoFlow" }), vt({ prop: "gridAutoColumns" }), vt({ prop: "gridAutoRows" }), vt({ prop: "gridTemplateColumns" }), vt({ prop: "gridTemplateRows" }), vt({ prop: "gridTemplateAreas" }), vt({ prop: "gridArea" })), Dt(vt({ prop: "color", themeKey: "palette", transform: $t }), vt({ prop: "bgcolor", cssProperty: "backgroundColor", themeKey: "palette", transform: $t }), vt({ prop: "backgroundColor", themeKey: "palette", transform: $t })); const tn = vt({ prop: "width", transform: en }), nn = e => { if (void 0 !== e.maxWidth && null !== e.maxWidth) { const t = t => { const n = e.theme?.breakpoints?.values?.[t] || ct[t]; return n ? "px" !== e.theme?.breakpoints?.unit ? { maxWidth: `${n}${e.theme.breakpoints.unit}` } : { maxWidth: n } : { maxWidth: en(t) } }; return ht(e, e.maxWidth, t) } return null }; nn.filterProps = ["maxWidth"]; const rn = vt({ prop: "minWidth", transform: en }), an = vt({ prop: "height", transform: en }), on = vt({ prop: "maxHeight", transform: en }), sn = vt({ prop: "minHeight", transform: en }), ln = (vt({ prop: "size", cssProperty: "width", transform: en }), vt({ prop: "size", cssProperty: "height", transform: en }), Dt(tn, nn, rn, an, on, sn, vt({ prop: "boxSizing" })), { border: { themeKey: "borders", transform: kt }, borderTop: { themeKey: "borders", transform: kt }, borderRight: { themeKey: "borders", transform: kt }, borderBottom: { themeKey: "borders", transform: kt }, borderLeft: { themeKey: "borders", transform: kt }, borderColor: { themeKey: "palette" }, borderTopColor: { themeKey: "palette" }, borderRightColor: { themeKey: "palette" }, borderBottomColor: { themeKey: "palette" }, borderLeftColor: { themeKey: "palette" }, outline: { themeKey: "borders", transform: kt }, outlineColor: { themeKey: "palette" }, borderRadius: { themeKey: "shape.borderRadius", style: Qt }, color: { themeKey: "palette", transform: $t }, bgcolor: { themeKey: "palette", cssProperty: "backgroundColor", transform: $t }, backgroundColor: { themeKey: "palette", transform: $t }, p: { style: It }, pt: { style: It }, pr: { style: It }, pb: { style: It }, pl: { style: It }, px: { style: It }, py: { style: It }, padding: { style: It }, paddingTop: { style: It }, paddingRight: { style: It }, paddingBottom: { style: It }, paddingLeft: { style: It }, paddingX: { style: It }, paddingY: { style: It }, paddingInline: { style: It }, paddingInlineStart: { style: It }, paddingInlineEnd: { style: It }, paddingBlock: { style: It }, paddingBlockStart: { style: It }, paddingBlockEnd: { style: It }, m: { style: Bt }, mt: { style: Bt }, mr: { style: Bt }, mb: { style: Bt }, ml: { style: Bt }, mx: { style: Bt }, my: { style: Bt }, margin: { style: Bt }, marginTop: { style: Bt }, marginRight: { style: Bt }, marginBottom: { style: Bt }, marginLeft: { style: Bt }, marginX: { style: Bt }, marginY: { style: Bt }, marginInline: { style: Bt }, marginInlineStart: { style: Bt }, marginInlineEnd: { style: Bt }, marginBlock: { style: Bt }, marginBlockStart: { style: Bt }, marginBlockEnd: { style: Bt }, displayPrint: { cssProperty: !1, transform: e => ({ "@media print": { display: e } }) }, display: {}, overflow: {}, textOverflow: {}, visibility: {}, whiteSpace: {}, flexBasis: {}, flexDirection: {}, flexWrap: {}, justifyContent: {}, alignItems: {}, alignContent: {}, order: {}, flex: {}, flexGrow: {}, flexShrink: {}, alignSelf: {}, justifyItems: {}, justifySelf: {}, gap: { style: Kt }, rowGap: { style: Zt }, columnGap: { style: qt }, gridColumn: {}, gridRow: {}, gridAutoFlow: {}, gridAutoColumns: {}, gridAutoRows: {}, gridTemplateColumns: {}, gridTemplateRows: {}, gridTemplateAreas: {}, gridArea: {}, position: {}, zIndex: { themeKey: "zIndex" }, top: {}, right: {}, bottom: {}, left: {}, boxShadow: { themeKey: "shadows" }, width: { transform: en }, maxWidth: { style: nn }, minWidth: { transform: en }, height: { transform: en }, maxHeight: { transform: en }, minHeight: { transform: en }, boxSizing: {}, font: { themeKey: "font" }, fontFamily: { themeKey: "typography" }, fontSize: { themeKey: "typography" }, fontStyle: { themeKey: "typography" }, fontWeight: { themeKey: "typography" }, letterSpacing: {}, textTransform: {}, lineHeight: {}, textAlign: {}, typography: { cssProperty: !1, themeKey: "typography" } }), cn = function () { function e(e, t, n, r) { const i = { [e]: t, theme: n }, a = r[e]; if (!a) return { [e]: t }; const { cssProperty: o = e, themeKey: s, transform: l, style: c } = a; if (null == t) return null; if ("typography" === s && "inherit" === t) return { [e]: t }; const u = mt(n, s) || {}; return c ? c(i) : ht(i, t, (t => { let n = gt(u, l, t); return t === n && "string" == typeof t && (n = gt(u, l, `${e}${"default" === t ? "" : ft(t)}`, t)), !1 === o ? n : { [o]: n } })) } return function t(n) { const { sx: r, theme: i = {} } = n || {}; if (!r) return null; const a = i.unstable_sxConfig ?? ln; function o(n) { let r = n; if ("function" == typeof n) r = n(i); else if ("object" != typeof n) return n; if (!r) return null; const o = function (e = {}) { const t = e.keys?.reduce(((t, n) => (t[e.up(n)] = {}, t)), {}); return t || {} }(i.breakpoints), s = Object.keys(o); let l = o; return Object.keys(r).forEach((n => { const o = function (e, t) { return "function" == typeof e ? e(t) : e }(r[n], i); if (null != o) if ("object" == typeof o) if (a[n]) l = yt(l, e(n, o, i, a)); else { const e = ht({ theme: i }, o, (e => ({ [n]: e }))); !function (...e) { const t = e.reduce(((e, t) => e.concat(Object.keys(t))), []), n = new Set(t); return e.every((e => n.size === Object.keys(e).length)) }(e, o) ? l = yt(l, e) : l[n] = t({ sx: o, theme: i }) } else l = yt(l, e(n, o, i, a)) })), function (e, t) { if (!e.containerQueries) return t; const n = Object.keys(t).filter((e => e.startsWith("@container"))).sort(((e, t) => { const n = /min-width:\s*([0-9.]+)/; return +(e.match(n)?.[1] || 0) - +(t.match(n)?.[1] || 0) })); return n.length ? n.reduce(((e, n) => { const r = t[n]; return delete e[n], e[n] = r, e }), { ...t }) : t }(i, (c = l, s.reduce(((e, t) => { const n = e[t]; return (!n || 0 === Object.keys(n).length) && delete e[t], e }), c))); var c } return Array.isArray(r) ? r.map(o) : o(r) } }(); cn.filterProps = ["sx"]; const un = cn; function dn(e, t) { const n = this; if (n.vars) { if (!n.colorSchemes?.[e] || "function" != typeof n.getColorSchemeSelector) return {}; let r = n.getColorSchemeSelector(e); return "&" === r ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), { [r]: t }) } return n.palette.mode === e ? t : {} } const hn = function (e = {}, ...t) { const { breakpoints: n = {}, palette: r = {}, spacing: i, shape: a = {}, ...o } = e; let s = ot({ breakpoints: st(n), direction: "ltr", components: {}, palette: { mode: "light", ...r }, spacing: Lt(i), shape: { ...lt, ...a } }, o); return s = function (e) { const t = (e, t) => e.replace("@media", t ? `@container ${t}` : "@container"); function n(n, r) { n.up = (...n) => t(e.breakpoints.up(...n), r), n.down = (...n) => t(e.breakpoints.down(...n), r), n.between = (...n) => t(e.breakpoints.between(...n), r), n.only = (...n) => t(e.breakpoints.only(...n), r), n.not = (...n) => { const i = t(e.breakpoints.not(...n), r); return i.includes("not all and") ? i.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : i } } const r = {}, i = e => (n(r, e), r); return n(i), { ...e, containerQueries: i } }(s), s.applyStyles = dn, s = t.reduce(((e, t) => ot(e, t)), s), s.unstable_sxConfig = { ...ln, ...o?.unstable_sxConfig }, s.unstable_sx = function (e) { return un({ sx: e, theme: this }) }, s }; function pn(e) { const { variants: t, ...n } = e, r = { variants: t, style: rt(n), isProcessed: !0 }; return r.style === n || t && t.forEach((e => { "function" != typeof e.style && (e.style = rt(e.style)) })), r } const fn = hn(); function mn(e) { return "ownerState" !== e && "theme" !== e && "sx" !== e && "as" !== e } function gn(e) { return e ? (t, n) => n[e] : null } function vn(e, t) { const n = "function" == typeof t ? t(e) : t; if (Array.isArray(n)) return n.flatMap((t => vn(e, t))); if (Array.isArray(n?.variants)) { let t; if (n.isProcessed) t = n.style; else { const { variants: e, ...r } = n; t = r } return yn(e, n.variants, [t]) } return n?.isProcessed ? n.style : n } function yn(e, t, n = []) { let r; e: for (let i = 0; i < t.length; i += 1) { const a = t[i]; if ("function" == typeof a.props) { if (r ??= { ...e, ...e.ownerState, ownerState: e.ownerState }, !a.props(r)) continue } else for (const t in a.props) if (e[t] !== a.props[t] && e.ownerState?.[t] !== a.props[t]) continue e; "function" == typeof a.style ? (r ??= { ...e, ...e.ownerState, ownerState: e.ownerState }, n.push(a.style(r))) : n.push(a.style) } return n } function bn(e) { return e ? e.charAt(0).toLowerCase() + e.slice(1) : e } function xn(e, t = 0, n = 1) { return function (e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) { return Math.max(t, Math.min(e, n)) }(e, t, n) } function An(e) { if (e.type) return e; if ("#" === e.charAt(0)) return An(function (e) { e = e.slice(1); const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g"); let n = e.match(t); return n && 1 === n[0].length && (n = n.map((e => e + e))), n ? `rgb${4 === n.length ? "a" : ""}(${n.map(((e, t) => t < 3 ? parseInt(e, 16) : Math.round(parseInt(e, 16) / 255 * 1e3) / 1e3)).join(", ")})` : "" }(e)); const t = e.indexOf("("), n = e.substring(0, t); if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n)) throw new Error(pt(9, e)); let r, i = e.substring(t + 1, e.length - 1); if ("color" === n) { if (i = i.split(" "), r = i.shift(), 4 === i.length && "/" === i[3].charAt(0) && (i[3] = i[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(r)) throw new Error(pt(10, r)) } else i = i.split(","); return i = i.map((e => parseFloat(e))), { type: n, values: i, colorSpace: r } } const Sn = (e, t) => { try { return (e => { const t = An(e); return t.values.slice(0, 3).map(((e, n) => t.type.includes("hsl") && 0 !== n ? `${e}%` : e)).join(" ") })(e) } catch (t) { return e } }; function Mn(e) { const { type: t, colorSpace: n } = e; let { values: r } = e; return t.includes("rgb") ? r = r.map(((e, t) => t < 3 ? parseInt(e, 10) : e)) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), r = t.includes("color") ? `${n} ${r.join(" ")}` : `${r.join(", ")}`, `${t}(${r})` } function wn(e) { e = An(e); const { values: t } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, a = r * Math.min(i, 1 - i), o = (e, t = (e + n / 30) % 12) => i - a * Math.max(Math.min(t - 3, 9 - t, 1), -1); let s = "rgb"; const l = [Math.round(255 * o(0)), Math.round(255 * o(8)), Math.round(255 * o(4))]; return "hsla" === e.type && (s += "a", l.push(t[3])), Mn({ type: s, values: l }) } function _n(e) { let t = "hsl" === (e = An(e)).type || "hsla" === e.type ? An(wn(e)).values : e.values; return t = t.map((t => ("color" !== e.type && (t /= 255), t <= .03928 ? t / 12.92 : ((t + .055) / 1.055) ** 2.4))), Number((.2126 * t[0] + .7152 * t[1] + .0722 * t[2]).toFixed(3)) } function En(e, t) { return e = An(e), t = xn(t), "rgb" !== e.type && "hsl" !== e.type || (e.type += "a"), "color" === e.type ? e.values[3] = `/${t}` : e.values[3] = t, Mn(e) } function Cn(e, t, n) { try { return En(e, t) } catch (t) { return e } } function Tn(e, t) { if (e = An(e), t = xn(t), e.type.includes("hsl")) e.values[2] *= 1 - t; else if (e.type.includes("rgb") || e.type.includes("color")) for (let n = 0; n < 3; n += 1)e.values[n] *= 1 - t; return Mn(e) } function Rn(e, t, n) { try { return Tn(e, t) } catch (t) { return e } } function Bn(e, t) { if (e = An(e), t = xn(t), e.type.includes("hsl")) e.values[2] += (100 - e.values[2]) * t; else if (e.type.includes("rgb")) for (let n = 0; n < 3; n += 1)e.values[n] += (255 - e.values[n]) * t; else if (e.type.includes("color")) for (let n = 0; n < 3; n += 1)e.values[n] += (1 - e.values[n]) * t; return Mn(e) } function In(e, t, n) { try { return Bn(e, t) } catch (t) { return e } } function Pn(e, t, n) { try { return function (e, t = .15) { return _n(e) > .5 ? Tn(e, t) : Bn(e, t) }(e, t) } catch (t) { return e } } const Ln = { black: "#000", white: "#fff" }, Dn = { 50: "#fafafa", 100: "#f5f5f5", 200: "#eeeeee", 300: "#e0e0e0", 400: "#bdbdbd", 500: "#9e9e9e", 600: "#757575", 700: "#616161", 800: "#424242", 900: "#212121", A100: "#f5f5f5", A200: "#eeeeee", A400: "#bdbdbd", A700: "#616161" }, kn = "#f3e5f5", Nn = "#ce93d8", Fn = "#ba68c8", On = "#ab47bc", Un = "#9c27b0", zn = "#7b1fa2", Hn = "#e57373", Gn = "#ef5350", jn = "#f44336", Vn = "#d32f2f", Wn = "#c62828", Xn = "#ffb74d", Jn = "#ffa726", Yn = "#ff9800", Qn = "#f57c00", Kn = "#e65100", qn = "#e3f2fd", Zn = "#90caf9", $n = "#42a5f5", er = "#1976d2", tr = "#1565c0", nr = "#4fc3f7", rr = "#29b6f6", ir = "#03a9f4", ar = "#0288d1", or = "#01579b", sr = "#81c784", lr = "#66bb6a", cr = "#4caf50", ur = "#388e3c", dr = "#2e7d32", hr = "#1b5e20"; function pr() { return { text: { primary: "rgba(0, 0, 0, 0.87)", secondary: "rgba(0, 0, 0, 0.6)", disabled: "rgba(0, 0, 0, 0.38)" }, divider: "rgba(0, 0, 0, 0.12)", background: { paper: Ln.white, default: Ln.white }, action: { active: "rgba(0, 0, 0, 0.54)", hover: "rgba(0, 0, 0, 0.04)", hoverOpacity: .04, selected: "rgba(0, 0, 0, 0.08)", selectedOpacity: .08, disabled: "rgba(0, 0, 0, 0.26)", disabledBackground: "rgba(0, 0, 0, 0.12)", disabledOpacity: .38, focus: "rgba(0, 0, 0, 0.12)", focusOpacity: .12, activatedOpacity: .12 } } } const fr = pr(); function mr() { return { text: { primary: Ln.white, secondary: "rgba(255, 255, 255, 0.7)", disabled: "rgba(255, 255, 255, 0.5)", icon: "rgba(255, 255, 255, 0.5)" }, divider: "rgba(255, 255, 255, 0.12)", background: { paper: "#121212", default: "#121212" }, action: { active: Ln.white, hover: "rgba(255, 255, 255, 0.08)", hoverOpacity: .08, selected: "rgba(255, 255, 255, 0.16)", selectedOpacity: .16, disabled: "rgba(255, 255, 255, 0.3)", disabledBackground: "rgba(255, 255, 255, 0.12)", disabledOpacity: .38, focus: "rgba(255, 255, 255, 0.12)", focusOpacity: .12, activatedOpacity: .24 } } } const gr = mr(); function vr(e, t, n, r) { const i = r.light || r, a = r.dark || 1.5 * r; e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : "light" === t ? e.light = Bn(e.main, i) : "dark" === t && (e.dark = Tn(e.main, a))) } function yr(e) { const { mode: t = "light", contrastThreshold: n = 3, tonalOffset: r = .2, ...i } = e, a = e.primary || function (e = "light") { return "dark" === e ? { main: Zn, light: qn, dark: $n } : { main: er, light: $n, dark: tr } }(t), o = e.secondary || function (e = "light") { return "dark" === e ? { main: Nn, light: kn, dark: On } : { main: Un, light: Fn, dark: zn } }(t), s = e.error || function (e = "light") { return "dark" === e ? { main: jn, light: Hn, dark: Vn } : { main: Vn, light: Gn, dark: Wn } }(t), l = e.info || function (e = "light") { return "dark" === e ? { main: rr, light: nr, dark: ar } : { main: ar, light: ir, dark: or } }(t), c = e.success || function (e = "light") { return "dark" === e ? { main: lr, light: sr, dark: ur } : { main: dr, light: cr, dark: hr } }(t), u = e.warning || function (e = "light") { return "dark" === e ? { main: Jn, light: Xn, dark: Qn } : { main: "#ed6c02", light: Yn, dark: Kn } }(t); function d(e) { const t = function (e, t) { const n = _n(e), r = _n(t); return (Math.max(n, r) + .05) / (Math.min(n, r) + .05) }(e, gr.text.primary) >= n ? gr.text.primary : fr.text.primary; return t } const h = ({ color: e, name: t, mainShade: n = 500, lightShade: i = 300, darkShade: a = 700 }) => { if (!(e = { ...e }).main && e[n] && (e.main = e[n]), !e.hasOwnProperty("main")) throw new Error(pt(11, t ? ` (${t})` : "", n)); if ("string" != typeof e.main) throw new Error(pt(12, t ? ` (${t})` : "", JSON.stringify(e.main))); return vr(e, "light", i, r), vr(e, "dark", a, r), e.contrastText || (e.contrastText = d(e.main)), e }; let p; return "light" === t ? p = pr() : "dark" === t && (p = mr()), ot({ common: { ...Ln }, mode: t, primary: h({ color: a, name: "primary" }), secondary: h({ color: o, name: "secondary", mainShade: "A400", lightShade: "A200", darkShade: "A700" }), error: h({ color: s, name: "error" }), warning: h({ color: u, name: "warning" }), info: h({ color: l, name: "info" }), success: h({ color: c, name: "success" }), grey: Dn, contrastThreshold: n, getContrastText: d, augmentColor: h, tonalOffset: r, ...p }, i) } function br(e = "") { function t(...n) { if (!n.length) return ""; const r = n[0]; return "string" != typeof r || r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, ${r}` : `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})` } return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})` } function xr(e) { const t = {}; return Object.entries(e).forEach((e => { const [n, r] = e; "object" == typeof r && (t[n] = `${r.fontStyle ? `${r.fontStyle} ` : ""}${r.fontVariant ? `${r.fontVariant} ` : ""}${r.fontWeight ? `${r.fontWeight} ` : ""}${r.fontStretch ? `${r.fontStretch} ` : ""}${r.fontSize || ""}${r.lineHeight ? `/${r.lineHeight} ` : ""}${r.fontFamily || ""}`) })), t } const Ar = (e, t, n, r = []) => { let i = e; t.forEach(((e, a) => { a === t.length - 1 ? Array.isArray(i) ? i[Number(e)] = n : i && "object" == typeof i && (i[e] = n) : i && "object" == typeof i && (i[e] || (i[e] = r.includes(e) ? [] : {}), i = i[e]) })) }; function Sr(e, t) { const { prefix: n, shouldSkipGeneratingVar: r } = t || {}, i = {}, a = {}, o = {}; var s, l; return s = (e, t, s) => { if (!("string" != typeof t && "number" != typeof t || r && r(e, t))) { const r = `--${n ? `${n}-` : ""}${e.join("-")}`, l = ((e, t) => "number" == typeof t ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((t => e.includes(t))) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t)(e, t); Object.assign(i, { [r]: l }), Ar(a, e, `var(${r})`, s), Ar(o, e, `var(${r}, ${l})`, s) } }, l = e => "vars" === e[0], function e(t, n = [], r = []) { Object.entries(t).forEach((([t, i]) => { (!l || l && !l([...n, t])) && null != i && ("object" == typeof i && Object.keys(i).length > 0 ? e(i, [...n, t], Array.isArray(i) ? [...r, t] : r) : s([...n, t], i, r)) })) }(e), { css: i, vars: a, varsWithDefaults: o } } const Mr = { textTransform: "uppercase" }, wr = '"Roboto", "Helvetica", "Arial", sans-serif'; function _r(e, t) { const { fontFamily: n = wr, fontSize: r = 14, fontWeightLight: i = 300, fontWeightRegular: a = 400, fontWeightMedium: o = 500, fontWeightBold: s = 700, htmlFontSize: l = 16, allVariants: c, pxToRem: u, ...d } = "function" == typeof t ? t(e) : t, h = r / 14, p = u || (e => e / l * h + "rem"), f = (e, t, r, i, a) => { return { fontFamily: n, fontWeight: e, fontSize: p(t), lineHeight: r, ...n === wr ? { letterSpacing: (o = i / t, Math.round(1e5 * o) / 1e5 + "em") } : {}, ...a, ...c }; var o }, m = { h1: f(i, 96, 1.167, -1.5), h2: f(i, 60, 1.2, -.5), h3: f(a, 48, 1.167, 0), h4: f(a, 34, 1.235, .25), h5: f(a, 24, 1.334, 0), h6: f(o, 20, 1.6, .15), subtitle1: f(a, 16, 1.75, .15), subtitle2: f(o, 14, 1.57, .1), body1: f(a, 16, 1.5, .15), body2: f(a, 14, 1.43, .15), button: f(o, 14, 1.75, .4, Mr), caption: f(a, 12, 1.66, .4), overline: f(a, 12, 2.66, 1, Mr), inherit: { fontFamily: "inherit", fontWeight: "inherit", fontSize: "inherit", lineHeight: "inherit", letterSpacing: "inherit" } }; return ot({ htmlFontSize: l, pxToRem: p, fontFamily: n, fontSize: r, fontWeightLight: i, fontWeightRegular: a, fontWeightMedium: o, fontWeightBold: s, ...m }, d, { clone: !1 }) } function Er(...e) { return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,0.2)`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,0.14)`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,0.12)`].join(",") } const Cr = ["none", Er(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Er(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Er(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Er(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Er(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Er(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Er(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Er(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Er(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Er(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Er(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Er(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Er(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Er(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Er(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Er(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Er(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Er(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Er(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Er(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Er(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Er(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Er(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Er(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], Tr = { easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)", easeOut: "cubic-bezier(0.0, 0, 0.2, 1)", easeIn: "cubic-bezier(0.4, 0, 1, 1)", sharp: "cubic-bezier(0.4, 0, 0.6, 1)" }, Rr = { shortest: 150, shorter: 200, short: 250, standard: 300, complex: 375, enteringScreen: 225, leavingScreen: 195 }; function Br(e) { return `${Math.round(e)}ms` } function Ir(e) { if (!e) return 0; const t = e / 36; return Math.min(Math.round(10 * (4 + 15 * t ** .25 + t / 5)), 3e3) } function Pr(e) { const t = { ...Tr, ...e.easing }, n = { ...Rr, ...e.duration }; return { getAutoHeightDuration: Ir, create: (e = ["all"], r = {}) => { const { duration: i = n.standard, easing: a = t.easeInOut, delay: o = 0, ...s } = r; return (Array.isArray(e) ? e : [e]).map((e => `${e} ${"string" == typeof i ? i : Br(i)} ${a} ${"string" == typeof o ? o : Br(o)}`)).join(",") }, ...e, easing: t, duration: n } } const Lr = { mobileStepper: 1e3, fab: 1050, speedDial: 1050, appBar: 1100, drawer: 1200, modal: 1300, snackbar: 1400, tooltip: 1500 }; const Dr = function (e = {}, ...t) { const { breakpoints: n, mixins: r = {}, spacing: i, palette: a = {}, transitions: o = {}, typography: s = {}, shape: l, ...c } = e; if (e.vars) throw new Error(pt(20)); const u = yr(a), d = hn(e); let h = ot(d, { mixins: (p = d.breakpoints, f = r, { toolbar: { minHeight: 56, [p.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } }, [p.up("sm")]: { minHeight: 64 } }, ...f }), palette: u, shadows: Cr.slice(), typography: _r(u, s), transitions: Pr(o), zIndex: { ...Lr } }); var p, f; return h = ot(h, c), h = t.reduce(((e, t) => ot(e, t)), h), h.unstable_sxConfig = { ...ln, ...c?.unstable_sxConfig }, h.unstable_sx = function (e) { return un({ sx: e, theme: this }) }, h }; function kr(e) { let t; return t = e < 1 ? 5.11916 * e ** 2 : 4.5 * Math.log(e + 1) + 2, Math.round(10 * t) / 1e3 } const Nr = [...Array(25)].map(((e, t) => { if (0 === t) return "none"; const n = kr(t); return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))` })); function Fr(e) { return { inputPlaceholder: "dark" === e ? .5 : .42, inputUnderline: "dark" === e ? .7 : .42, switchTrackDisabled: "dark" === e ? .2 : .12, switchTrack: "dark" === e ? .3 : .38 } } function Or(e) { return "dark" === e ? Nr : [] } function Ur(e) { return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || "palette" === e[0] && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/) } const zr = e => (t, n) => { const r = e.rootSelector || ":root", i = e.colorSchemeSelector; let a = i; if ("class" === i && (a = ".%s"), "data" === i && (a = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (a = `[${i}="%s"]`), e.defaultColorScheme === t) { if ("dark" === t) { const i = {}; return (o = e.cssVarPrefix, [...[...Array(25)].map(((e, t) => `--${o ? `${o}-` : ""}overlays-${t}`)), `--${o ? `${o}-` : ""}palette-AppBar-darkBg`, `--${o ? `${o}-` : ""}palette-AppBar-darkColor`]).forEach((e => { i[e] = n[e], delete n[e] })), "media" === a ? { [r]: n, "@media (prefers-color-scheme: dark)": { [r]: i } } : a ? { [a.replace("%s", t)]: i, [`${r}, ${a.replace("%s", t)}`]: n } : { [r]: { ...n, ...i } } } if (a && "media" !== a) return `${r}, ${a.replace("%s", String(t))}` } else if (t) { if ("media" === a) return { [`@media (prefers-color-scheme: ${String(t)})`]: { [r]: n } }; if (a) return a.replace("%s", String(t)) } var o; return r }; function Hr(e = {}) { const t = { ...e }; return function e(t) { const n = Object.entries(t); for (let i = 0; i < n.length; i++) { const [a, o] = n[i]; !it(r = o) && void 0 !== r && "string" != typeof r && "boolean" != typeof r && "number" != typeof r && !Array.isArray(r) || a.startsWith("unstable_") ? delete t[a] : it(o) && (t[a] = { ...o }, e(t[a])) } var r }(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';\n\nconst theme = ${JSON.stringify(t, null, 2)};\n\ntheme.breakpoints = createBreakpoints(theme.breakpoints || {});\ntheme.transitions = createTransitions(theme.transitions || {});\n\nexport default theme;` } function Gr(e, t, n) { !e[t] && n && (e[t] = n) } function jr(e) { return e && e.startsWith("hsl") ? wn(e) : e } function Vr(e, t) { `${t}Channel` in e || (e[`${t}Channel`] = Sn(jr(e[t]))) } const Wr = e => { try { return e() } catch (e) { } }; function Xr(e, t, n, r) { if (!t) return; t = !0 === t ? {} : t; const i = "dark" === r ? "dark" : "light"; if (!n) return void (e[r] = function (e) { const { palette: t = { mode: "light" }, opacity: n, overlays: r, ...i } = e, a = yr(t); return { palette: a, opacity: { ...Fr(a.mode), ...n }, overlays: r || Or(a.mode), ...i } }({ ...t, palette: { mode: i, ...t?.palette } })); const { palette: a, ...o } = Dr({ ...n, palette: { mode: i, ...t?.palette } }); return e[r] = { ...t, palette: a, opacity: { ...Fr(i), ...t?.opacity }, overlays: t?.overlays || Or(i) }, o } function Jr(e = {}, ...t) { const { colorSchemes: n = { light: !0 }, defaultColorScheme: r, disableCssColorScheme: i = !1, cssVarPrefix: a = "mui", shouldSkipGeneratingVar: o = Ur, colorSchemeSelector: s = (n.light && n.dark ? "media" : void 0), rootSelector: l = ":root", ...c } = e, u = Object.keys(n)[0], d = r || (n.light && "light" !== u ? "light" : u), h = ((e = "mui") => br(e))(a), { [d]: p, light: f, dark: m, ...g } = n, v = { ...g }; let y = p; if (("dark" === d && !("dark" in n) || "light" === d && !("light" in n)) && (y = !0), !y) throw new Error(pt(21, d)); const b = Xr(v, y, c, d); f && !v.light && Xr(v, f, void 0, "light"), m && !v.dark && Xr(v, m, void 0, "dark"); let x = { defaultColorScheme: d, ...b, cssVarPrefix: a, colorSchemeSelector: s, rootSelector: l, getCssVar: h, colorSchemes: v, font: { ...xr(b.typography), ...b.font }, spacing: (A = c.spacing, "number" == typeof A ? `${A}px` : "string" == typeof A || "function" == typeof A || Array.isArray(A) ? A : "8px") }; var A; Object.keys(x.colorSchemes).forEach((e => { const t = x.colorSchemes[e].palette, n = e => { const n = e.split("-"), r = n[1], i = n[2]; return h(e, t[r][i]) }; if ("light" === t.mode && (Gr(t.common, "background", "#fff"), Gr(t.common, "onBackground", "#000")), "dark" === t.mode && (Gr(t.common, "background", "#000"), Gr(t.common, "onBackground", "#fff")), r = t, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"].forEach((e => { r[e] || (r[e] = {}) })), "light" === t.mode) { Gr(t.Alert, "errorColor", Rn(t.error.light, .6)), Gr(t.Alert, "infoColor", Rn(t.info.light, .6)), Gr(t.Alert, "successColor", Rn(t.success.light, .6)), Gr(t.Alert, "warningColor", Rn(t.warning.light, .6)), Gr(t.Alert, "errorFilledBg", n("palette-error-main")), Gr(t.Alert, "infoFilledBg", n("palette-info-main")), Gr(t.Alert, "successFilledBg", n("palette-success-main")), Gr(t.Alert, "warningFilledBg", n("palette-warning-main")), Gr(t.Alert, "errorFilledColor", Wr((() => t.getContrastText(t.error.main)))), Gr(t.Alert, "infoFilledColor", Wr((() => t.getContrastText(t.info.main)))), Gr(t.Alert, "successFilledColor", Wr((() => t.getContrastText(t.success.main)))), Gr(t.Alert, "warningFilledColor", Wr((() => t.getContrastText(t.warning.main)))), Gr(t.Alert, "errorStandardBg", In(t.error.light, .9)), Gr(t.Alert, "infoStandardBg", In(t.info.light, .9)), Gr(t.Alert, "successStandardBg", In(t.success.light, .9)), Gr(t.Alert, "warningStandardBg", In(t.warning.light, .9)), Gr(t.Alert, "errorIconColor", n("palette-error-main")), Gr(t.Alert, "infoIconColor", n("palette-info-main")), Gr(t.Alert, "successIconColor", n("palette-success-main")), Gr(t.Alert, "warningIconColor", n("palette-warning-main")), Gr(t.AppBar, "defaultBg", n("palette-grey-100")), Gr(t.Avatar, "defaultBg", n("palette-grey-400")), Gr(t.Button, "inheritContainedBg", n("palette-grey-300")), Gr(t.Button, "inheritContainedHoverBg", n("palette-grey-A100")), Gr(t.Chip, "defaultBorder", n("palette-grey-400")), Gr(t.Chip, "defaultAvatarColor", n("palette-grey-700")), Gr(t.Chip, "defaultIconColor", n("palette-grey-700")), Gr(t.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Gr(t.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Gr(t.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Gr(t.LinearProgress, "primaryBg", In(t.primary.main, .62)), Gr(t.LinearProgress, "secondaryBg", In(t.secondary.main, .62)), Gr(t.LinearProgress, "errorBg", In(t.error.main, .62)), Gr(t.LinearProgress, "infoBg", In(t.info.main, .62)), Gr(t.LinearProgress, "successBg", In(t.success.main, .62)), Gr(t.LinearProgress, "warningBg", In(t.warning.main, .62)), Gr(t.Skeleton, "bg", `rgba(${n("palette-text-primaryChannel")} / 0.11)`), Gr(t.Slider, "primaryTrack", In(t.primary.main, .62)), Gr(t.Slider, "secondaryTrack", In(t.secondary.main, .62)), Gr(t.Slider, "errorTrack", In(t.error.main, .62)), Gr(t.Slider, "infoTrack", In(t.info.main, .62)), Gr(t.Slider, "successTrack", In(t.success.main, .62)), Gr(t.Slider, "warningTrack", In(t.warning.main, .62)); const e = Pn(t.background.default, .8); Gr(t.SnackbarContent, "bg", e), Gr(t.SnackbarContent, "color", Wr((() => t.getContrastText(e)))), Gr(t.SpeedDialAction, "fabHoverBg", Pn(t.background.paper, .15)), Gr(t.StepConnector, "border", n("palette-grey-400")), Gr(t.StepContent, "border", n("palette-grey-400")), Gr(t.Switch, "defaultColor", n("palette-common-white")), Gr(t.Switch, "defaultDisabledColor", n("palette-grey-100")), Gr(t.Switch, "primaryDisabledColor", In(t.primary.main, .62)), Gr(t.Switch, "secondaryDisabledColor", In(t.secondary.main, .62)), Gr(t.Switch, "errorDisabledColor", In(t.error.main, .62)), Gr(t.Switch, "infoDisabledColor", In(t.info.main, .62)), Gr(t.Switch, "successDisabledColor", In(t.success.main, .62)), Gr(t.Switch, "warningDisabledColor", In(t.warning.main, .62)), Gr(t.TableCell, "border", In(Cn(t.divider, 1), .88)), Gr(t.Tooltip, "bg", Cn(t.grey[700], .92)) } var r; if ("dark" === t.mode) { Gr(t.Alert, "errorColor", In(t.error.light, .6)), Gr(t.Alert, "infoColor", In(t.info.light, .6)), Gr(t.Alert, "successColor", In(t.success.light, .6)), Gr(t.Alert, "warningColor", In(t.warning.light, .6)), Gr(t.Alert, "errorFilledBg", n("palette-error-dark")), Gr(t.Alert, "infoFilledBg", n("palette-info-dark")), Gr(t.Alert, "successFilledBg", n("palette-success-dark")), Gr(t.Alert, "warningFilledBg", n("palette-warning-dark")), Gr(t.Alert, "errorFilledColor", Wr((() => t.getContrastText(t.error.dark)))), Gr(t.Alert, "infoFilledColor", Wr((() => t.getContrastText(t.info.dark)))), Gr(t.Alert, "successFilledColor", Wr((() => t.getContrastText(t.success.dark)))), Gr(t.Alert, "warningFilledColor", Wr((() => t.getContrastText(t.warning.dark)))), Gr(t.Alert, "errorStandardBg", Rn(t.error.light, .9)), Gr(t.Alert, "infoStandardBg", Rn(t.info.light, .9)), Gr(t.Alert, "successStandardBg", Rn(t.success.light, .9)), Gr(t.Alert, "warningStandardBg", Rn(t.warning.light, .9)), Gr(t.Alert, "errorIconColor", n("palette-error-main")), Gr(t.Alert, "infoIconColor", n("palette-info-main")), Gr(t.Alert, "successIconColor", n("palette-success-main")), Gr(t.Alert, "warningIconColor", n("palette-warning-main")), Gr(t.AppBar, "defaultBg", n("palette-grey-900")), Gr(t.AppBar, "darkBg", n("palette-background-paper")), Gr(t.AppBar, "darkColor", n("palette-text-primary")), Gr(t.Avatar, "defaultBg", n("palette-grey-600")), Gr(t.Button, "inheritContainedBg", n("palette-grey-800")), Gr(t.Button, "inheritContainedHoverBg", n("palette-grey-700")), Gr(t.Chip, "defaultBorder", n("palette-grey-700")), Gr(t.Chip, "defaultAvatarColor", n("palette-grey-300")), Gr(t.Chip, "defaultIconColor", n("palette-grey-300")), Gr(t.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Gr(t.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Gr(t.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Gr(t.LinearProgress, "primaryBg", Rn(t.primary.main, .5)), Gr(t.LinearProgress, "secondaryBg", Rn(t.secondary.main, .5)), Gr(t.LinearProgress, "errorBg", Rn(t.error.main, .5)), Gr(t.LinearProgress, "infoBg", Rn(t.info.main, .5)), Gr(t.LinearProgress, "successBg", Rn(t.success.main, .5)), Gr(t.LinearProgress, "warningBg", Rn(t.warning.main, .5)), Gr(t.Skeleton, "bg", `rgba(${n("palette-text-primaryChannel")} / 0.13)`), Gr(t.Slider, "primaryTrack", Rn(t.primary.main, .5)), Gr(t.Slider, "secondaryTrack", Rn(t.secondary.main, .5)), Gr(t.Slider, "errorTrack", Rn(t.error.main, .5)), Gr(t.Slider, "infoTrack", Rn(t.info.main, .5)), Gr(t.Slider, "successTrack", Rn(t.success.main, .5)), Gr(t.Slider, "warningTrack", Rn(t.warning.main, .5)); const e = Pn(t.background.default, .98); Gr(t.SnackbarContent, "bg", e), Gr(t.SnackbarContent, "color", Wr((() => t.getContrastText(e)))), Gr(t.SpeedDialAction, "fabHoverBg", Pn(t.background.paper, .15)), Gr(t.StepConnector, "border", n("palette-grey-600")), Gr(t.StepContent, "border", n("palette-grey-600")), Gr(t.Switch, "defaultColor", n("palette-grey-300")), Gr(t.Switch, "defaultDisabledColor", n("palette-grey-600")), Gr(t.Switch, "primaryDisabledColor", Rn(t.primary.main, .55)), Gr(t.Switch, "secondaryDisabledColor", Rn(t.secondary.main, .55)), Gr(t.Switch, "errorDisabledColor", Rn(t.error.main, .55)), Gr(t.Switch, "infoDisabledColor", Rn(t.info.main, .55)), Gr(t.Switch, "successDisabledColor", Rn(t.success.main, .55)), Gr(t.Switch, "warningDisabledColor", Rn(t.warning.main, .55)), Gr(t.TableCell, "border", Rn(Cn(t.divider, 1), .68)), Gr(t.Tooltip, "bg", Cn(t.grey[700], .92)) } Vr(t.background, "default"), Vr(t.background, "paper"), Vr(t.common, "background"), Vr(t.common, "onBackground"), Vr(t, "divider"), Object.keys(t).forEach((e => { const n = t[e]; n && "object" == typeof n && (n.main && Gr(t[e], "mainChannel", Sn(jr(n.main))), n.light && Gr(t[e], "lightChannel", Sn(jr(n.light))), n.dark && Gr(t[e], "darkChannel", Sn(jr(n.dark))), n.contrastText && Gr(t[e], "contrastTextChannel", Sn(jr(n.contrastText))), "text" === e && (Vr(t[e], "primary"), Vr(t[e], "secondary")), "action" === e && (n.active && Vr(t[e], "active"), n.selected && Vr(t[e], "selected"))) })) })), x = t.reduce(((e, t) => ot(e, t)), x); const S = { prefix: a, disableCssColorScheme: i, shouldSkipGeneratingVar: o, getSelector: zr(x) }, { vars: M, generateThemeVars: w, generateStyleSheets: _ } = function (e, t = {}) { const { getSelector: n = g, disableCssColorScheme: r, colorSchemeSelector: i } = t, { colorSchemes: a = {}, components: o, defaultColorScheme: s = "light", ...l } = e, { vars: c, css: u, varsWithDefaults: d } = Sr(l, t); let h = d; const p = {}, { [s]: f, ...m } = a; if (Object.entries(m || {}).forEach((([e, n]) => { const { vars: r, css: i, varsWithDefaults: a } = Sr(n, t); h = ot(h, a), p[e] = { css: i, vars: r } })), f) { const { css: e, vars: n, varsWithDefaults: r } = Sr(f, t); h = ot(h, r), p[s] = { css: e, vars: n } } function g(t, n) { let r = i; if ("class" === i && (r = ".%s"), "data" === i && (r = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (r = `[${i}="%s"]`), t) { if ("media" === r) { if (e.defaultColorScheme === t) return ":root"; const r = a[t]?.palette?.mode || t; return { [`@media (prefers-color-scheme: ${r})`]: { ":root": n } } } if (r) return e.defaultColorScheme === t ? `:root, ${r.replace("%s", String(t))}` : r.replace("%s", String(t)) } return ":root" } return { vars: h, generateThemeVars: () => { let e = { ...c }; return Object.entries(p).forEach((([, { vars: t }]) => { e = ot(e, t) })), e }, generateStyleSheets: () => { const t = [], i = e.defaultColorScheme || "light"; function o(e, n) { Object.keys(n).length && t.push("string" == typeof e ? { [e]: { ...n } } : e) } o(n(void 0, { ...u }), u); const { [i]: s, ...l } = p; if (s) { const { css: e } = s, t = a[i]?.palette?.mode, l = !r && t ? { colorScheme: t, ...e } : { ...e }; o(n(i, { ...l }), l) } return Object.entries(l).forEach((([e, { css: t }]) => { const i = a[e]?.palette?.mode, s = !r && i ? { colorScheme: i, ...t } : { ...t }; o(n(e, { ...s }), s) })), t } } }(x, S); return x.vars = M, Object.entries(x.colorSchemes[x.defaultColorScheme]).forEach((([e, t]) => { x[e] = t })), x.generateThemeVars = w, x.generateStyleSheets = _, x.generateSpacing = function () { return Lt(c.spacing, Ct(this)) }, x.getColorSchemeSelector = function (e) { return function (t) { return "media" === e ? `@media (prefers-color-scheme: ${t})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${t}"] &` : "class" === e ? `.${t} &` : "data" === e ? `[data-${t}] &` : `${e.replace("%s", t)} &` : "&" } }(s), x.spacing = x.generateSpacing(), x.shouldSkipGeneratingVar = o, x.unstable_sxConfig = { ...ln, ...c?.unstable_sxConfig }, x.unstable_sx = function (e) { return un({ sx: e, theme: this }) }, x.toRuntimeSource = Hr, x } function Yr(e, t, n) { e.colorSchemes && n && (e.colorSchemes[t] = { ...!0 !== n && n, palette: yr({ ...!0 === n ? {} : n.palette, mode: t }) }) } function Qr(e = {}, ...t) { const { palette: n, cssVariables: r = !1, colorSchemes: i = (n ? void 0 : { light: !0 }), defaultColorScheme: a = n?.mode, ...o } = e, s = a || "light", l = i?.[s], c = { ...i, ...n ? { [s]: { ..."boolean" != typeof l && l, palette: n } } : void 0 }; if (!1 === r) { if (!("colorSchemes" in e)) return Dr(e, ...t); let r = n; "palette" in e || c[s] && (!0 !== c[s] ? r = c[s].palette : "dark" === s && (r = { mode: "dark" })); const i = Dr({ ...e, palette: r }, ...t); return i.defaultColorScheme = s, i.colorSchemes = c, "light" === i.palette.mode && (i.colorSchemes.light = { ...!0 !== c.light && c.light, palette: i.palette }, Yr(i, "dark", c.dark)), "dark" === i.palette.mode && (i.colorSchemes.dark = { ...!0 !== c.dark && c.dark, palette: i.palette }, Yr(i, "light", c.light)), i } return n || "light" in c || "light" !== s || (c.light = !0), Jr({ ...o, colorSchemes: c, defaultColorScheme: s, ..."boolean" != typeof r && r }, ...t) } const Kr = Qr(), qr = "$$material", Zr = e => function (e) { return "ownerState" !== e && "theme" !== e && "sx" !== e && "as" !== e }(e) && "classes" !== e, $r = function (e = {}) { const { themeId: t, defaultTheme: n = fn, rootShouldForwardProp: r = mn, slotShouldForwardProp: i = mn } = e; function a(e) { !function (e, t, n) { e.theme = function (e) { for (const t in e) return !1; return !0 }(e.theme) ? n : e.theme[t] || e.theme }(e, t, n) } return (e, t = {}) => { !function (e) { Array.isArray(e.__emotion_styles) && (e.__emotion_styles = (e => e.filter((e => e !== un)))(e.__emotion_styles)) }(e); const { name: n, slot: o, skipVariantsResolver: s, skipSx: l, overridesResolver: c = gn(bn(o)), ...u } = t, d = void 0 !== s ? s : o && "Root" !== o && "root" !== o || !1, h = l || !1; let p = mn; "Root" === o || "root" === o ? p = r : o ? p = i : function (e) { return "string" == typeof e && e.charCodeAt(0) > 96 }(e) && (p = void 0); const f = tt(e, { shouldForwardProp: p, label: void 0, ...u }), m = e => { if ("function" == typeof e && e.__emotion_real !== e) return function (t) { return vn(t, e) }; if (it(e)) { const t = pn(e); return t.variants ? function (e) { return vn(e, t) } : t.style } return e }, g = (...t) => { const r = [], i = t.map(m), o = []; if (r.push(a), n && c && o.push((function (e) { const t = e.theme, r = t.components?.[n]?.styleOverrides; if (!r) return null; const i = {}; for (const t in r) i[t] = vn(e, r[t]); return c(e, i) })), n && !d && o.push((function (e) { const t = e.theme, r = t?.components?.[n]?.variants; return r ? yn(e, r) : null })), h || o.push(un), Array.isArray(i[0])) { const e = i.shift(), t = new Array(r.length).fill(""), n = new Array(o.length).fill(""); let a; a = [...t, ...e, ...n], a.raw = [...t, ...e.raw, ...n], r.unshift(a) } const s = [...r, ...i, ...o], l = f(...s); return e.muiName && (l.muiName = e.muiName), l }; return f.withConfig && (g.withConfig = f.withConfig), g } }({ themeId: qr, defaultTheme: Kr, rootShouldForwardProp: Zr }), ei = $r, ti = { theme: void 0 }, ni = function (e) { let t, n; return function (r) { let i = t; return void 0 !== i && r.theme === n || (ti.theme = r.theme, i = pn(e(ti)), t = i, n = r.theme), i } }; function ri(e, t) { const n = { ...t }; for (const r in e) if (Object.prototype.hasOwnProperty.call(e, r)) { const i = r; if ("components" === i || "slots" === i) n[i] = { ...e[i], ...n[i] }; else if ("componentsProps" === i || "slotProps" === i) { const r = e[i], a = t[i]; if (a) if (r) { n[i] = { ...a }; for (const e in r) if (Object.prototype.hasOwnProperty.call(r, e)) { const t = e; n[i][t] = ri(r[t], a[t]) } } else n[i] = a; else n[i] = r || {} } else void 0 === n[i] && (n[i] = e[i]) } return n } var ii = i(848); const ai = n.createContext(void 0); const oi = function ({ value: e, children: t }) { return (0, ii.jsx)(ai.Provider, { value: e, children: t }) }; function si(e) { return function ({ props: e, name: t }) { return function (e) { const { theme: t, name: n, props: r } = e; if (!t || !t.components || !t.components[n]) return r; const i = t.components[n]; return i.defaultProps ? ri(i.defaultProps, r) : i.styleOverrides || i.variants ? r : ri(i, r) }({ props: e, name: t, theme: { components: n.useContext(ai) } }) }(e) } const li = ft; function ci(e = []) { return ([, t]) => t && function (e, t = []) { if (!function (e) { return "string" == typeof e.main }(e)) return !1; for (const n of t) if (!e.hasOwnProperty(n) || "string" != typeof e[n]) return !1; return !0 }(t, e) } const ui = function (e = null) { const t = n.useContext(Xe); return t && (r = t, 0 !== Object.keys(r).length) ? t : e; var r }, di = hn(), hi = function (e = di) { return ui(e) }; function pi() { const e = hi(Kr); return e[qr] || e } const fi = e => e, mi = (() => { let e = fi; return { configure(t) { e = t }, generate: t => e(t), reset() { e = fi } } })(), gi = { active: "active", checked: "checked", completed: "completed", disabled: "disabled", error: "error", expanded: "expanded", focused: "focused", focusVisible: "focusVisible", open: "open", readOnly: "readOnly", required: "required", selected: "selected" }; function vi(e, t, n = "Mui") { const r = gi[t]; return r ? `${n}-${r}` : `${mi.generate(e)}-${t}` } function yi(e, t, n = "Mui") { const r = {}; return t.forEach((t => { r[t] = vi(e, t, n) })), r } function bi(e) { return vi("MuiPaper", e) } yi("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]); const xi = ei("div", { name: "MuiPaper", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, t[n.variant], !n.square && t.rounded, "elevation" === n.variant && t[`elevation${n.elevation}`]] } })(ni((({ theme: e }) => ({ backgroundColor: (e.vars || e).palette.background.paper, color: (e.vars || e).palette.text.primary, transition: e.transitions.create("box-shadow"), variants: [{ props: ({ ownerState: e }) => !e.square, style: { borderRadius: e.shape.borderRadius } }, { props: { variant: "outlined" }, style: { border: `1px solid ${(e.vars || e).palette.divider}` } }, { props: { variant: "elevation" }, style: { boxShadow: "var(--Paper-shadow)", backgroundImage: "var(--Paper-overlay)" } }] })))), Ai = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiPaper" }), r = pi(), { className: i, component: a = "div", elevation: o = 1, square: s = !1, variant: l = "elevation", ...c } = n, u = { ...n, component: a, elevation: o, square: s, variant: l }, d = (e => { const { square: t, elevation: n, variant: r, classes: i } = e; return w({ root: ["root", r, !t && "rounded", "elevation" === r && `elevation${n}`] }, bi, i) })(u); return (0, ii.jsx)(xi, { as: a, ownerState: u, className: M(d.root, i), ref: t, ...c, style: { ..."elevation" === l && { "--Paper-shadow": (r.vars || r).shadows[o], ...r.vars && { "--Paper-overlay": r.vars.overlays?.[o] }, ...!r.vars && "dark" === r.palette.mode && { "--Paper-overlay": `linear-gradient(${En("#fff", kr(o))}, ${En("#fff", kr(o))})` } }, ...c.style } }) })), Si = Ai; function Mi(e) { return vi("MuiAppBar", e) } yi("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]); const wi = (e, t) => e ? `${e?.replace(")", "")}, ${t})` : t, _i = ei(Si, { name: "MuiAppBar", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, t[`position${li(n.position)}`], t[`color${li(n.color)}`]] } })(ni((({ theme: e }) => ({ display: "flex", flexDirection: "column", width: "100%", boxSizing: "border-box", flexShrink: 0, variants: [{ props: { position: "fixed" }, style: { position: "fixed", zIndex: (e.vars || e).zIndex.appBar, top: 0, left: "auto", right: 0, "@media print": { position: "absolute" } } }, { props: { position: "absolute" }, style: { position: "absolute", zIndex: (e.vars || e).zIndex.appBar, top: 0, left: "auto", right: 0 } }, { props: { position: "sticky" }, style: { position: "sticky", zIndex: (e.vars || e).zIndex.appBar, top: 0, left: "auto", right: 0 } }, { props: { position: "static" }, style: { position: "static" } }, { props: { position: "relative" }, style: { position: "relative" } }, { props: { color: "inherit" }, style: { "--AppBar-color": "inherit" } }, { props: { color: "default" }, style: { "--AppBar-background": e.vars ? e.vars.palette.AppBar.defaultBg : e.palette.grey[100], "--AppBar-color": e.vars ? e.vars.palette.text.primary : e.palette.getContrastText(e.palette.grey[100]), ...e.applyStyles("dark", { "--AppBar-background": e.vars ? e.vars.palette.AppBar.defaultBg : e.palette.grey[900], "--AppBar-color": e.vars ? e.vars.palette.text.primary : e.palette.getContrastText(e.palette.grey[900]) }) } }, ...Object.entries(e.palette).filter(ci(["contrastText"])).map((([t]) => ({ props: { color: t }, style: { "--AppBar-background": (e.vars ?? e).palette[t].main, "--AppBar-color": (e.vars ?? e).palette[t].contrastText } }))), { props: e => !0 === e.enableColorOnDark && !["inherit", "transparent"].includes(e.color), style: { backgroundColor: "var(--AppBar-background)", color: "var(--AppBar-color)" } }, { props: e => !1 === e.enableColorOnDark && !["inherit", "transparent"].includes(e.color), style: { backgroundColor: "var(--AppBar-background)", color: "var(--AppBar-color)", ...e.applyStyles("dark", { backgroundColor: e.vars ? wi(e.vars.palette.AppBar.darkBg, "var(--AppBar-background)") : null, color: e.vars ? wi(e.vars.palette.AppBar.darkColor, "var(--AppBar-color)") : null }) } }, { props: { color: "transparent" }, style: { "--AppBar-background": "transparent", "--AppBar-color": "inherit", backgroundColor: "var(--AppBar-background)", color: "var(--AppBar-color)", ...e.applyStyles("dark", { backgroundImage: "none" }) } }] })))), Ei = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiAppBar" }), { className: r, color: i = "primary", enableColorOnDark: a = !1, position: o = "fixed", ...s } = n, l = { ...n, color: i, position: o, enableColorOnDark: a }, c = (e => { const { color: t, position: n, classes: r } = e; return w({ root: ["root", `color${li(t)}`, `position${li(n)}`] }, Mi, r) })(l); return (0, ii.jsx)(_i, { square: !0, component: "header", ownerState: l, elevation: 4, className: M(c.root, r, "fixed" === o && "mui-fixed"), ref: t, ...s }) })), Ci = Ei; function Ti(e) { const { sx: t, ...n } = e, { systemProps: r, otherProps: i } = (e => { const t = { systemProps: {}, otherProps: {} }, n = e?.theme?.unstable_sxConfig ?? ln; return Object.keys(e).forEach((r => { n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r] })), t })(n); let a; return a = Array.isArray(t) ? [r, ...t] : "function" == typeof t ? (...e) => { const n = t(...e); return it(n) ? { ...r, ...n } : r } : { ...r, ...t }, { ...i, sx: a } } function Ri(e) { return vi("MuiTypography", e) } const Bi = yi("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), Ii = { primary: !0, secondary: !0, error: !0, info: !0, success: !0, warning: !0, textPrimary: !0, textSecondary: !0, textDisabled: !0 }, Pi = Ti, Li = ei("span", { name: "MuiTypography", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, n.variant && t[n.variant], "inherit" !== n.align && t[`align${li(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph] } })(ni((({ theme: e }) => ({ margin: 0, variants: [{ props: { variant: "inherit" }, style: { font: "inherit", lineHeight: "inherit", letterSpacing: "inherit" } }, ...Object.entries(e.typography).filter((([e, t]) => "inherit" !== e && t && "object" == typeof t)).map((([e, t]) => ({ props: { variant: e }, style: t }))), ...Object.entries(e.palette).filter(ci()).map((([t]) => ({ props: { color: t }, style: { color: (e.vars || e).palette[t].main } }))), ...Object.entries(e.palette?.text || {}).filter((([, e]) => "string" == typeof e)).map((([t]) => ({ props: { color: `text${li(t)}` }, style: { color: (e.vars || e).palette.text[t] } }))), { props: ({ ownerState: e }) => "inherit" !== e.align, style: { textAlign: "var(--Typography-textAlign)" } }, { props: ({ ownerState: e }) => e.noWrap, style: { overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" } }, { props: ({ ownerState: e }) => e.gutterBottom, style: { marginBottom: "0.35em" } }, { props: ({ ownerState: e }) => e.paragraph, style: { marginBottom: 16 } }] })))), Di = { h1: "h1", h2: "h2", h3: "h3", h4: "h4", h5: "h5", h6: "h6", subtitle1: "h6", subtitle2: "h6", body1: "p", body2: "p", inherit: "p" }, ki = n.forwardRef((function (e, t) { const { color: n, ...r } = si({ props: e, name: "MuiTypography" }), i = Pi({ ...r, ...!Ii[n] && { color: n } }), { align: a = "inherit", className: o, component: s, gutterBottom: l = !1, noWrap: c = !1, paragraph: u = !1, variant: d = "body1", variantMapping: h = Di, ...p } = i, f = { ...i, align: a, color: n, className: o, component: s, gutterBottom: l, noWrap: c, paragraph: u, variant: d, variantMapping: h }, m = s || (u ? "p" : h[d] || Di[d]) || "span", g = (e => { const { align: t, gutterBottom: n, noWrap: r, paragraph: i, variant: a, classes: o } = e; return w({ root: ["root", a, "inherit" !== e.align && `align${li(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"] }, Ri, o) })(f); return (0, ii.jsx)(Li, { as: m, ref: t, className: M(g.root, o), ...p, ownerState: f, style: { ..."inherit" !== a && { "--Typography-textAlign": a }, ...p.style } }) })); function Ni(e) { try { return e.matches(":focus-visible") } catch (e) { } return !1 } function Fi(e) { return vi("MuiLink", e) } const Oi = yi("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]), Ui = ({ theme: e, ownerState: t }) => { const n = t.color, r = mt(e, `palette.${n}`, !1) || t.color, i = mt(e, `palette.${n}Channel`); return "vars" in e && i ? `rgba(${i} / 0.4)` : En(r, .4) }, zi = { primary: !0, secondary: !0, error: !0, info: !0, success: !0, warning: !0, textPrimary: !0, textSecondary: !0, textDisabled: !0 }, Hi = ei(ki, { name: "MuiLink", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, t[`underline${li(n.underline)}`], "button" === n.component && t.button] } })(ni((({ theme: e }) => ({ variants: [{ props: { underline: "none" }, style: { textDecoration: "none" } }, { props: { underline: "hover" }, style: { textDecoration: "none", "&:hover": { textDecoration: "underline" } } }, { props: { underline: "always" }, style: { textDecoration: "underline", "&:hover": { textDecorationColor: "inherit" } } }, { props: ({ underline: e, ownerState: t }) => "always" === e && "inherit" !== t.color, style: { textDecorationColor: "var(--Link-underlineColor)" } }, ...Object.entries(e.palette).filter(ci()).map((([t]) => ({ props: { underline: "always", color: t }, style: { "--Link-underlineColor": e.vars ? `rgba(${e.vars.palette[t].mainChannel} / 0.4)` : En(e.palette[t].main, .4) } }))), { props: { underline: "always", color: "textPrimary" }, style: { "--Link-underlineColor": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : En(e.palette.text.primary, .4) } }, { props: { underline: "always", color: "textSecondary" }, style: { "--Link-underlineColor": e.vars ? `rgba(${e.vars.palette.text.secondaryChannel} / 0.4)` : En(e.palette.text.secondary, .4) } }, { props: { underline: "always", color: "textDisabled" }, style: { "--Link-underlineColor": (e.vars || e).palette.text.disabled } }, { props: { component: "button" }, style: { position: "relative", WebkitTapHighlightColor: "transparent", backgroundColor: "transparent", outline: 0, border: 0, margin: 0, borderRadius: 0, padding: 0, cursor: "pointer", userSelect: "none", verticalAlign: "middle", MozAppearance: "none", WebkitAppearance: "none", "&::-moz-focus-inner": { borderStyle: "none" }, [`&.${Oi.focusVisible}`]: { outline: "auto" } } }] })))), Gi = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiLink" }), i = pi(), { className: a, color: o = "primary", component: s = "a", onBlur: l, onFocus: c, TypographyClasses: u, underline: d = "always", variant: h = "inherit", sx: p, ...f } = r, [m, g] = n.useState(!1), v = { ...r, color: o, component: s, focusVisible: m, underline: d, variant: h }, y = (e => { const { classes: t, component: n, focusVisible: r, underline: i } = e; return w({ root: ["root", `underline${li(i)}`, "button" === n && "button", r && "focusVisible"] }, Fi, t) })(v); return (0, ii.jsx)(Hi, { color: o, className: M(y.root, a), classes: u, component: s, onBlur: e => { Ni(e.target) || g(!1), l && l(e) }, onFocus: e => { Ni(e.target) && g(!0), c && c(e) }, ref: t, ownerState: v, variant: h, ...f, sx: [...void 0 === zi[o] ? [{ color: o }] : [], ...Array.isArray(p) ? p : [p]], style: { ...f.style, ..."always" === d && "inherit" !== o && !zi[o] && { "--Link-underlineColor": Ui({ theme: i, ownerState: v }) } } }) })), ji = Gi; function Vi(e) { return vi("MuiToolbar", e) } yi("MuiToolbar", ["root", "gutters", "regular", "dense"]); const Wi = ei("div", { name: "MuiToolbar", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, !n.disableGutters && t.gutters, t[n.variant]] } })(ni((({ theme: e }) => ({ position: "relative", display: "flex", alignItems: "center", variants: [{ props: ({ ownerState: e }) => !e.disableGutters, style: { paddingLeft: e.spacing(2), paddingRight: e.spacing(2), [e.breakpoints.up("sm")]: { paddingLeft: e.spacing(3), paddingRight: e.spacing(3) } } }, { props: { variant: "dense" }, style: { minHeight: 48 } }, { props: { variant: "regular" }, style: e.mixins.toolbar }] })))), Xi = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiToolbar" }), { className: r, component: i = "div", disableGutters: a = !1, variant: o = "regular", ...s } = n, l = { ...n, component: i, disableGutters: a, variant: o }, c = (e => { const { classes: t, disableGutters: n, variant: r } = e; return w({ root: ["root", !n && "gutters", r] }, Vi, t) })(l); return (0, ii.jsx)(Wi, { as: i, className: M(c.root, r), ref: t, ownerState: l, ...s }) })); function Ji(e, t) { "function" == typeof e ? e(t) : e && (e.current = t) } function Yi(...e) { return n.useMemo((() => e.every((e => null == e)) ? null : t => { e.forEach((e => { Ji(e, t) })) }), e) } const Qi = Yi, Ki = "undefined" != typeof window ? n.useLayoutEffect : n.useEffect, qi = function (e) { const t = n.useRef(e); return Ki((() => { t.current = e })), n.useRef(((...e) => (0, t.current)(...e))).current }, Zi = qi, $i = {}; function ea(e, t) { const r = n.useRef($i); return r.current === $i && (r.current = e(t)), r } class ta { static create() { return new ta } static use() { const e = ea(ta.create).current, [t, r] = n.useState(!1); return e.shouldMount = t, e.setShouldMount = r, n.useEffect(e.mountEffect, [t]), e } constructor() { this.ref = { current: null }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null } mount() { return this.mounted || (this.mounted = function () { let e, t; const n = new Promise(((n, r) => { e = n, t = r })); return n.resolve = e, n.reject = t, n }(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted } mountEffect = () => { this.shouldMount && !this.didMount && null !== this.ref.current && (this.didMount = !0, this.mounted.resolve()) }; start(...e) { this.mount().then((() => this.ref.current?.start(...e))) } stop(...e) { this.mount().then((() => this.ref.current?.stop(...e))) } pulsate(...e) { this.mount().then((() => this.ref.current?.pulsate(...e))) } } function na(e, t) { if (null == e) return {}; var n = {}; for (var r in e) if ({}.hasOwnProperty.call(e, r)) { if (t.includes(r)) continue; n[r] = e[r] } return n } function ra(e, t) { return ra = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e }, ra(e, t) } function ia(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, ra(e, t) } const aa = n.createContext(null); function oa(e, t) { var r = Object.create(null); return e && n.Children.map(e, (function (e) { return e })).forEach((function (e) { r[e.key] = function (e) { return t && (0, n.isValidElement)(e) ? t(e) : e }(e) })), r } function sa(e, t, n) { return null != n[t] ? n[t] : e.props[t] } function la(e, t, r) { var i = oa(e.children), a = function (e, t) { function n(n) { return n in t ? t[n] : e[n] } e = e || {}, t = t || {}; var r, i = Object.create(null), a = []; for (var o in e) o in t ? a.length && (i[o] = a, a = []) : a.push(o); var s = {}; for (var l in t) { if (i[l]) for (r = 0; r < i[l].length; r++) { var c = i[l][r]; s[i[l][r]] = n(c) } s[l] = n(l) } for (r = 0; r < a.length; r++)s[a[r]] = n(a[r]); return s }(t, i); return Object.keys(a).forEach((function (o) { var s = a[o]; if ((0, n.isValidElement)(s)) { var l = o in t, c = o in i, u = t[o], d = (0, n.isValidElement)(u) && !u.props.in; !c || l && !d ? c || !l || d ? c && l && (0, n.isValidElement)(u) && (a[o] = (0, n.cloneElement)(s, { onExited: r.bind(null, s), in: u.props.in, exit: sa(s, "exit", e), enter: sa(s, "enter", e) })) : a[o] = (0, n.cloneElement)(s, { in: !1 }) : a[o] = (0, n.cloneElement)(s, { onExited: r.bind(null, s), in: !0, exit: sa(s, "exit", e), enter: sa(s, "enter", e) }) } })), a } var ca = Object.values || function (e) { return Object.keys(e).map((function (t) { return e[t] })) }, ua = function (e) { function t(t, n) { var r, i = (r = e.call(this, t, n) || this).handleExited.bind(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(r)); return r.state = { contextValue: { isMounting: !0 }, handleExited: i, firstRender: !0 }, r } ia(t, e); var r = t.prototype; return r.componentDidMount = function () { this.mounted = !0, this.setState({ contextValue: { isMounting: !1 } }) }, r.componentWillUnmount = function () { this.mounted = !1 }, t.getDerivedStateFromProps = function (e, t) { var r, i, a = t.children, o = t.handleExited; return { children: t.firstRender ? (r = e, i = o, oa(r.children, (function (e) { return (0, n.cloneElement)(e, { onExited: i.bind(null, e), in: !0, appear: sa(e, "appear", r), enter: sa(e, "enter", r), exit: sa(e, "exit", r) }) }))) : la(e, a, o), firstRender: !1 } }, r.handleExited = function (e, t) { var n = oa(this.props.children); e.key in n || (e.props.onExited && e.props.onExited(t), this.mounted && this.setState((function (t) { var n = _({}, t.children); return delete n[e.key], { children: n } }))) }, r.render = function () { var e = this.props, t = e.component, r = e.childFactory, i = na(e, ["component", "childFactory"]), a = this.state.contextValue, o = ca(this.state.children).map(r); return delete i.appear, delete i.enter, delete i.exit, null === t ? n.createElement(aa.Provider, { value: a }, o) : n.createElement(aa.Provider, { value: a }, n.createElement(t, i, o)) }, t }(n.Component); ua.propTypes = {}, ua.defaultProps = { component: "div", childFactory: function (e) { return e } }; const da = ua, ha = []; class pa { static create() { return new pa } currentId = null; start(e, t) { this.clear(), this.currentId = setTimeout((() => { this.currentId = null, t() }), e) } clear = () => { null !== this.currentId && (clearTimeout(this.currentId), this.currentId = null) }; disposeEffect = () => this.clear } function fa() { const e = ea(pa.create).current; var t; return t = e.disposeEffect, n.useEffect(t, ha), e } i(146); var ma = We((function (e, t) { var r = ze([e.styles], void 0, n.useContext(Xe)), i = n.useRef(); return je((function () { var e = t.key + "-global", n = new t.sheet.constructor({ key: e, nonce: t.sheet.nonce, container: t.sheet.container, speedy: t.sheet.isSpeedy }), a = !1, o = document.querySelector('style[data-emotion="' + e + " " + r.name + '"]'); return t.sheet.tags.length && (n.before = t.sheet.tags[0]), null !== o && (a = !0, o.setAttribute("data-emotion", e), n.hydrate([o])), i.current = [n, a], function () { n.flush() } }), [t]), je((function () { var e = i.current, n = e[0]; if (e[1]) e[1] = !1; else { if (void 0 !== r.next && Ye(t, r.next, !0), n.tags.length) { var a = n.tags[n.tags.length - 1].nextElementSibling; n.before = a, n.flush() } t.insert("", r, n, !1) } }), [t, r.name]), null })); function ga() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return ze(t) } var va = function () { var e = ga.apply(void 0, arguments), t = "animation-" + e.name; return { name: t, styles: "@keyframes " + t + "{" + e.styles + "}", anim: 1, toString: function () { return "_EMO_" + this.name + "_" + this.styles + "_EMO_" } } }; const ya = yi("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), ba = va`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, xa = va`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, Aa = va`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, Sa = ei("span", { name: "MuiTouchRipple", slot: "Root" })({ overflow: "hidden", pointerEvents: "none", position: "absolute", zIndex: 0, top: 0, right: 0, bottom: 0, left: 0, borderRadius: "inherit" }), Ma = ei((function (e) { const { className: t, classes: r, pulsate: i = !1, rippleX: a, rippleY: o, rippleSize: s, in: l, onExited: c, timeout: u } = e, [d, h] = n.useState(!1), p = M(t, r.ripple, r.rippleVisible, i && r.ripplePulsate), f = { width: s, height: s, top: -s / 2 + o, left: -s / 2 + a }, m = M(r.child, d && r.childLeaving, i && r.childPulsate); return l || d || h(!0), n.useEffect((() => { if (!l && null != c) { const e = setTimeout(c, u); return () => { clearTimeout(e) } } }), [c, l, u]), (0, ii.jsx)("span", { className: p, style: f, children: (0, ii.jsx)("span", { className: m }) }) }), { name: "MuiTouchRipple", slot: "Ripple" })`
  opacity: 0;
  position: absolute;

  &.${ya.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${ba};
    animation-duration: ${550}ms;
    animation-timing-function: ${({ theme: e }) => e.transitions.easing.easeInOut};
  }

  &.${ya.ripplePulsate} {
    animation-duration: ${({ theme: e }) => e.transitions.duration.shorter}ms;
  }

  & .${ya.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${ya.childLeaving} {
    opacity: 0;
    animation-name: ${xa};
    animation-duration: ${550}ms;
    animation-timing-function: ${({ theme: e }) => e.transitions.easing.easeInOut};
  }

  & .${ya.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Aa};
    animation-duration: 2500ms;
    animation-timing-function: ${({ theme: e }) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, wa = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiTouchRipple" }), { center: i = !1, classes: a = {}, className: o, ...s } = r, [l, c] = n.useState([]), u = n.useRef(0), d = n.useRef(null); n.useEffect((() => { d.current && (d.current(), d.current = null) }), [l]); const h = n.useRef(!1), p = fa(), f = n.useRef(null), m = n.useRef(null), g = n.useCallback((e => { const { pulsate: t, rippleX: n, rippleY: r, rippleSize: i, cb: o } = e; c((e => [...e, (0, ii.jsx)(Ma, { classes: { ripple: M(a.ripple, ya.ripple), rippleVisible: M(a.rippleVisible, ya.rippleVisible), ripplePulsate: M(a.ripplePulsate, ya.ripplePulsate), child: M(a.child, ya.child), childLeaving: M(a.childLeaving, ya.childLeaving), childPulsate: M(a.childPulsate, ya.childPulsate) }, timeout: 550, pulsate: t, rippleX: n, rippleY: r, rippleSize: i }, u.current)])), u.current += 1, d.current = o }), [a]), v = n.useCallback(((e = {}, t = {}, n = () => { }) => { const { pulsate: r = !1, center: a = i || t.pulsate, fakeElement: o = !1 } = t; if ("mousedown" === e?.type && h.current) return void (h.current = !1); "touchstart" === e?.type && (h.current = !0); const s = o ? null : m.current, l = s ? s.getBoundingClientRect() : { width: 0, height: 0, left: 0, top: 0 }; let c, u, d; if (a || void 0 === e || 0 === e.clientX && 0 === e.clientY || !e.clientX && !e.touches) c = Math.round(l.width / 2), u = Math.round(l.height / 2); else { const { clientX: t, clientY: n } = e.touches && e.touches.length > 0 ? e.touches[0] : e; c = Math.round(t - l.left), u = Math.round(n - l.top) } if (a) d = Math.sqrt((2 * l.width ** 2 + l.height ** 2) / 3), d % 2 == 0 && (d += 1); else { const e = 2 * Math.max(Math.abs((s ? s.clientWidth : 0) - c), c) + 2, t = 2 * Math.max(Math.abs((s ? s.clientHeight : 0) - u), u) + 2; d = Math.sqrt(e ** 2 + t ** 2) } e?.touches ? null === f.current && (f.current = () => { g({ pulsate: r, rippleX: c, rippleY: u, rippleSize: d, cb: n }) }, p.start(80, (() => { f.current && (f.current(), f.current = null) }))) : g({ pulsate: r, rippleX: c, rippleY: u, rippleSize: d, cb: n }) }), [i, g, p]), y = n.useCallback((() => { v({}, { pulsate: !0 }) }), [v]), b = n.useCallback(((e, t) => { if (p.clear(), "touchend" === e?.type && f.current) return f.current(), f.current = null, void p.start(0, (() => { b(e, t) })); f.current = null, c((e => e.length > 0 ? e.slice(1) : e)), d.current = t }), [p]); return n.useImperativeHandle(t, (() => ({ pulsate: y, start: v, stop: b })), [y, v, b]), (0, ii.jsx)(Sa, { className: M(ya.root, a.root, o), ref: m, ...s, children: (0, ii.jsx)(da, { component: null, exit: !0, children: l }) }) })), _a = wa; function Ea(e) { return vi("MuiButtonBase", e) } const Ca = yi("MuiButtonBase", ["root", "disabled", "focusVisible"]), Ta = ei("button", { name: "MuiButtonBase", slot: "Root", overridesResolver: (e, t) => t.root })({ display: "inline-flex", alignItems: "center", justifyContent: "center", position: "relative", boxSizing: "border-box", WebkitTapHighlightColor: "transparent", backgroundColor: "transparent", outline: 0, border: 0, margin: 0, borderRadius: 0, padding: 0, cursor: "pointer", userSelect: "none", verticalAlign: "middle", MozAppearance: "none", WebkitAppearance: "none", textDecoration: "none", color: "inherit", "&::-moz-focus-inner": { borderStyle: "none" }, [`&.${Ca.disabled}`]: { pointerEvents: "none", cursor: "default" }, "@media print": { colorAdjust: "exact" } }), Ra = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiButtonBase" }), { action: i, centerRipple: a = !1, children: o, className: s, component: l = "button", disabled: c = !1, disableRipple: u = !1, disableTouchRipple: d = !1, focusRipple: h = !1, focusVisibleClassName: p, LinkComponent: f = "a", onBlur: m, onClick: g, onContextMenu: v, onDragLeave: y, onFocus: b, onFocusVisible: x, onKeyDown: A, onKeyUp: S, onMouseDown: _, onMouseLeave: E, onMouseUp: C, onTouchEnd: T, onTouchMove: R, onTouchStart: B, tabIndex: I = 0, TouchRippleProps: P, touchRippleRef: L, type: D, ...k } = r, N = n.useRef(null), F = ta.use(), O = Qi(F.ref, L), [U, z] = n.useState(!1); c && U && z(!1), n.useImperativeHandle(i, (() => ({ focusVisible: () => { z(!0), N.current.focus() } })), []); const H = F.shouldMount && !u && !c; function G(e, t, n = d) { return Zi((r => (t && t(r), n || F[e](r), !0))) } n.useEffect((() => { U && h && !u && F.pulsate() }), [u, h, U, F]); const j = G("start", _), V = G("stop", v), W = G("stop", y), X = G("stop", C), J = G("stop", (e => { U && e.preventDefault(), E && E(e) })), Y = G("start", B), Q = G("stop", T), K = G("stop", R), q = G("stop", (e => { Ni(e.target) || z(!1), m && m(e) }), !1), Z = Zi((e => { N.current || (N.current = e.currentTarget), Ni(e.target) && (z(!0), x && x(e)), b && b(e) })), $ = () => { const e = N.current; return l && "button" !== l && !("A" === e.tagName && e.href) }, ee = Zi((e => { h && !e.repeat && U && " " === e.key && F.stop(e, (() => { F.start(e) })), e.target === e.currentTarget && $() && " " === e.key && e.preventDefault(), A && A(e), e.target === e.currentTarget && $() && "Enter" === e.key && !c && (e.preventDefault(), g && g(e)) })), te = Zi((e => { h && " " === e.key && U && !e.defaultPrevented && F.stop(e, (() => { F.pulsate(e) })), S && S(e), g && e.target === e.currentTarget && $() && " " === e.key && !e.defaultPrevented && g(e) })); let ne = l; "button" === ne && (k.href || k.to) && (ne = f); const re = {}; "button" === ne ? (re.type = void 0 === D ? "button" : D, re.disabled = c) : (k.href || k.to || (re.role = "button"), c && (re["aria-disabled"] = c)); const ie = Qi(t, N), ae = { ...r, centerRipple: a, component: l, disabled: c, disableRipple: u, disableTouchRipple: d, focusRipple: h, tabIndex: I, focusVisible: U }, oe = (e => { const { disabled: t, focusVisible: n, focusVisibleClassName: r, classes: i } = e, a = w({ root: ["root", t && "disabled", n && "focusVisible"] }, Ea, i); return n && r && (a.root += ` ${r}`), a })(ae); return (0, ii.jsxs)(Ta, { as: ne, className: M(oe.root, s), ownerState: ae, onBlur: q, onClick: g, onContextMenu: V, onFocus: Z, onKeyDown: ee, onKeyUp: te, onMouseDown: j, onMouseLeave: J, onMouseUp: X, onDragLeave: W, onTouchEnd: Q, onTouchMove: K, onTouchStart: Y, ref: ie, tabIndex: c ? -1 : I, type: D, ...re, ...k, children: [o, H ? (0, ii.jsx)(_a, { ref: O, center: a, ...P }) : null] }) })); function Ba(e) { return vi("MuiIconButton", e) } const Ia = yi("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), Pa = ei(Ra, { name: "MuiIconButton", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, "default" !== n.color && t[`color${li(n.color)}`], n.edge && t[`edge${li(n.edge)}`], t[`size${li(n.size)}`]] } })(ni((({ theme: e }) => ({ textAlign: "center", flex: "0 0 auto", fontSize: e.typography.pxToRem(24), padding: 8, borderRadius: "50%", color: (e.vars || e).palette.action.active, transition: e.transitions.create("background-color", { duration: e.transitions.duration.shortest }), variants: [{ props: e => !e.disableRipple, style: { "--IconButton-hoverBg": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : En(e.palette.action.active, e.palette.action.hoverOpacity), "&:hover": { backgroundColor: "var(--IconButton-hoverBg)", "@media (hover: none)": { backgroundColor: "transparent" } } } }, { props: { edge: "start" }, style: { marginLeft: -12 } }, { props: { edge: "start", size: "small" }, style: { marginLeft: -3 } }, { props: { edge: "end" }, style: { marginRight: -12 } }, { props: { edge: "end", size: "small" }, style: { marginRight: -3 } }] }))), ni((({ theme: e }) => ({ variants: [{ props: { color: "inherit" }, style: { color: "inherit" } }, ...Object.entries(e.palette).filter(ci()).map((([t]) => ({ props: { color: t }, style: { color: (e.vars || e).palette[t].main } }))), ...Object.entries(e.palette).filter(ci()).map((([t]) => ({ props: { color: t }, style: { "--IconButton-hoverBg": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : En((e.vars || e).palette[t].main, e.palette.action.hoverOpacity) } }))), { props: { size: "small" }, style: { padding: 5, fontSize: e.typography.pxToRem(18) } }, { props: { size: "large" }, style: { padding: 12, fontSize: e.typography.pxToRem(28) } }], [`&.${Ia.disabled}`]: { backgroundColor: "transparent", color: (e.vars || e).palette.action.disabled } })))), La = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiIconButton" }), { edge: r = !1, children: i, className: a, color: o = "default", disabled: s = !1, disableFocusRipple: l = !1, size: c = "medium", ...u } = n, d = { ...n, edge: r, color: o, disabled: s, disableFocusRipple: l, size: c }, h = (e => { const { classes: t, disabled: n, color: r, edge: i, size: a } = e; return w({ root: ["root", n && "disabled", "default" !== r && `color${li(r)}`, i && `edge${li(i)}`, `size${li(a)}`] }, Ba, t) })(d); return (0, ii.jsx)(Pa, { className: M(h.root, a), centerRipple: !0, focusRipple: !l, disabled: s, ref: t, ...u, ownerState: d, children: i }) })); i(2); const Da = n.createContext(), ka = function ({ value: e, ...t }) { return (0, ii.jsx)(Da.Provider, { value: e ?? !0, ...t }) }, Na = function (e, t, n) { return void 0 === e || "string" == typeof e ? t : { ...t, ownerState: { ...t.ownerState, ...n } } }, Fa = function (e, t = []) { if (void 0 === e) return {}; const n = {}; return Object.keys(e).filter((n => n.match(/^on[A-Z]/) && "function" == typeof e[n] && !t.includes(n))).forEach((t => { n[t] = e[t] })), n }, Oa = function (e) { if (void 0 === e) return {}; const t = {}; return Object.keys(e).filter((t => !(t.match(/^on[A-Z]/) && "function" == typeof e[t]))).forEach((n => { t[n] = e[n] })), t }, Ua = function (e) { const { getSlotProps: t, additionalProps: n, externalSlotProps: r, externalForwardedProps: i, className: a } = e; if (!t) { const e = M(n?.className, a, i?.className, r?.className), t = { ...n?.style, ...i?.style, ...r?.style }, o = { ...n, ...i, ...r }; return e.length > 0 && (o.className = e), Object.keys(t).length > 0 && (o.style = t), { props: o, internalRef: void 0 } } const o = Fa({ ...i, ...r }), s = Oa(r), l = Oa(i), c = t(o), u = M(c?.className, n?.className, a, i?.className, r?.className), d = { ...c?.style, ...n?.style, ...i?.style, ...r?.style }, h = { ...c, ...n, ...l, ...s }; return u.length > 0 && (h.className = u), Object.keys(d).length > 0 && (h.style = d), { props: h, internalRef: c.ref } }, za = function (e, t, n) { return "function" == typeof e ? e(t, n) : e }, Ha = function (e) { const { elementType: t, externalSlotProps: n, ownerState: r, skipResolvingSlotProps: i = !1, ...a } = e, o = i ? {} : za(n, r), { props: s, internalRef: l } = Ua({ ...a, externalSlotProps: o }), c = Yi(l, o?.ref, e.additionalProps?.ref); return Na(t, { ...s, ref: c }, r) }; function Ga(e) { return e && e.ownerDocument || document } const ja = Ga, Va = n.createContext({}); function Wa(e) { return vi("MuiList", e) } yi("MuiList", ["root", "padding", "dense", "subheader"]); const Xa = ei("ul", { name: "MuiList", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader] } })({ listStyle: "none", margin: 0, padding: 0, position: "relative", variants: [{ props: ({ ownerState: e }) => !e.disablePadding, style: { paddingTop: 8, paddingBottom: 8 } }, { props: ({ ownerState: e }) => e.subheader, style: { paddingTop: 0 } }] }), Ja = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiList" }), { children: i, className: a, component: o = "ul", dense: s = !1, disablePadding: l = !1, subheader: c, ...u } = r, d = n.useMemo((() => ({ dense: s })), [s]), h = { ...r, component: o, dense: s, disablePadding: l }, p = (e => { const { classes: t, disablePadding: n, dense: r, subheader: i } = e; return w({ root: ["root", !n && "padding", r && "dense", i && "subheader"] }, Wa, t) })(h); return (0, ii.jsx)(Va.Provider, { value: d, children: (0, ii.jsxs)(Xa, { as: o, className: M(p.root, a), ref: t, ownerState: h, ...u, children: [c, i] }) }) })), Ya = Ja; function Qa(e = window) { const t = e.document.documentElement.clientWidth; return e.innerWidth - t } const Ka = Qa, qa = Ki; function Za(e) { return Ga(e).defaultView || window } const $a = Za; function eo(e, t, n) { return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild } function to(e, t, n) { return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild } function no(e, t) { if (void 0 === t) return !0; let n = e.innerText; return void 0 === n && (n = e.textContent), n = n.trim().toLowerCase(), 0 !== n.length && (t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""))) } function ro(e, t, n, r, i, a) { let o = !1, s = i(e, t, !!t && n); for (; s;) { if (s === e.firstChild) { if (o) return !1; o = !0 } const t = !r && (s.disabled || "true" === s.getAttribute("aria-disabled")); if (s.hasAttribute("tabindex") && no(s, a) && !t) return s.focus(), !0; s = i(e, s, n) } return !1 } const io = n.forwardRef((function (e, t) { const { actions: r, autoFocus: i = !1, autoFocusItem: a = !1, children: o, className: s, disabledItemsFocusable: l = !1, disableListWrap: c = !1, onKeyDown: u, variant: d = "selectedMenu", ...h } = e, p = n.useRef(null), f = n.useRef({ keys: [], repeating: !0, previousKeyMatched: !0, lastTime: null }); qa((() => { i && p.current.focus() }), [i]), n.useImperativeHandle(r, (() => ({ adjustStyleForScrollbar: (e, { direction: t }) => { const n = !p.current.style.width; if (e.clientHeight < p.current.clientHeight && n) { const n = `${Ka($a(e))}px`; p.current.style["rtl" === t ? "paddingLeft" : "paddingRight"] = n, p.current.style.width = `calc(100% + ${n})` } return p.current } })), []); const m = Qi(p, t); let g = -1; n.Children.forEach(o, ((e, t) => { n.isValidElement(e) ? (e.props.disabled || ("selectedMenu" === d && e.props.selected || -1 === g) && (g = t), g === t && (e.props.disabled || e.props.muiSkipListHighlight || e.type.muiSkipListHighlight) && (g += 1, g >= o.length && (g = -1))) : g === t && (g += 1, g >= o.length && (g = -1)) })); const v = n.Children.map(o, ((e, t) => { if (t === g) { const t = {}; return a && (t.autoFocus = !0), void 0 === e.props.tabIndex && "selectedMenu" === d && (t.tabIndex = 0), n.cloneElement(e, t) } return e })); return (0, ii.jsx)(Ya, { role: "menu", ref: m, className: s, onKeyDown: e => { const t = p.current, n = e.key; if (e.ctrlKey || e.metaKey || e.altKey) return void (u && u(e)); const r = ja(t).activeElement; if ("ArrowDown" === n) e.preventDefault(), ro(t, r, c, l, eo); else if ("ArrowUp" === n) e.preventDefault(), ro(t, r, c, l, to); else if ("Home" === n) e.preventDefault(), ro(t, null, c, l, eo); else if ("End" === n) e.preventDefault(), ro(t, null, c, l, to); else if (1 === n.length) { const i = f.current, a = n.toLowerCase(), o = performance.now(); i.keys.length > 0 && (o - i.lastTime > 500 ? (i.keys = [], i.repeating = !0, i.previousKeyMatched = !0) : i.repeating && a !== i.keys[0] && (i.repeating = !1)), i.lastTime = o, i.keys.push(a); const s = r && !i.repeating && no(r, i); i.previousKeyMatched && (s || ro(t, r, !1, l, eo, i)) ? e.preventDefault() : i.previousKeyMatched = !1 } u && u(e) }, tabIndex: i ? 0 : -1, ...h, children: v }) })); function ao(e) { return parseInt(n.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null } var oo = i(961); var so = "unmounted", lo = "exited", co = "entering", uo = "entered", ho = "exiting", po = function (e) { function t(t, n) { var r; r = e.call(this, t, n) || this; var i, a = n && !n.isMounting ? t.enter : t.appear; return r.appearStatus = null, t.in ? a ? (i = lo, r.appearStatus = co) : i = uo : i = t.unmountOnExit || t.mountOnEnter ? so : lo, r.state = { status: i }, r.nextCallback = null, r } ia(t, e), t.getDerivedStateFromProps = function (e, t) { return e.in && t.status === so ? { status: lo } : null }; var r = t.prototype; return r.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, r.componentDidUpdate = function (e) { var t = null; if (e !== this.props) { var n = this.state.status; this.props.in ? n !== co && n !== uo && (t = co) : n !== co && n !== uo || (t = ho) } this.updateStatus(!1, t) }, r.componentWillUnmount = function () { this.cancelNextCallback() }, r.getTimeouts = function () { var e, t, n, r = this.props.timeout; return e = t = n = r, null != r && "number" != typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), { exit: e, enter: t, appear: n } }, r.updateStatus = function (e, t) { if (void 0 === e && (e = !1), null !== t) if (this.cancelNextCallback(), t === co) { if (this.props.unmountOnExit || this.props.mountOnEnter) { var n = this.props.nodeRef ? this.props.nodeRef.current : oo.findDOMNode(this); n && function (e) { e.scrollTop }(n) } this.performEnter(e) } else this.performExit(); else this.props.unmountOnExit && this.state.status === lo && this.setState({ status: so }) }, r.performEnter = function (e) { var t = this, n = this.props.enter, r = this.context ? this.context.isMounting : e, i = this.props.nodeRef ? [r] : [oo.findDOMNode(this), r], a = i[0], o = i[1], s = this.getTimeouts(), l = r ? s.appear : s.enter; e || n ? (this.props.onEnter(a, o), this.safeSetState({ status: co }, (function () { t.props.onEntering(a, o), t.onTransitionEnd(l, (function () { t.safeSetState({ status: uo }, (function () { t.props.onEntered(a, o) })) })) }))) : this.safeSetState({ status: uo }, (function () { t.props.onEntered(a) })) }, r.performExit = function () { var e = this, t = this.props.exit, n = this.getTimeouts(), r = this.props.nodeRef ? void 0 : oo.findDOMNode(this); t ? (this.props.onExit(r), this.safeSetState({ status: ho }, (function () { e.props.onExiting(r), e.onTransitionEnd(n.exit, (function () { e.safeSetState({ status: lo }, (function () { e.props.onExited(r) })) })) }))) : this.safeSetState({ status: lo }, (function () { e.props.onExited(r) })) }, r.cancelNextCallback = function () { null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null) }, r.safeSetState = function (e, t) { t = this.setNextCallback(t), this.setState(e, t) }, r.setNextCallback = function (e) { var t = this, n = !0; return this.nextCallback = function (r) { n && (n = !1, t.nextCallback = null, e(r)) }, this.nextCallback.cancel = function () { n = !1 }, this.nextCallback }, r.onTransitionEnd = function (e, t) { this.setNextCallback(t); var n = this.props.nodeRef ? this.props.nodeRef.current : oo.findDOMNode(this), r = null == e && !this.props.addEndListener; if (n && !r) { if (this.props.addEndListener) { var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback], a = i[0], o = i[1]; this.props.addEndListener(a, o) } null != e && setTimeout(this.nextCallback, e) } else setTimeout(this.nextCallback, 0) }, r.render = function () { var e = this.state.status; if (e === so) return null; var t = this.props, r = t.children, i = (t.in, t.mountOnEnter, t.unmountOnExit, t.appear, t.enter, t.exit, t.timeout, t.addEndListener, t.onEnter, t.onEntering, t.onEntered, t.onExit, t.onExiting, t.onExited, t.nodeRef, na(t, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"])); return n.createElement(aa.Provider, { value: null }, "function" == typeof r ? r(e, i) : n.cloneElement(n.Children.only(r), i)) }, t }(n.Component); function fo() { } po.contextType = aa, po.propTypes = {}, po.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: fo, onEntering: fo, onEntered: fo, onExit: fo, onExiting: fo, onExited: fo }, po.UNMOUNTED = so, po.EXITED = lo, po.ENTERING = co, po.ENTERED = uo, po.EXITING = ho; const mo = po, go = e => e.scrollTop; function vo(e, t) { const { timeout: n, easing: r, style: i = {} } = e; return { duration: i.transitionDuration ?? ("number" == typeof n ? n : n[t.mode] || 0), easing: i.transitionTimingFunction ?? ("object" == typeof r ? r[t.mode] : r), delay: i.transitionDelay } } function yo(e) { return `scale(${e}, ${e ** 2})` } const bo = { entering: { opacity: 1, transform: yo(1) }, entered: { opacity: 1, transform: "none" } }, xo = "undefined" != typeof navigator && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), Ao = n.forwardRef((function (e, t) { const { addEndListener: r, appear: i = !0, children: a, easing: o, in: s, onEnter: l, onEntered: c, onEntering: u, onExit: d, onExited: h, onExiting: p, style: f, timeout: m = "auto", TransitionComponent: g = mo, ...v } = e, y = fa(), b = n.useRef(), x = pi(), A = n.useRef(null), S = Qi(A, ao(a), t), M = e => t => { if (e) { const n = A.current; void 0 === t ? e(n) : e(n, t) } }, w = M(u), _ = M(((e, t) => { go(e); const { duration: n, delay: r, easing: i } = vo({ style: f, timeout: m, easing: o }, { mode: "enter" }); let a; "auto" === m ? (a = x.transitions.getAutoHeightDuration(e.clientHeight), b.current = a) : a = n, e.style.transition = [x.transitions.create("opacity", { duration: a, delay: r }), x.transitions.create("transform", { duration: xo ? a : .666 * a, delay: r, easing: i })].join(","), l && l(e, t) })), E = M(c), C = M(p), T = M((e => { const { duration: t, delay: n, easing: r } = vo({ style: f, timeout: m, easing: o }, { mode: "exit" }); let i; "auto" === m ? (i = x.transitions.getAutoHeightDuration(e.clientHeight), b.current = i) : i = t, e.style.transition = [x.transitions.create("opacity", { duration: i, delay: n }), x.transitions.create("transform", { duration: xo ? i : .666 * i, delay: xo ? n : n || .333 * i, easing: r })].join(","), e.style.opacity = 0, e.style.transform = yo(.75), d && d(e) })), R = M(h); return (0, ii.jsx)(g, { appear: i, in: s, nodeRef: A, onEnter: _, onEntered: E, onEntering: w, onExit: T, onExited: R, onExiting: C, addEndListener: e => { "auto" === m && y.start(b.current || 0, e), r && r(A.current, e) }, timeout: "auto" === m ? null : m, ...v, children: (e, t) => n.cloneElement(a, { style: { opacity: 0, transform: yo(.75), visibility: "exited" !== e || s ? void 0 : "hidden", ...bo[e], ...f, ...a.props.style }, ref: S, ...t }) }) })); Ao && (Ao.muiSupportAuto = !0); const So = Ao, Mo = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(","); function wo(e) { const t = [], n = []; return Array.from(e.querySelectorAll(Mo)).forEach(((e, r) => { const i = function (e) { const t = parseInt(e.getAttribute("tabindex") || "", 10); return Number.isNaN(t) ? "true" === e.contentEditable || ("AUDIO" === e.nodeName || "VIDEO" === e.nodeName || "DETAILS" === e.nodeName) && null === e.getAttribute("tabindex") ? 0 : e.tabIndex : t }(e); -1 !== i && function (e) { return !(e.disabled || "INPUT" === e.tagName && "hidden" === e.type || function (e) { if ("INPUT" !== e.tagName || "radio" !== e.type) return !1; if (!e.name) return !1; const t = t => e.ownerDocument.querySelector(`input[type="radio"]${t}`); let n = t(`[name="${e.name}"]:checked`); return n || (n = t(`[name="${e.name}"]`)), n !== e }(e)) }(e) && (0 === i ? t.push(e) : n.push({ documentOrder: r, tabIndex: i, node: e })) })), n.sort(((e, t) => e.tabIndex === t.tabIndex ? e.documentOrder - t.documentOrder : e.tabIndex - t.tabIndex)).map((e => e.node)).concat(t) } function _o() { return !0 } const Eo = function (e) { const { children: t, disableAutoFocus: r = !1, disableEnforceFocus: i = !1, disableRestoreFocus: a = !1, getTabbable: o = wo, isEnabled: s = _o, open: l } = e, c = n.useRef(!1), u = n.useRef(null), d = n.useRef(null), h = n.useRef(null), p = n.useRef(null), f = n.useRef(!1), m = n.useRef(null), g = Yi(ao(t), m), v = n.useRef(null); n.useEffect((() => { l && m.current && (f.current = !r) }), [r, l]), n.useEffect((() => { if (!l || !m.current) return; const e = Ga(m.current); return m.current.contains(e.activeElement) || (m.current.hasAttribute("tabIndex") || m.current.setAttribute("tabIndex", "-1"), f.current && m.current.focus()), () => { a || (h.current && h.current.focus && (c.current = !0, h.current.focus()), h.current = null) } }), [l]), n.useEffect((() => { if (!l || !m.current) return; const e = Ga(m.current), t = t => { v.current = t, !i && s() && "Tab" === t.key && e.activeElement === m.current && t.shiftKey && (c.current = !0, d.current && d.current.focus()) }, n = () => { const t = m.current; if (null === t) return; if (!e.hasFocus() || !s() || c.current) return void (c.current = !1); if (t.contains(e.activeElement)) return; if (i && e.activeElement !== u.current && e.activeElement !== d.current) return; if (e.activeElement !== p.current) p.current = null; else if (null !== p.current) return; if (!f.current) return; let n = []; if (e.activeElement !== u.current && e.activeElement !== d.current || (n = o(m.current)), n.length > 0) { const e = Boolean(v.current?.shiftKey && "Tab" === v.current?.key), t = n[0], r = n[n.length - 1]; "string" != typeof t && "string" != typeof r && (e ? r.focus() : t.focus()) } else t.focus() }; e.addEventListener("focusin", n), e.addEventListener("keydown", t, !0); const r = setInterval((() => { e.activeElement && "BODY" === e.activeElement.tagName && n() }), 50); return () => { clearInterval(r), e.removeEventListener("focusin", n), e.removeEventListener("keydown", t, !0) } }), [r, i, a, s, l, o]); const y = e => { null === h.current && (h.current = e.relatedTarget), f.current = !0 }; return (0, ii.jsxs)(n.Fragment, { children: [(0, ii.jsx)("div", { tabIndex: l ? 0 : -1, onFocus: y, ref: u, "data-testid": "sentinelStart" }), n.cloneElement(t, { ref: g, onFocus: e => { null === h.current && (h.current = e.relatedTarget), f.current = !0, p.current = e.target; const n = t.props.onFocus; n && n(e) } }), (0, ii.jsx)("div", { tabIndex: l ? 0 : -1, onFocus: y, ref: d, "data-testid": "sentinelEnd" })] }) }, Co = n.forwardRef((function (e, t) { const { children: r, container: i, disablePortal: a = !1 } = e, [o, s] = n.useState(null), l = Yi(n.isValidElement(r) ? ao(r) : null, t); if (Ki((() => { a || s(function (e) { return "function" == typeof e ? e() : e }(i) || document.body) }), [i, a]), Ki((() => { if (o && !a) return Ji(t, o), () => { Ji(t, null) } }), [t, o, a]), a) { if (n.isValidElement(r)) { const e = { ref: l }; return n.cloneElement(r, e) } return (0, ii.jsx)(n.Fragment, { children: r }) } return (0, ii.jsx)(n.Fragment, { children: o ? oo.createPortal(r, o) : o }) })); function To(e, t) { const { className: n, elementType: r, ownerState: i, externalForwardedProps: a, getSlotOwnerState: o, internalForwardedProps: s, ...l } = t, { component: c, slots: u = { [e]: void 0 }, slotProps: d = { [e]: void 0 }, ...h } = a, p = u[e] || r, f = za(d[e], i), { props: { component: m, ...g }, internalRef: v } = Ua({ className: n, ...l, externalForwardedProps: "root" === e ? h : void 0, externalSlotProps: f }), y = Yi(v, f?.ref, t.ref), b = o ? o(g) : {}, x = { ...i, ...b }, A = "root" === e ? m || c : m, S = Na(p, { ..."root" === e && !c && !u[e] && s, ..."root" !== e && !u[e] && s, ...g, ...A && { as: A }, ref: y }, x); return Object.keys(b).forEach((e => { delete S[e] })), [p, S] } const Ro = { entering: { opacity: 1 }, entered: { opacity: 1 } }, Bo = n.forwardRef((function (e, t) { const r = pi(), i = { enter: r.transitions.duration.enteringScreen, exit: r.transitions.duration.leavingScreen }, { addEndListener: a, appear: o = !0, children: s, easing: l, in: c, onEnter: u, onEntered: d, onEntering: h, onExit: p, onExited: f, onExiting: m, style: g, timeout: v = i, TransitionComponent: y = mo, ...b } = e, x = n.useRef(null), A = Qi(x, ao(s), t), S = e => t => { if (e) { const n = x.current; void 0 === t ? e(n) : e(n, t) } }, M = S(h), w = S(((e, t) => { go(e); const n = vo({ style: g, timeout: v, easing: l }, { mode: "enter" }); e.style.webkitTransition = r.transitions.create("opacity", n), e.style.transition = r.transitions.create("opacity", n), u && u(e, t) })), _ = S(d), E = S(m), C = S((e => { const t = vo({ style: g, timeout: v, easing: l }, { mode: "exit" }); e.style.webkitTransition = r.transitions.create("opacity", t), e.style.transition = r.transitions.create("opacity", t), p && p(e) })), T = S(f); return (0, ii.jsx)(y, { appear: o, in: c, nodeRef: x, onEnter: w, onEntered: _, onEntering: M, onExit: C, onExited: T, onExiting: E, addEndListener: e => { a && a(x.current, e) }, timeout: v, ...b, children: (e, t) => n.cloneElement(s, { style: { opacity: 0, visibility: "exited" !== e || c ? void 0 : "hidden", ...Ro[e], ...g, ...s.props.style }, ref: A, ...t }) }) })), Io = Bo; function Po(e) { return vi("MuiBackdrop", e) } yi("MuiBackdrop", ["root", "invisible"]); const Lo = ei("div", { name: "MuiBackdrop", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, n.invisible && t.invisible] } })({ position: "fixed", display: "flex", alignItems: "center", justifyContent: "center", right: 0, bottom: 0, top: 0, left: 0, backgroundColor: "rgba(0, 0, 0, 0.5)", WebkitTapHighlightColor: "transparent", variants: [{ props: { invisible: !0 }, style: { backgroundColor: "transparent" } }] }), Do = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiBackdrop" }), { children: r, className: i, component: a = "div", invisible: o = !1, open: s, components: l = {}, componentsProps: c = {}, slotProps: u = {}, slots: d = {}, TransitionComponent: h, transitionDuration: p, ...f } = n, m = { ...n, component: a, invisible: o }, g = (e => { const { classes: t, invisible: n } = e; return w({ root: ["root", n && "invisible"] }, Po, t) })(m), v = { slots: { transition: h, root: l.Root, ...d }, slotProps: { ...c, ...u } }, [y, b] = To("root", { elementType: Lo, externalForwardedProps: v, className: M(g.root, i), ownerState: m }), [x, A] = To("transition", { elementType: Io, externalForwardedProps: v, ownerState: m }), S = (e => { const { ownerState: t, ...n } = e; return n })(A); return (0, ii.jsx)(x, { in: s, timeout: p, ...f, ...S, children: (0, ii.jsx)(y, { "aria-hidden": !0, ...b, classes: g, ref: t, children: r }) }) })); function ko(...e) { return e.reduce(((e, t) => null == t ? e : function (...n) { e.apply(this, n), t.apply(this, n) }), (() => { })) } function No(e, t) { t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden") } function Fo(e) { return parseInt(Za(e).getComputedStyle(e).paddingRight, 10) || 0 } function Oo(e, t, n, r, i) { const a = [t, n, ...r];[].forEach.call(e.children, (e => { const t = !a.includes(e), n = !function (e) { const t = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), n = "INPUT" === e.tagName && "hidden" === e.getAttribute("type"); return t || n }(e); t && n && No(e, i) })) } function Uo(e, t) { let n = -1; return e.some(((e, r) => !!t(e) && (n = r, !0))), n } const zo = new class { constructor() { this.modals = [], this.containers = [] } add(e, t) { let n = this.modals.indexOf(e); if (-1 !== n) return n; n = this.modals.length, this.modals.push(e), e.modalRef && No(e.modalRef, !1); const r = function (e) { const t = []; return [].forEach.call(e.children, (e => { "true" === e.getAttribute("aria-hidden") && t.push(e) })), t }(t); Oo(t, e.mount, e.modalRef, r, !0); const i = Uo(this.containers, (e => e.container === t)); return -1 !== i ? (this.containers[i].modals.push(e), n) : (this.containers.push({ modals: [e], container: t, restore: null, hiddenSiblings: r }), n) } mount(e, t) { const n = Uo(this.containers, (t => t.modals.includes(e))), r = this.containers[n]; r.restore || (r.restore = function (e, t) { const n = [], r = e.container; if (!t.disableScrollLock) { if (function (e) { const t = Ga(e); return t.body === e ? Za(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight }(r)) { const e = Qa(Za(r)); n.push({ value: r.style.paddingRight, property: "padding-right", el: r }), r.style.paddingRight = `${Fo(r) + e}px`; const t = Ga(r).querySelectorAll(".mui-fixed");[].forEach.call(t, (t => { n.push({ value: t.style.paddingRight, property: "padding-right", el: t }), t.style.paddingRight = `${Fo(t) + e}px` })) } let e; if (r.parentNode instanceof DocumentFragment) e = Ga(r).body; else { const t = r.parentElement, n = Za(r); e = "HTML" === t?.nodeName && "scroll" === n.getComputedStyle(t).overflowY ? t : r } n.push({ value: e.style.overflow, property: "overflow", el: e }, { value: e.style.overflowX, property: "overflow-x", el: e }, { value: e.style.overflowY, property: "overflow-y", el: e }), e.style.overflow = "hidden" } return () => { n.forEach((({ value: e, el: t, property: n }) => { e ? t.style.setProperty(n, e) : t.style.removeProperty(n) })) } }(r, t)) } remove(e, t = !0) { const n = this.modals.indexOf(e); if (-1 === n) return n; const r = Uo(this.containers, (t => t.modals.includes(e))), i = this.containers[r]; if (i.modals.splice(i.modals.indexOf(e), 1), this.modals.splice(n, 1), 0 === i.modals.length) i.restore && i.restore(), e.modalRef && No(e.modalRef, t), Oo(i.container, e.mount, e.modalRef, i.hiddenSiblings, !1), this.containers.splice(r, 1); else { const e = i.modals[i.modals.length - 1]; e.modalRef && No(e.modalRef, !1) } return n } isTopModal(e) { return this.modals.length > 0 && this.modals[this.modals.length - 1] === e } }; function Ho(e) { return vi("MuiModal", e) } yi("MuiModal", ["root", "hidden", "backdrop"]); const Go = ei("div", { name: "MuiModal", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, !n.open && n.exited && t.hidden] } })(ni((({ theme: e }) => ({ position: "fixed", zIndex: (e.vars || e).zIndex.modal, right: 0, bottom: 0, top: 0, left: 0, variants: [{ props: ({ ownerState: e }) => !e.open && e.exited, style: { visibility: "hidden" } }] })))), jo = ei(Do, { name: "MuiModal", slot: "Backdrop", overridesResolver: (e, t) => t.backdrop })({ zIndex: -1 }), Vo = n.forwardRef((function (e, t) { const r = si({ name: "MuiModal", props: e }), { BackdropComponent: i = jo, BackdropProps: a, classes: o, className: s, closeAfterTransition: l = !1, children: c, container: u, component: d, components: h = {}, componentsProps: p = {}, disableAutoFocus: f = !1, disableEnforceFocus: m = !1, disableEscapeKeyDown: g = !1, disablePortal: v = !1, disableRestoreFocus: y = !1, disableScrollLock: b = !1, hideBackdrop: x = !1, keepMounted: A = !1, onBackdropClick: S, onClose: _, onTransitionEnter: E, onTransitionExited: C, open: T, slotProps: R = {}, slots: B = {}, theme: I, ...P } = r, L = { ...r, closeAfterTransition: l, disableAutoFocus: f, disableEnforceFocus: m, disableEscapeKeyDown: g, disablePortal: v, disableRestoreFocus: y, disableScrollLock: b, hideBackdrop: x, keepMounted: A }, { getRootProps: D, getBackdropProps: k, getTransitionProps: N, portalRef: F, isTopModal: O, exited: U, hasTransition: z } = function (e) { const { container: t, disableEscapeKeyDown: r = !1, disableScrollLock: i = !1, closeAfterTransition: a = !1, onTransitionEnter: o, onTransitionExited: s, children: l, onClose: c, open: u, rootRef: d } = e, h = n.useRef({}), p = n.useRef(null), f = n.useRef(null), m = Yi(f, d), [g, v] = n.useState(!u), y = function (e) { return !!e && e.props.hasOwnProperty("in") }(l); let b = !0; "false" !== e["aria-hidden"] && !1 !== e["aria-hidden"] || (b = !1); const x = () => (h.current.modalRef = f.current, h.current.mount = p.current, h.current), A = () => { zo.mount(x(), { disableScrollLock: i }), f.current && (f.current.scrollTop = 0) }, S = qi((() => { const e = function (e) { return "function" == typeof e ? e() : e }(t) || Ga(p.current).body; zo.add(x(), e), f.current && A() })), M = () => zo.isTopModal(x()), w = qi((e => { p.current = e, e && (u && M() ? A() : f.current && No(f.current, b)) })), _ = n.useCallback((() => { zo.remove(x(), b) }), [b]); n.useEffect((() => () => { _() }), [_]), n.useEffect((() => { u ? S() : y && a || _() }), [u, _, y, a, S]); const E = e => t => { e.onKeyDown?.(t), "Escape" === t.key && 229 !== t.which && M() && (r || (t.stopPropagation(), c && c(t, "escapeKeyDown"))) }, C = e => t => { e.onClick?.(t), t.target === t.currentTarget && c && c(t, "backdropClick") }; return { getRootProps: (t = {}) => { const n = Fa(e); delete n.onTransitionEnter, delete n.onTransitionExited; const r = { ...n, ...t }; return { role: "presentation", ...r, onKeyDown: E(r), ref: m } }, getBackdropProps: (e = {}) => { const t = e; return { "aria-hidden": !0, ...t, onClick: C(t), open: u } }, getTransitionProps: () => ({ onEnter: ko((() => { v(!1), o && o() }), l?.props.onEnter), onExited: ko((() => { v(!0), s && s(), a && _() }), l?.props.onExited) }), rootRef: m, portalRef: w, isTopModal: M, exited: g, hasTransition: y } }({ ...L, rootRef: t }), H = { ...L, exited: U }, G = (e => { const { open: t, exited: n, classes: r } = e; return w({ root: ["root", !t && n && "hidden"], backdrop: ["backdrop"] }, Ho, r) })(H), j = {}; if (void 0 === c.props.tabIndex && (j.tabIndex = "-1"), z) { const { onEnter: e, onExited: t } = N(); j.onEnter = e, j.onExited = t } const V = { ...P, slots: { root: h.Root, backdrop: h.Backdrop, ...B }, slotProps: { ...p, ...R } }, [W, X] = To("root", { elementType: Go, externalForwardedProps: V, getSlotProps: D, additionalProps: { ref: t, as: d }, ownerState: H, className: M(s, G?.root, !H.open && H.exited && G?.hidden) }), [J, Y] = To("backdrop", { elementType: i, externalForwardedProps: V, additionalProps: a, getSlotProps: e => k({ ...e, onClick: t => { S && S(t), e?.onClick && e.onClick(t) } }), className: M(a?.className, G?.backdrop), ownerState: H }), Q = Qi(a?.ref, Y.ref); return A || T || z && !U ? (0, ii.jsx)(Co, { ref: F, container: u, disablePortal: v, children: (0, ii.jsxs)(W, { ...X, children: [!x && i ? (0, ii.jsx)(J, { ...Y, ref: Q }) : null, (0, ii.jsx)(Eo, { disableEnforceFocus: m, disableAutoFocus: f, disableRestoreFocus: y, isEnabled: O, open: T, children: n.cloneElement(c, j) })] }) }) : null })), Wo = Vo; function Xo(e) { return vi("MuiPopover", e) } function Jo(e, t) { let n = 0; return "number" == typeof t ? n = t : "center" === t ? n = e.height / 2 : "bottom" === t && (n = e.height), n } function Yo(e, t) { let n = 0; return "number" == typeof t ? n = t : "center" === t ? n = e.width / 2 : "right" === t && (n = e.width), n } function Qo(e) { return [e.horizontal, e.vertical].map((e => "number" == typeof e ? `${e}px` : e)).join(" ") } function Ko(e) { return "function" == typeof e ? e() : e } yi("MuiPopover", ["root", "paper"]); const qo = ei(Wo, { name: "MuiPopover", slot: "Root", overridesResolver: (e, t) => t.root })({}), Zo = ei(Si, { name: "MuiPopover", slot: "Paper", overridesResolver: (e, t) => t.paper })({ position: "absolute", overflowY: "auto", overflowX: "hidden", minWidth: 16, minHeight: 16, maxWidth: "calc(100% - 32px)", maxHeight: "calc(100% - 32px)", outline: 0 }), $o = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiPopover" }), { action: i, anchorEl: a, anchorOrigin: o = { vertical: "top", horizontal: "left" }, anchorPosition: s, anchorReference: l = "anchorEl", children: c, className: u, container: d, elevation: h = 8, marginThreshold: p = 16, open: f, PaperProps: m = {}, slots: g = {}, slotProps: v = {}, transformOrigin: y = { vertical: "top", horizontal: "left" }, TransitionComponent: b = So, transitionDuration: x = "auto", TransitionProps: { onEntering: A, ...S } = {}, disableScrollLock: _ = !1, ...E } = r, C = v?.paper ?? m, T = n.useRef(), R = { ...r, anchorOrigin: o, anchorReference: l, elevation: h, marginThreshold: p, externalPaperSlotProps: C, transformOrigin: y, TransitionComponent: b, transitionDuration: x, TransitionProps: S }, B = (e => { const { classes: t } = e; return w({ root: ["root"], paper: ["paper"] }, Xo, t) })(R), I = n.useCallback((() => { if ("anchorPosition" === l) return s; const e = Ko(a), t = (e && 1 === e.nodeType ? e : ja(T.current).body).getBoundingClientRect(); return { top: t.top + Jo(t, o.vertical), left: t.left + Yo(t, o.horizontal) } }), [a, o.horizontal, o.vertical, s, l]), P = n.useCallback((e => ({ vertical: Jo(e, y.vertical), horizontal: Yo(e, y.horizontal) })), [y.horizontal, y.vertical]), L = n.useCallback((e => { const t = { width: e.offsetWidth, height: e.offsetHeight }, n = P(t); if ("none" === l) return { top: null, left: null, transformOrigin: Qo(n) }; const r = I(); let i = r.top - n.vertical, o = r.left - n.horizontal; const s = i + t.height, c = o + t.width, u = $a(Ko(a)), d = u.innerHeight - p, h = u.innerWidth - p; if (null !== p && i < p) { const e = i - p; i -= e, n.vertical += e } else if (null !== p && s > d) { const e = s - d; i -= e, n.vertical += e } if (null !== p && o < p) { const e = o - p; o -= e, n.horizontal += e } else if (c > h) { const e = c - h; o -= e, n.horizontal += e } return { top: `${Math.round(i)}px`, left: `${Math.round(o)}px`, transformOrigin: Qo(n) } }), [a, l, I, P, p]), [D, k] = n.useState(f), N = n.useCallback((() => { const e = T.current; if (!e) return; const t = L(e); null !== t.top && e.style.setProperty("top", t.top), null !== t.left && (e.style.left = t.left), e.style.transformOrigin = t.transformOrigin, k(!0) }), [L]); n.useEffect((() => (_ && window.addEventListener("scroll", N), () => window.removeEventListener("scroll", N))), [a, _, N]), n.useEffect((() => { f && N() })), n.useImperativeHandle(i, (() => f ? { updatePosition: () => { N() } } : null), [f, N]), n.useEffect((() => { if (!f) return; const e = function (e, t = 166) { let n; function r(...r) { clearTimeout(n), n = setTimeout((() => { e.apply(this, r) }), t) } return r.clear = () => { clearTimeout(n) }, r }((() => { N() })), t = $a(a); return t.addEventListener("resize", e), () => { e.clear(), t.removeEventListener("resize", e) } }), [a, f, N]); let F = x; "auto" !== x || b.muiSupportAuto || (F = void 0); const O = d || (a ? ja(Ko(a)).body : void 0), U = { slots: g, slotProps: { ...v, paper: C } }, [z, H] = To("paper", { elementType: Zo, externalForwardedProps: U, additionalProps: { elevation: h, className: M(B.paper, C?.className), style: D ? C.style : { ...C.style, opacity: 0 } }, ownerState: R }), [G, { slotProps: j, ...V }] = To("root", { elementType: qo, externalForwardedProps: U, additionalProps: { slotProps: { backdrop: { invisible: !0 } }, container: O, open: f }, ownerState: R, className: M(B.root, u) }), W = Qi(T, H.ref); return (0, ii.jsx)(G, { ...V, ...(X = G, !("string" == typeof X) && { slotProps: j, disableScrollLock: _ }), ...E, ref: t, children: (0, ii.jsx)(b, { appear: !0, in: f, onEntering: (e, t) => { A && A(e, t), N() }, onExited: () => { k(!1) }, timeout: F, ...S, children: (0, ii.jsx)(z, { ...H, ref: W, children: c }) }) }); var X })); function es(e) { return vi("MuiMenu", e) } yi("MuiMenu", ["root", "paper", "list"]); const ts = { vertical: "top", horizontal: "right" }, ns = { vertical: "top", horizontal: "left" }, rs = ei($o, { shouldForwardProp: e => Zr(e) || "classes" === e, name: "MuiMenu", slot: "Root", overridesResolver: (e, t) => t.root })({}), is = ei(Zo, { name: "MuiMenu", slot: "Paper", overridesResolver: (e, t) => t.paper })({ maxHeight: "calc(100% - 96px)", WebkitOverflowScrolling: "touch" }), as = ei(io, { name: "MuiMenu", slot: "List", overridesResolver: (e, t) => t.list })({ outline: 0 }), os = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiMenu" }), { autoFocus: i = !0, children: a, className: o, disableAutoFocusItem: s = !1, MenuListProps: l = {}, onClose: c, open: u, PaperProps: d = {}, PopoverClasses: h, transitionDuration: p = "auto", TransitionProps: { onEntering: f, ...m } = {}, variant: g = "selectedMenu", slots: v = {}, slotProps: y = {}, ...b } = r, x = n.useContext(Da) ?? !1, A = { ...r, autoFocus: i, disableAutoFocusItem: s, MenuListProps: l, onEntering: f, PaperProps: d, transitionDuration: p, TransitionProps: m, variant: g }, S = (e => { const { classes: t } = e; return w({ root: ["root"], paper: ["paper"], list: ["list"] }, es, t) })(A), _ = i && !s && u, E = n.useRef(null); let C = -1; n.Children.map(a, ((e, t) => { n.isValidElement(e) && (e.props.disabled || ("selectedMenu" === g && e.props.selected || -1 === C) && (C = t)) })); const T = v.paper ?? is, R = y.paper ?? d, B = Ha({ elementType: v.root, externalSlotProps: y.root, ownerState: A, className: [S.root, o] }), I = Ha({ elementType: T, externalSlotProps: R, ownerState: A, className: S.paper }); return (0, ii.jsx)(rs, { onClose: c, anchorOrigin: { vertical: "bottom", horizontal: x ? "right" : "left" }, transformOrigin: x ? ts : ns, slots: { paper: T, root: v.root }, slotProps: { root: B, paper: I }, open: u, ref: t, transitionDuration: p, TransitionProps: { onEntering: (e, t) => { E.current && E.current.adjustStyleForScrollbar(e, { direction: x ? "rtl" : "ltr" }), f && f(e, t) }, ...m }, ownerState: A, ...b, classes: h, children: (0, ii.jsx)(as, { onKeyDown: e => { "Tab" === e.key && (e.preventDefault(), c && c(e, "tabKeyDown")) }, actions: E, autoFocus: i && (-1 === C || s), autoFocusItem: _, variant: g, ...l, className: M(S.list, l.className), children: a }) }) })), ss = yi("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]); function ls(e) { return vi("MuiListItemIcon", e) } const cs = yi("MuiListItemIcon", ["root", "alignItemsFlexStart"]); function us(e) { return vi("MuiListItemText", e) } const ds = yi("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]); function hs(e) { return vi("MuiMenuItem", e) } const ps = yi("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), fs = ei(Ra, { shouldForwardProp: e => Zr(e) || "classes" === e, name: "MuiMenuItem", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters] } })(ni((({ theme: e }) => ({ ...e.typography.body1, display: "flex", justifyContent: "flex-start", alignItems: "center", position: "relative", textDecoration: "none", minHeight: 48, paddingTop: 6, paddingBottom: 6, boxSizing: "border-box", whiteSpace: "nowrap", "&:hover": { textDecoration: "none", backgroundColor: (e.vars || e).palette.action.hover, "@media (hover: none)": { backgroundColor: "transparent" } }, [`&.${ps.selected}`]: { backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : En(e.palette.primary.main, e.palette.action.selectedOpacity), [`&.${ps.focusVisible}`]: { backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : En(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity) } }, [`&.${ps.selected}:hover`]: { backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : En(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : En(e.palette.primary.main, e.palette.action.selectedOpacity) } }, [`&.${ps.focusVisible}`]: { backgroundColor: (e.vars || e).palette.action.focus }, [`&.${ps.disabled}`]: { opacity: (e.vars || e).palette.action.disabledOpacity }, [`& + .${ss.root}`]: { marginTop: e.spacing(1), marginBottom: e.spacing(1) }, [`& + .${ss.inset}`]: { marginLeft: 52 }, [`& .${ds.root}`]: { marginTop: 0, marginBottom: 0 }, [`& .${ds.inset}`]: { paddingLeft: 36 }, [`& .${cs.root}`]: { minWidth: 36 }, variants: [{ props: ({ ownerState: e }) => !e.disableGutters, style: { paddingLeft: 16, paddingRight: 16 } }, { props: ({ ownerState: e }) => e.divider, style: { borderBottom: `1px solid ${(e.vars || e).palette.divider}`, backgroundClip: "padding-box" } }, { props: ({ ownerState: e }) => !e.dense, style: { [e.breakpoints.up("sm")]: { minHeight: "auto" } } }, { props: ({ ownerState: e }) => e.dense, style: { minHeight: 32, paddingTop: 4, paddingBottom: 4, ...e.typography.body2, [`& .${cs.root} svg`]: { fontSize: "1.25rem" } } }] })))), ms = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiMenuItem" }), { autoFocus: i = !1, component: a = "li", dense: o = !1, divider: s = !1, disableGutters: l = !1, focusVisibleClassName: c, role: u = "menuitem", tabIndex: d, className: h, ...p } = r, f = n.useContext(Va), m = n.useMemo((() => ({ dense: o || f.dense || !1, disableGutters: l })), [f.dense, o, l]), g = n.useRef(null); qa((() => { i && g.current && g.current.focus() }), [i]); const v = { ...r, dense: m.dense, divider: s, disableGutters: l }, y = (e => { const { disabled: t, dense: n, divider: r, disableGutters: i, selected: a, classes: o } = e, s = w({ root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", a && "selected"] }, hs, o); return { ...o, ...s } })(r), b = Qi(g, t); let x; return r.disabled || (x = void 0 !== d ? d : -1), (0, ii.jsx)(Va.Provider, { value: m, children: (0, ii.jsx)(fs, { ref: b, role: u, tabIndex: x, component: a, focusVisibleClassName: M(y.focusVisible, c), className: M(y.root, h), ...p, ownerState: v, classes: y }) }) })), gs = ms, vs = ei("div", { name: "MuiListItemIcon", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, "flex-start" === n.alignItems && t.alignItemsFlexStart] } })(ni((({ theme: e }) => ({ minWidth: 56, color: (e.vars || e).palette.action.active, flexShrink: 0, display: "inline-flex", variants: [{ props: { alignItems: "flex-start" }, style: { marginTop: 8 } }] })))), ys = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiListItemIcon" }), { className: i, ...a } = r, o = n.useContext(Va), s = { ...r, alignItems: o.alignItems }, l = (e => { const { alignItems: t, classes: n } = e; return w({ root: ["root", "flex-start" === t && "alignItemsFlexStart"] }, ls, n) })(s); return (0, ii.jsx)(vs, { className: M(l.root, i), ownerState: s, ref: t, ...a }) })), bs = ys, xs = ei("div", { name: "MuiListItemText", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [{ [`& .${ds.primary}`]: t.primary }, { [`& .${ds.secondary}`]: t.secondary }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense] } })({ flex: "1 1 auto", minWidth: 0, marginTop: 4, marginBottom: 4, [`.${Bi.root}:where(& .${ds.primary})`]: { display: "block" }, [`.${Bi.root}:where(& .${ds.secondary})`]: { display: "block" }, variants: [{ props: ({ ownerState: e }) => e.primary && e.secondary, style: { marginTop: 6, marginBottom: 6 } }, { props: ({ ownerState: e }) => e.inset, style: { paddingLeft: 56 } }] }), As = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiListItemText" }), { children: i, className: a, disableTypography: o = !1, inset: s = !1, primary: l, primaryTypographyProps: c, secondary: u, secondaryTypographyProps: d, ...h } = r, { dense: p } = n.useContext(Va); let f = null != l ? l : i, m = u; const g = { ...r, disableTypography: o, inset: s, primary: !!f, secondary: !!m, dense: p }, v = (e => { const { classes: t, inset: n, primary: r, secondary: i, dense: a } = e; return w({ root: ["root", n && "inset", a && "dense", r && i && "multiline"], primary: ["primary"], secondary: ["secondary"] }, us, t) })(g); return null == f || f.type === ki || o || (f = (0, ii.jsx)(ki, { variant: p ? "body2" : "body1", className: v.primary, component: c?.variant ? void 0 : "span", ...c, children: f })), null == m || m.type === ki || o || (m = (0, ii.jsx)(ki, { variant: "body2", className: v.secondary, color: "textSecondary", ...d, children: m })), (0, ii.jsxs)(xs, { className: M(v.root, a), ownerState: g, ref: t, ...h, children: [f, m] }) })); let Ss = 0; const Ms = { ...r }.useId; function ws(e) { return vi("MuiDialog", e) } const _s = yi("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]), Es = n.createContext({}), Cs = ei(Do, { name: "MuiDialog", slot: "Backdrop", overrides: (e, t) => t.backdrop })({ zIndex: -1 }), Ts = ei(Wo, { name: "MuiDialog", slot: "Root", overridesResolver: (e, t) => t.root })({ "@media print": { position: "absolute !important" } }), Rs = ei("div", { name: "MuiDialog", slot: "Container", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.container, t[`scroll${li(n.scroll)}`]] } })({ height: "100%", "@media print": { height: "auto" }, outline: 0, variants: [{ props: { scroll: "paper" }, style: { display: "flex", justifyContent: "center", alignItems: "center" } }, { props: { scroll: "body" }, style: { overflowY: "auto", overflowX: "hidden", textAlign: "center", "&::after": { content: '""', display: "inline-block", verticalAlign: "middle", height: "100%", width: "0" } } }] }), Bs = ei(Si, { name: "MuiDialog", slot: "Paper", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.paper, t[`scrollPaper${li(n.scroll)}`], t[`paperWidth${li(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen] } })(ni((({ theme: e }) => ({ margin: 32, position: "relative", overflowY: "auto", "@media print": { overflowY: "visible", boxShadow: "none" }, variants: [{ props: { scroll: "paper" }, style: { display: "flex", flexDirection: "column", maxHeight: "calc(100% - 64px)" } }, { props: { scroll: "body" }, style: { display: "inline-block", verticalAlign: "middle", textAlign: "initial" } }, { props: ({ ownerState: e }) => !e.maxWidth, style: { maxWidth: "calc(100% - 64px)" } }, { props: { maxWidth: "xs" }, style: { maxWidth: "px" === e.breakpoints.unit ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`, [`&.${_s.paperScrollBody}`]: { [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 64)]: { maxWidth: "calc(100% - 64px)" } } } }, ...Object.keys(e.breakpoints.values).filter((e => "xs" !== e)).map((t => ({ props: { maxWidth: t }, style: { maxWidth: `${e.breakpoints.values[t]}${e.breakpoints.unit}`, [`&.${_s.paperScrollBody}`]: { [e.breakpoints.down(e.breakpoints.values[t] + 64)]: { maxWidth: "calc(100% - 64px)" } } } }))), { props: ({ ownerState: e }) => e.fullWidth, style: { width: "calc(100% - 64px)" } }, { props: ({ ownerState: e }) => e.fullScreen, style: { margin: 0, width: "100%", maxWidth: "100%", height: "100%", maxHeight: "none", borderRadius: 0, [`&.${_s.paperScrollBody}`]: { margin: 0, maxWidth: "100%" } } }] })))), Is = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiDialog" }), i = pi(), a = { enter: i.transitions.duration.enteringScreen, exit: i.transitions.duration.leavingScreen }, { "aria-describedby": o, "aria-labelledby": s, BackdropComponent: l, BackdropProps: c, children: u, className: d, disableEscapeKeyDown: h = !1, fullScreen: p = !1, fullWidth: f = !1, maxWidth: m = "sm", onBackdropClick: g, onClick: v, onClose: y, open: b, PaperComponent: x = Si, PaperProps: A = {}, scroll: S = "paper", TransitionComponent: _ = Io, transitionDuration: E = a, TransitionProps: C, ...T } = r, R = { ...r, disableEscapeKeyDown: h, fullScreen: p, fullWidth: f, maxWidth: m, scroll: S }, B = (e => { const { classes: t, scroll: n, maxWidth: r, fullWidth: i, fullScreen: a } = e; return w({ root: ["root"], container: ["container", `scroll${li(n)}`], paper: ["paper", `paperScroll${li(n)}`, `paperWidth${li(String(r))}`, i && "paperFullWidth", a && "paperFullScreen"] }, ws, t) })(R), I = n.useRef(), P = function (e) { if (void 0 !== Ms) { const t = Ms(); return e ?? t } return function (e) { const [t, r] = n.useState(e), i = e || t; return n.useEffect((() => { null == t && (Ss += 1, r(`mui-${Ss}`)) }), [t]), i }(e) }(s), L = n.useMemo((() => ({ titleId: P })), [P]); return (0, ii.jsx)(Ts, { className: M(B.root, d), closeAfterTransition: !0, components: { Backdrop: Cs }, componentsProps: { backdrop: { transitionDuration: E, as: l, ...c } }, disableEscapeKeyDown: h, onClose: y, open: b, ref: t, onClick: e => { v && v(e), I.current && (I.current = null, g && g(e), y && y(e, "backdropClick")) }, ownerState: R, ...T, children: (0, ii.jsx)(_, { appear: !0, in: b, timeout: E, role: "presentation", ...C, children: (0, ii.jsx)(Rs, { className: M(B.container), onMouseDown: e => { I.current = e.target === e.currentTarget }, ownerState: R, children: (0, ii.jsx)(Bs, { as: x, elevation: 24, role: "dialog", "aria-describedby": o, "aria-labelledby": P, ...A, className: M(B.paper, A.className), ownerState: R, children: (0, ii.jsx)(Es.Provider, { value: L, children: u }) }) }) }) }) })), Ps = Is; function Ls(e) { return vi("MuiDialogTitle", e) } const Ds = yi("MuiDialogTitle", ["root"]), ks = ei(ki, { name: "MuiDialogTitle", slot: "Root", overridesResolver: (e, t) => t.root })({ padding: "16px 24px", flex: "0 0 auto" }), Ns = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiDialogTitle" }), { className: i, id: a, ...o } = r, s = r, l = (e => { const { classes: t } = e; return w({ root: ["root"] }, Ls, t) })(s), { titleId: c = a } = n.useContext(Es); return (0, ii.jsx)(ks, { component: "h2", className: M(l.root, i), ownerState: s, ref: t, variant: "h6", id: a ?? c, ...o }) })); function Fs(e) { return vi("MuiDialogContent", e) } yi("MuiDialogContent", ["root", "dividers"]); const Os = ei("div", { name: "MuiDialogContent", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, n.dividers && t.dividers] } })(ni((({ theme: e }) => ({ flex: "1 1 auto", WebkitOverflowScrolling: "touch", overflowY: "auto", padding: "20px 24px", variants: [{ props: ({ ownerState: e }) => e.dividers, style: { padding: "16px 24px", borderTop: `1px solid ${(e.vars || e).palette.divider}`, borderBottom: `1px solid ${(e.vars || e).palette.divider}` } }, { props: ({ ownerState: e }) => !e.dividers, style: { [`.${Ds.root} + &`]: { paddingTop: 0 } } }] })))), Us = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiDialogContent" }), { className: r, dividers: i = !1, ...a } = n, o = { ...n, dividers: i }, s = (e => { const { classes: t, dividers: n } = e; return w({ root: ["root", n && "dividers"] }, Fs, t) })(o); return (0, ii.jsx)(Os, { className: M(s.root, r), ownerState: o, ref: t, ...a }) })); function zs(e) { return vi("MuiDialogContentText", e) } yi("MuiDialogContentText", ["root"]); const Hs = ei(ki, { shouldForwardProp: e => Zr(e) || "classes" === e, name: "MuiDialogContentText", slot: "Root", overridesResolver: (e, t) => t.root })({}), Gs = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiDialogContentText" }), { children: r, className: i, ...a } = n, o = (e => { const { classes: t } = e, n = w({ root: ["root"] }, zs, t); return { ...t, ...n } })(a); return (0, ii.jsx)(Hs, { component: "p", variant: "body1", color: "textSecondary", ref: t, ownerState: a, className: M(o.root, i), ...n, classes: o }) })); function js(e) { return vi("MuiDialogActions", e) } yi("MuiDialogActions", ["root", "spacing"]); const Vs = ei("div", { name: "MuiDialogActions", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, !n.disableSpacing && t.spacing] } })({ display: "flex", alignItems: "center", padding: 8, justifyContent: "flex-end", flex: "0 0 auto", variants: [{ props: ({ ownerState: e }) => !e.disableSpacing, style: { "& > :not(style) ~ :not(style)": { marginLeft: 8 } } }] }), Ws = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiDialogActions" }), { className: r, disableSpacing: i = !1, ...a } = n, o = { ...n, disableSpacing: i }, s = (e => { const { classes: t, disableSpacing: n } = e; return w({ root: ["root", !n && "spacing"] }, js, t) })(o); return (0, ii.jsx)(Vs, { className: M(s.root, r), ownerState: o, ref: t, ...a }) })); function Xs(e) { return vi("MuiButton", e) } const Js = yi("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), Ys = n.createContext({}), Qs = n.createContext(void 0), Ks = [{ props: { size: "small" }, style: { "& > *:nth-of-type(1)": { fontSize: 18 } } }, { props: { size: "medium" }, style: { "& > *:nth-of-type(1)": { fontSize: 20 } } }, { props: { size: "large" }, style: { "& > *:nth-of-type(1)": { fontSize: 22 } } }], qs = ei(Ra, { shouldForwardProp: e => Zr(e) || "classes" === e, name: "MuiButton", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, t[n.variant], t[`${n.variant}${li(n.color)}`], t[`size${li(n.size)}`], t[`${n.variant}Size${li(n.size)}`], "inherit" === n.color && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth] } })(ni((({ theme: e }) => { const t = "light" === e.palette.mode ? e.palette.grey[300] : e.palette.grey[800], n = "light" === e.palette.mode ? e.palette.grey.A100 : e.palette.grey[700]; return { ...e.typography.button, minWidth: 64, padding: "6px 16px", border: 0, borderRadius: (e.vars || e).shape.borderRadius, transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], { duration: e.transitions.duration.short }), "&:hover": { textDecoration: "none" }, [`&.${Js.disabled}`]: { color: (e.vars || e).palette.action.disabled }, variants: [{ props: { variant: "contained" }, style: { color: "var(--variant-containedColor)", backgroundColor: "var(--variant-containedBg)", boxShadow: (e.vars || e).shadows[2], "&:hover": { boxShadow: (e.vars || e).shadows[4], "@media (hover: none)": { boxShadow: (e.vars || e).shadows[2] } }, "&:active": { boxShadow: (e.vars || e).shadows[8] }, [`&.${Js.focusVisible}`]: { boxShadow: (e.vars || e).shadows[6] }, [`&.${Js.disabled}`]: { color: (e.vars || e).palette.action.disabled, boxShadow: (e.vars || e).shadows[0], backgroundColor: (e.vars || e).palette.action.disabledBackground } } }, { props: { variant: "outlined" }, style: { padding: "5px 15px", border: "1px solid currentColor", borderColor: "var(--variant-outlinedBorder, currentColor)", backgroundColor: "var(--variant-outlinedBg)", color: "var(--variant-outlinedColor)", [`&.${Js.disabled}`]: { border: `1px solid ${(e.vars || e).palette.action.disabledBackground}` } } }, { props: { variant: "text" }, style: { padding: "6px 8px", color: "var(--variant-textColor)", backgroundColor: "var(--variant-textBg)" } }, ...Object.entries(e.palette).filter(ci()).map((([t]) => ({ props: { color: t }, style: { "--variant-textColor": (e.vars || e).palette[t].main, "--variant-outlinedColor": (e.vars || e).palette[t].main, "--variant-outlinedBorder": e.vars ? `rgba(${e.vars.palette[t].mainChannel} / 0.5)` : En(e.palette[t].main, .5), "--variant-containedColor": (e.vars || e).palette[t].contrastText, "--variant-containedBg": (e.vars || e).palette[t].main, "@media (hover: hover)": { "&:hover": { "--variant-containedBg": (e.vars || e).palette[t].dark, "--variant-textBg": e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : En(e.palette[t].main, e.palette.action.hoverOpacity), "--variant-outlinedBorder": (e.vars || e).palette[t].main, "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : En(e.palette[t].main, e.palette.action.hoverOpacity) } } } }))), { props: { color: "inherit" }, style: { color: "inherit", borderColor: "currentColor", "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t, "@media (hover: hover)": { "&:hover": { "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n, "--variant-textBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : En(e.palette.text.primary, e.palette.action.hoverOpacity), "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : En(e.palette.text.primary, e.palette.action.hoverOpacity) } } } }, { props: { size: "small", variant: "text" }, style: { padding: "4px 5px", fontSize: e.typography.pxToRem(13) } }, { props: { size: "large", variant: "text" }, style: { padding: "8px 11px", fontSize: e.typography.pxToRem(15) } }, { props: { size: "small", variant: "outlined" }, style: { padding: "3px 9px", fontSize: e.typography.pxToRem(13) } }, { props: { size: "large", variant: "outlined" }, style: { padding: "7px 21px", fontSize: e.typography.pxToRem(15) } }, { props: { size: "small", variant: "contained" }, style: { padding: "4px 10px", fontSize: e.typography.pxToRem(13) } }, { props: { size: "large", variant: "contained" }, style: { padding: "8px 22px", fontSize: e.typography.pxToRem(15) } }, { props: { disableElevation: !0 }, style: { boxShadow: "none", "&:hover": { boxShadow: "none" }, [`&.${Js.focusVisible}`]: { boxShadow: "none" }, "&:active": { boxShadow: "none" }, [`&.${Js.disabled}`]: { boxShadow: "none" } } }, { props: { fullWidth: !0 }, style: { width: "100%" } }] } }))), Zs = ei("span", { name: "MuiButton", slot: "StartIcon", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.startIcon, t[`iconSize${li(n.size)}`]] } })({ display: "inherit", marginRight: 8, marginLeft: -4, variants: [{ props: { size: "small" }, style: { marginLeft: -2 } }, ...Ks] }), $s = ei("span", { name: "MuiButton", slot: "EndIcon", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.endIcon, t[`iconSize${li(n.size)}`]] } })({ display: "inherit", marginRight: -4, marginLeft: 8, variants: [{ props: { size: "small" }, style: { marginRight: -2 } }, ...Ks] }), el = n.forwardRef((function (e, t) { const r = n.useContext(Ys), i = n.useContext(Qs), a = si({ props: ri(r, e), name: "MuiButton" }), { children: o, color: s = "primary", component: l = "button", className: c, disabled: u = !1, disableElevation: d = !1, disableFocusRipple: h = !1, endIcon: p, focusVisibleClassName: f, fullWidth: m = !1, size: g = "medium", startIcon: v, type: y, variant: b = "text", ...x } = a, A = { ...a, color: s, component: l, disabled: u, disableElevation: d, disableFocusRipple: h, fullWidth: m, size: g, type: y, variant: b }, S = (e => { const { color: t, disableElevation: n, fullWidth: r, size: i, variant: a, classes: o } = e, s = w({ root: ["root", a, `${a}${li(t)}`, `size${li(i)}`, `${a}Size${li(i)}`, `color${li(t)}`, n && "disableElevation", r && "fullWidth"], label: ["label"], startIcon: ["icon", "startIcon", `iconSize${li(i)}`], endIcon: ["icon", "endIcon", `iconSize${li(i)}`] }, Xs, o); return { ...o, ...s } })(A), _ = v && (0, ii.jsx)(Zs, { className: S.startIcon, ownerState: A, children: v }), E = p && (0, ii.jsx)($s, { className: S.endIcon, ownerState: A, children: p }), C = i || ""; return (0, ii.jsxs)(qs, { ownerState: A, className: M(r.className, S.root, c, C), component: l, disabled: u, focusRipple: !h, focusVisibleClassName: M(S.focusVisible, f), ref: t, type: y, ...x, classes: S, children: [_, o, E] }) })); function tl(e) { return vi("MuiSvgIcon", e) } yi("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]); const nl = ei("svg", { name: "MuiSvgIcon", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, "inherit" !== n.color && t[`color${li(n.color)}`], t[`fontSize${li(n.fontSize)}`]] } })(ni((({ theme: e }) => ({ userSelect: "none", width: "1em", height: "1em", display: "inline-block", flexShrink: 0, transition: e.transitions?.create?.("fill", { duration: (e.vars ?? e).transitions?.duration?.shorter }), variants: [{ props: e => !e.hasSvgAsChild, style: { fill: "currentColor" } }, { props: { fontSize: "inherit" }, style: { fontSize: "inherit" } }, { props: { fontSize: "small" }, style: { fontSize: e.typography?.pxToRem?.(20) || "1.25rem" } }, { props: { fontSize: "medium" }, style: { fontSize: e.typography?.pxToRem?.(24) || "1.5rem" } }, { props: { fontSize: "large" }, style: { fontSize: e.typography?.pxToRem?.(35) || "2.1875rem" } }, ...Object.entries((e.vars ?? e).palette).filter((([, e]) => e && e.main)).map((([t]) => ({ props: { color: t }, style: { color: (e.vars ?? e).palette?.[t]?.main } }))), { props: { color: "action" }, style: { color: (e.vars ?? e).palette?.action?.active } }, { props: { color: "disabled" }, style: { color: (e.vars ?? e).palette?.action?.disabled } }, { props: { color: "inherit" }, style: { color: void 0 } }] })))), rl = n.forwardRef((function (e, t) { const r = si({ props: e, name: "MuiSvgIcon" }), { children: i, className: a, color: o = "inherit", component: s = "svg", fontSize: l = "medium", htmlColor: c, inheritViewBox: u = !1, titleAccess: d, viewBox: h = "0 0 24 24", ...p } = r, f = n.isValidElement(i) && "svg" === i.type, m = { ...r, color: o, component: s, fontSize: l, instanceFontSize: e.fontSize, inheritViewBox: u, viewBox: h, hasSvgAsChild: f }, g = {}; u || (g.viewBox = h); const v = (e => { const { color: t, fontSize: n, classes: r } = e; return w({ root: ["root", "inherit" !== t && `color${li(t)}`, `fontSize${li(n)}`] }, tl, r) })(m); return (0, ii.jsxs)(nl, { as: s, className: M(v.root, a), focusable: "false", color: c, "aria-hidden": !d || void 0, role: d ? "img" : void 0, ref: t, ...g, ...p, ...f && i.props, ownerState: m, children: [f ? i.props.children : i, d ? (0, ii.jsx)("title", { children: d }) : null] }) })); rl && (rl.muiName = "SvgIcon"); const il = rl; function al(e, t) { function r(n, r) { return (0, ii.jsx)(il, { "data-testid": `${t}Icon`, ref: r, ...n, children: e }) } return r.muiName = il.muiName, n.memo(n.forwardRef(r)) } const ol = al((0, ii.jsx)("path", { d: "M3 18h18v-2H3zm0-5h18v-2H3zm0-7v2h18V6z" }), "Menu"), sl = al((0, ii.jsx)("path", { d: "m5.2494 8.0688 2.83-2.8269 14.1343 14.15-2.83 2.8269zm4.2363-4.2415 2.828-2.8289 5.6577 5.656-2.828 2.8289zM.9989 12.3147l2.8284-2.8285 5.6569 5.6569-2.8285 2.8284zM1 21h12v2H1z" }), "Gavel"), ll = al((0, ii.jsx)("path", { d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" }), "Home"), cl = al((0, ii.jsx)("path", { d: "M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27" }), "GitHub"); function ul(e) { const [t, r] = (0, n.useState)(!1), [i, a] = (0, n.useState)(null); return (0, ii.jsxs)(Ci, { className: x.topBarContainer, style: { height: 40, justifyContent: "space-between", alignItems: "center", flexDirection: "row" }, children: [(0, ii.jsxs)(Xi, { sx: { flexGrow: 1 }, children: [(0, ii.jsx)(La, { edge: "start", onClick: e => { a(e.currentTarget) }, children: (0, ii.jsx)(ol, {}) }), (0, ii.jsxs)(os, { id: "menu-appbar", anchorEl: i, open: Boolean(i), onClose: () => a(null), children: [e.showBack && (0, ii.jsxs)(gs, { onClick: () => { e.back(), a(null) }, children: [(0, ii.jsx)(bs, { children: (0, ii.jsx)(ll, { fontSize: "small" }) }), (0, ii.jsx)(As, { children: "Home" })] }), (0, ii.jsxs)(gs, { onClick: () => { r(!0), a(null) }, children: [(0, ii.jsx)(bs, { children: (0, ii.jsx)(sl, { fontSize: "small" }) }), (0, ii.jsx)(As, { children: "Rules" })] })] }), (0, ii.jsx)(ki, { sx: { flexGrow: 1, ml: 5 }, variant: "h6", children: "Block Game Clone" }), (0, ii.jsxs)(ji, { sx: { margin: 1, display: "flex", alignItems: "center", justifyContent: "center" }, href: "https://github.com/ethanSE/block_game_clone", underline: "hover", children: [(0, ii.jsx)(cl, { sx: { mr: 1 } }), "GitHub"] })] }), (0, ii.jsxs)(Ps, { open: t, onClose: () => { r(!1), a(null) }, "aria-labelledby": "modal-modal-title", "aria-describedby": "modal-modal-description", scroll: "paper", children: [(0, ii.jsx)(Ns, { children: "How To Play" }), (0, ii.jsxs)(Us, { dividers: !0, children: [(0, ii.jsx)(Ns, { children: "Rules:" }), (0, ii.jsx)(Gs, { tabIndex: -1, children: "Players take turns placing pieces on the game board. The first player is free to play anywhere. The second player must touch the first player's piece. After this, players much touch their own piece with every play. Pieces must be placed on the game board and within the height limits. All cubes within a piece must be supported." }), (0, ii.jsx)(Ns, { children: "Making a Move:" }), (0, ii.jsx)(Gs, { children: "1. Select a piece from the bottom piece selector" }), (0, ii.jsx)(Gs, { children: "2. Select a cube to the pick the piece up by" }), (0, ii.jsx)(Gs, { children: "3. Rotate the piece using the rotate controls" }), (0, ii.jsx)(Gs, { children: "4. Place the piece on the game board" }), (0, ii.jsx)(Gs, { children: "5. Hit the play button" }), (0, ii.jsx)(Ns, { children: "Scoring:" }), (0, ii.jsx)(Gs, { children: "A player's score is the number of their cubes visible from the top down. The player with the highest score once all piece are played or no more moves can be made wins." })] }), (0, ii.jsx)(Ws, { children: (0, ii.jsx)(el, { onClick: () => r(!1), children: "Close" }) })] })] }) } const dl = "169", hl = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, pl = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, fl = 0, ml = 1, gl = 2, vl = 3, yl = 0, bl = 1, xl = 2, Al = 3, Sl = 0, Ml = 1, wl = 2, _l = 0, El = 1, Cl = 2, Tl = 3, Rl = 4, Bl = 5, Il = 100, Pl = 101, Ll = 102, Dl = 103, kl = 104, Nl = 200, Fl = 201, Ol = 202, Ul = 203, zl = 204, Hl = 205, Gl = 206, jl = 207, Vl = 208, Wl = 209, Xl = 210, Jl = 211, Yl = 212, Ql = 213, Kl = 214, ql = 0, Zl = 1, $l = 2, ec = 3, tc = 4, nc = 5, rc = 6, ic = 7, ac = 0, oc = 1, sc = 2, lc = 0, cc = 1, uc = 2, dc = 3, hc = 4, pc = 5, fc = 6, mc = 7, gc = "attached", vc = "detached", yc = 300, bc = 301, xc = 302, Ac = 303, Sc = 304, Mc = 306, wc = 1e3, _c = 1001, Ec = 1002, Cc = 1003, Tc = 1004, Rc = 1004, Bc = 1005, Ic = 1005, Pc = 1006, Lc = 1007, Dc = 1007, kc = 1008, Nc = 1008, Fc = 1009, Oc = 1010, Uc = 1011, zc = 1012, Hc = 1013, Gc = 1014, jc = 1015, Vc = 1016, Wc = 1017, Xc = 1018, Jc = 1020, Yc = 35902, Qc = 1021, Kc = 1022, qc = 1023, Zc = 1024, $c = 1025, eu = 1026, tu = 1027, nu = 1028, ru = 1029, iu = 1030, au = 1031, ou = 1032, su = 1033, lu = 33776, cu = 33777, uu = 33778, du = 33779, hu = 35840, pu = 35841, fu = 35842, mu = 35843, gu = 36196, vu = 37492, yu = 37496, bu = 37808, xu = 37809, Au = 37810, Su = 37811, Mu = 37812, wu = 37813, _u = 37814, Eu = 37815, Cu = 37816, Tu = 37817, Ru = 37818, Bu = 37819, Iu = 37820, Pu = 37821, Lu = 36492, Du = 36494, ku = 36495, Nu = 36283, Fu = 36284, Ou = 36285, Uu = 36286, zu = 2200, Hu = 2201, Gu = 2202, ju = 2300, Vu = 2301, Wu = 2302, Xu = 2400, Ju = 2401, Yu = 2402, Qu = 2500, Ku = 2501, qu = 0, Zu = 1, $u = 2, ed = 3200, td = 3201, nd = 3202, rd = 3203, id = 0, ad = 1, od = "", sd = "srgb", ld = "srgb-linear", cd = "display-p3", ud = "display-p3-linear", dd = "linear", hd = "srgb", pd = "rec709", fd = "p3", md = 0, gd = 7680, vd = 7681, yd = 7682, bd = 7683, xd = 34055, Ad = 34056, Sd = 5386, Md = 512, wd = 513, _d = 514, Ed = 515, Cd = 516, Td = 517, Rd = 518, Bd = 519, Id = 512, Pd = 513, Ld = 514, Dd = 515, kd = 516, Nd = 517, Fd = 518, Od = 519, Ud = 35044, zd = 35048, Hd = 35040, Gd = 35045, jd = 35049, Vd = 35041, Wd = 35046, Xd = 35050, Jd = 35042, Yd = "100", Qd = "300 es", Kd = 2e3, qd = 2001; class Zd { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const n = t.slice(0); for (let t = 0, r = n.length; t < r; t++)n[t].call(this, e); e.target = null } } } const $d = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let eh = 1234567; const th = Math.PI / 180, nh = 180 / Math.PI; function rh() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return ($d[255 & e] + $d[e >> 8 & 255] + $d[e >> 16 & 255] + $d[e >> 24 & 255] + "-" + $d[255 & t] + $d[t >> 8 & 255] + "-" + $d[t >> 16 & 15 | 64] + $d[t >> 24 & 255] + "-" + $d[63 & n | 128] + $d[n >> 8 & 255] + "-" + $d[n >> 16 & 255] + $d[n >> 24 & 255] + $d[255 & r] + $d[r >> 8 & 255] + $d[r >> 16 & 255] + $d[r >> 24 & 255]).toLowerCase() } function ih(e, t, n) { return Math.max(t, Math.min(n, e)) } function ah(e, t) { return (e % t + t) % t } function oh(e, t, n) { return (1 - n) * e + n * t } function sh(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return e / 4294967295; case Uint16Array: return e / 65535; case Uint8Array: return e / 255; case Int32Array: return Math.max(e / 2147483647, -1); case Int16Array: return Math.max(e / 32767, -1); case Int8Array: return Math.max(e / 127, -1); default: throw new Error("Invalid component type.") } } function lh(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return Math.round(4294967295 * e); case Uint16Array: return Math.round(65535 * e); case Uint8Array: return Math.round(255 * e); case Int32Array: return Math.round(2147483647 * e); case Int16Array: return Math.round(32767 * e); case Int8Array: return Math.round(127 * e); default: throw new Error("Invalid component type.") } } const ch = { DEG2RAD: th, RAD2DEG: nh, generateUUID: rh, clamp: ih, euclideanModulo: ah, mapLinear: function (e, t, n, r, i) { return r + (e - t) * (i - r) / (n - t) }, inverseLerp: function (e, t, n) { return e !== t ? (n - e) / (t - e) : 0 }, lerp: oh, damp: function (e, t, n, r) { return oh(e, t, 1 - Math.exp(-n * r)) }, pingpong: function (e, t = 1) { return t - Math.abs(ah(e, 2 * t) - t) }, smoothstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { void 0 !== e && (eh = e); let t = eh += 1831565813; return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296 }, degToRad: function (e) { return e * th }, radToDeg: function (e) { return e * nh }, isPowerOfTwo: function (e) { return !(e & e - 1) && 0 !== e }, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function (e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, setQuaternionFromProperEuler: function (e, t, n, r, i) { const a = Math.cos, o = Math.sin, s = a(n / 2), l = o(n / 2), c = a((t + r) / 2), u = o((t + r) / 2), d = a((t - r) / 2), h = o((t - r) / 2), p = a((r - t) / 2), f = o((r - t) / 2); switch (i) { case "XYX": e.set(s * u, l * d, l * h, s * c); break; case "YZY": e.set(l * h, s * u, l * d, s * c); break; case "ZXZ": e.set(l * d, l * h, s * u, s * c); break; case "XZX": e.set(s * u, l * f, l * p, s * c); break; case "YXY": e.set(l * p, s * u, l * f, s * c); break; case "ZYZ": e.set(l * f, l * p, s * u, s * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } }, normalize: lh, denormalize: sh }; class uh { constructor(e = 0, t = 0) { uh.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, n = this.y, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(ih(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y; return t * t + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const n = Math.cos(t), r = Math.sin(t), i = this.x - e.x, a = this.y - e.y; return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class dh { constructor(e, t, n, r, i, a, o, s, l) { dh.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, r, i, a, o, s, l) } set(e, t, n, r, i, a, o, s, l) { const c = this.elements; return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, i = this.elements, a = n[0], o = n[3], s = n[6], l = n[1], c = n[4], u = n[7], d = n[2], h = n[5], p = n[8], f = r[0], m = r[3], g = r[6], v = r[1], y = r[4], b = r[7], x = r[2], A = r[5], S = r[8]; return i[0] = a * f + o * v + s * x, i[3] = a * m + o * y + s * A, i[6] = a * g + o * b + s * S, i[1] = l * f + c * v + u * x, i[4] = l * m + c * y + u * A, i[7] = l * g + c * b + u * S, i[2] = d * f + h * v + p * x, i[5] = d * m + h * y + p * A, i[8] = d * g + h * b + p * S, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8]; return t * a * c - t * o * l - n * i * c + n * o * s + r * i * l - r * a * s } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8], u = c * a - o * l, d = o * s - c * i, h = l * i - a * s, p = t * u + n * d + r * h; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * a) * f, e[3] = d * f, e[4] = (c * t - r * s) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * s - l * t) * f, e[8] = (a * t - n * i) * f, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, r, i, a, o) { const s = Math.cos(i), l = Math.sin(i); return this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(hh.makeScale(e, t)), this } rotate(e) { return this.premultiply(hh.makeRotation(-e)), this } translate(e, t) { return this.premultiply(hh.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } const hh = new dh; function ph(e) { for (let t = e.length - 1; t >= 0; --t)if (e[t] >= 65535) return !0; return !1 } const fh = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function mh(e, t) { return new fh[e](t) } function gh(e) { return document.createElementNS("http://www.w3.org/1999/xhtml", e) } function vh() { const e = gh("canvas"); return e.style.display = "block", e } const yh = {}; function bh(e) { e in yh || (yh[e] = !0, console.warn(e)) } const xh = (new dh).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199), Ah = (new dh).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735), Sh = { [ld]: { transfer: dd, primaries: pd, luminanceCoefficients: [.2126, .7152, .0722], toReference: e => e, fromReference: e => e }, [sd]: { transfer: hd, primaries: pd, luminanceCoefficients: [.2126, .7152, .0722], toReference: e => e.convertSRGBToLinear(), fromReference: e => e.convertLinearToSRGB() }, [ud]: { transfer: dd, primaries: fd, luminanceCoefficients: [.2289, .6917, .0793], toReference: e => e.applyMatrix3(Ah), fromReference: e => e.applyMatrix3(xh) }, [cd]: { transfer: hd, primaries: fd, luminanceCoefficients: [.2289, .6917, .0793], toReference: e => e.convertSRGBToLinear().applyMatrix3(Ah), fromReference: e => e.applyMatrix3(xh).convertLinearToSRGB() } }, Mh = new Set([ld, ud]), wh = { enabled: !0, _workingColorSpace: ld, get workingColorSpace() { return this._workingColorSpace }, set workingColorSpace(e) { if (!Mh.has(e)) throw new Error(`Unsupported working color space, "${e}".`); this._workingColorSpace = e }, convert: function (e, t, n) { if (!1 === this.enabled || t === n || !t || !n) return e; const r = Sh[t].toReference; return (0, Sh[n].fromReference)(r(e)) }, fromWorkingColorSpace: function (e, t) { return this.convert(e, this._workingColorSpace, t) }, toWorkingColorSpace: function (e, t) { return this.convert(e, t, this._workingColorSpace) }, getPrimaries: function (e) { return Sh[e].primaries }, getTransfer: function (e) { return e === od ? dd : Sh[e].transfer }, getLuminanceCoefficients: function (e, t = this._workingColorSpace) { return e.fromArray(Sh[t].luminanceCoefficients) } }; function _h(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function Eh(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } let Ch; class Th { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === Ch && (Ch = gh("canvas")), Ch.width = e.width, Ch.height = e.height; const n = Ch.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Ch } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const t = gh("canvas"); t.width = e.width, t.height = e.height; const n = t.getContext("2d"); n.drawImage(e, 0, 0, e.width, e.height); const r = n.getImageData(0, 0, e.width, e.height), i = r.data; for (let e = 0; e < i.length; e++)i[e] = 255 * _h(i[e] / 255); return n.putImageData(r, 0, 0), t } if (e.data) { const t = e.data.slice(0); for (let e = 0; e < t.length; e++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * _h(t[e] / 255)) : t[e] = _h(t[e]); return { data: t, width: e.width, height: e.height } } return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let Rh = 0; class Bh { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: Rh++ }), this.uuid = rh(), this.data = e, this.dataReady = !0, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid]; const n = { uuid: this.uuid, url: "" }, r = this.data; if (null !== r) { let e; if (Array.isArray(r)) { e = []; for (let t = 0, n = r.length; t < n; t++)r[t].isDataTexture ? e.push(Ih(r[t].image)) : e.push(Ih(r[t])) } else e = Ih(r); n.url = e } return t || (e.images[this.uuid] = n), n } } function Ih(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Th.getDataURL(e) : e.data ? { data: Array.from(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let Ph = 0; class Lh extends Zd { constructor(e = Lh.DEFAULT_IMAGE, t = Lh.DEFAULT_MAPPING, n = _c, r = _c, i = Pc, a = kc, o = qc, s = Fc, l = Lh.DEFAULT_ANISOTROPY, c = od) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Ph++ }), this.uuid = rh(), this.name = "", this.source = new Bh(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new uh(0, 0), this.repeat = new uh(1, 1), this.center = new uh(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new dh, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const n = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== yc) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case wc: e.x = e.x - Math.floor(e.x); break; case _c: e.x = e.x < 0 ? 0 : 1; break; case Ec: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case wc: e.y = e.y - Math.floor(e.y); break; case _c: e.y = e.y < 0 ? 0 : 1; break; case Ec: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && (this.version++, this.source.needsUpdate = !0) } set needsPMREMUpdate(e) { !0 === e && this.pmremVersion++ } } Lh.DEFAULT_IMAGE = null, Lh.DEFAULT_MAPPING = yc, Lh.DEFAULT_ANISOTROPY = 1; class Dh { constructor(e = 0, t = 0, n = 0, r = 1) { Dh.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, r) { return this.x = e, this.y = t, this.z = n, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, n = this.y, r = this.z, i = this.w, a = e.elements; return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, r, i; const a = .01, o = .1, s = e.elements, l = s[0], c = s[4], u = s[8], d = s[1], h = s[5], p = s[9], f = s[2], m = s[6], g = s[10]; if (Math.abs(c - d) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) { if (Math.abs(c + d) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + h + g - 3) < o) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (l + 1) / 2, s = (h + 1) / 2, v = (g + 1) / 2, y = (c + d) / 4, b = (u + f) / 4, x = (p + m) / 4; return e > s && e > v ? e < a ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(e), r = y / n, i = b / n) : s > v ? s < a ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(s), n = y / r, i = x / r) : v < a ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = b / i, r = x / i), this.set(n, r, i, t), this } let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (d - c) * (d - c)); return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (d - c) / v, this.w = Math.acos((l + h + g - 1) / 2), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class kh extends Zd { constructor(e = 1, t = 1, n = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Dh(0, 0, e, t), this.scissorTest = !1, this.viewport = new Dh(0, 0, e, t); const r = { width: e, height: t, depth: 1 }; n = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: Pc, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, n); const i = new Lh(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace); i.flipY = !1, i.generateMipmaps = n.generateMipmaps, i.internalFormat = n.internalFormat, this.textures = []; const a = n.count; for (let e = 0; e < a; e++)this.textures[e] = i.clone(), this.textures[e].isRenderTargetTexture = !0; this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples } get texture() { return this.textures[0] } set texture(e) { this.textures[0] = e } setSize(e, t, n = 1) { if (this.width !== e || this.height !== t || this.depth !== n) { this.width = e, this.height = t, this.depth = n; for (let r = 0, i = this.textures.length; r < i; r++)this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = n; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0; for (let t = 0, n = e.textures.length; t < n; t++)this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Bh(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Nh extends kh { constructor(e = 1, t = 1, n = {}) { super(e, t, n), this.isWebGLRenderTarget = !0 } } class Fh extends Lh { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Cc, this.minFilter = Cc, this.wrapR = _c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class Oh extends Nh { constructor(e = 1, t = 1, n = 1, r = {}) { super(e, t, r), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new Fh(null, e, t, n), this.texture.isRenderTargetTexture = !0 } } class Uh extends Lh { constructor(e = null, t = 1, n = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Cc, this.minFilter = Cc, this.wrapR = _c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class zh extends Nh { constructor(e = 1, t = 1, n = 1, r = {}) { super(e, t, r), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Uh(null, e, t, n), this.texture.isRenderTargetTexture = !0 } } class Hh { constructor(e = 0, t = 0, n = 0, r = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r } static slerpFlat(e, t, n, r, i, a, o) { let s = n[r + 0], l = n[r + 1], c = n[r + 2], u = n[r + 3]; const d = i[a + 0], h = i[a + 1], p = i[a + 2], f = i[a + 3]; if (0 === o) return e[t + 0] = s, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u); if (1 === o) return e[t + 0] = d, e[t + 1] = h, e[t + 2] = p, void (e[t + 3] = f); if (u !== f || s !== d || l !== h || c !== p) { let e = 1 - o; const t = s * d + l * h + c * p + u * f, n = t >= 0 ? 1 : -1, r = 1 - t * t; if (r > Number.EPSILON) { const i = Math.sqrt(r), a = Math.atan2(i, t * n); e = Math.sin(e * a) / i, o = Math.sin(o * a) / i } const i = o * n; if (s = s * e + d * i, l = l * e + h * i, c = c * e + p * i, u = u * e + f * i, e === 1 - o) { const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u); s *= e, l *= e, c *= e, u *= e } } e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u } static multiplyQuaternionsFlat(e, t, n, r, i, a) { const o = n[r], s = n[r + 1], l = n[r + 2], c = n[r + 3], u = i[a], d = i[a + 1], h = i[a + 2], p = i[a + 3]; return e[t] = o * p + c * u + s * h - l * d, e[t + 1] = s * p + c * d + l * u - o * h, e[t + 2] = l * p + c * h + o * d - s * u, e[t + 3] = c * p - o * u - s * d - l * h, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t = !0) { const n = e._x, r = e._y, i = e._z, a = e._order, o = Math.cos, s = Math.sin, l = o(n / 2), c = o(r / 2), u = o(i / 2), d = s(n / 2), h = s(r / 2), p = s(i / 2); switch (a) { case "XYZ": this._x = d * c * u + l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u - d * h * p; break; case "YXZ": this._x = d * c * u + l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u + d * h * p; break; case "ZXY": this._x = d * c * u - l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u - d * h * p; break; case "ZYX": this._x = d * c * u - l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u + d * h * p; break; case "YZX": this._x = d * c * u + l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u - d * h * p; break; case "XZY": this._x = d * c * u - l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u + d * h * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return !0 === t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const n = t / 2, r = Math.sin(n); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, n = t[0], r = t[4], i = t[8], a = t[1], o = t[5], s = t[9], l = t[2], c = t[6], u = t[10], d = n + o + u; if (d > 0) { const e = .5 / Math.sqrt(d + 1); this._w = .25 / e, this._x = (c - s) * e, this._y = (i - l) * e, this._z = (a - r) * e } else if (n > o && n > u) { const e = 2 * Math.sqrt(1 + n - o - u); this._w = (c - s) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (i + l) / e } else if (o > u) { const e = 2 * Math.sqrt(1 + o - n - u); this._w = (i - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (s + c) / e } else { const e = 2 * Math.sqrt(1 + u - n - o); this._w = (a - r) / e, this._x = (i + l) / e, this._y = (s + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(ih(this.dot(e), -1, 1))) } rotateTowards(e, t) { const n = this.angleTo(e); if (0 === n) return this; const r = Math.min(1, t / n); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const n = e._x, r = e._y, i = e._z, a = e._w, o = t._x, s = t._y, l = t._z, c = t._w; return this._x = n * c + a * o + r * l - i * s, this._y = r * c + a * s + i * o - n * l, this._z = i * c + a * l + n * s - r * o, this._w = a * c - n * o - r * s - i * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const n = this._x, r = this._y, i = this._z, a = this._w; let o = a * e._w + n * e._x + r * e._y + i * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this; const s = 1 - o * o; if (s <= Number.EPSILON) { const e = 1 - t; return this._w = e * a + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this } const l = Math.sqrt(s), c = Math.atan2(l, o), u = Math.sin((1 - t) * c) / l, d = Math.sin(t * c) / l; return this._w = a * u + this._w * d, this._x = n * u + this._x * d, this._y = r * u + this._y * d, this._z = i * u + this._z * d, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { return this.copy(e).slerp(t, n) } random() { const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), r = Math.sqrt(1 - n), i = Math.sqrt(n); return this.set(r * Math.sin(e), r * Math.cos(e), i * Math.sin(t), i * Math.cos(t)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class Gh { constructor(e = 0, t = 0, n = 0) { Gh.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n } set(e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(Vh.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(Vh.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, n = this.y, r = this.z, i = e.elements, a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]); return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this } applyQuaternion(e) { const t = this.x, n = this.y, r = this.z, i = e.x, a = e.y, o = e.z, s = e.w, l = 2 * (a * r - o * n), c = 2 * (o * t - i * r), u = 2 * (i * n - a * t); return this.x = t + s * l + a * u - o * c, this.y = n + s * c + o * l - i * u, this.z = r + s * u + i * c - a * l, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const n = e.x, r = e.y, i = e.z, a = t.x, o = t.y, s = t.z; return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } projectOnPlane(e) { return jh.copy(this).projectOnVector(e), this.sub(jh) } reflect(e) { return this.sub(jh.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(ih(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z; return t * t + n * n + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { const r = Math.sin(t) * e; return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, n = Math.sqrt(1 - t * t); return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const jh = new Gh, Vh = new Hh; class Wh { constructor(e = new Gh(1 / 0, 1 / 0, 1 / 0), t = new Gh(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t += 3)this.expandByPoint(Jh.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, n = e.count; t < n; t++)this.expandByPoint(Jh.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = Jh.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const n = e.geometry; if (void 0 !== n) { const r = n.getAttribute("position"); if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh) for (let t = 0, n = r.count; t < n; t++)!0 === e.isMesh ? e.getVertexPosition(t, Jh) : Jh.fromBufferAttribute(r, t), Jh.applyMatrix4(e.matrixWorld), this.expandByPoint(Jh); else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), Yh.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Yh.copy(n.boundingBox)), Yh.applyMatrix4(e.matrixWorld), this.union(Yh) } const r = e.children; for (let e = 0, n = r.length; e < n; e++)this.expandByObject(r[e], t); return this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z } intersectsSphere(e) { return this.clampPoint(e.center, Jh), Jh.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(tp), np.subVectors(this.max, tp), Qh.subVectors(e.a, tp), Kh.subVectors(e.b, tp), qh.subVectors(e.c, tp), Zh.subVectors(Kh, Qh), $h.subVectors(qh, Kh), ep.subVectors(Qh, qh); let t = [0, -Zh.z, Zh.y, 0, -$h.z, $h.y, 0, -ep.z, ep.y, Zh.z, 0, -Zh.x, $h.z, 0, -$h.x, ep.z, 0, -ep.x, -Zh.y, Zh.x, 0, -$h.y, $h.x, 0, -ep.y, ep.x, 0]; return !!ap(t, Qh, Kh, qh, np) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!ap(t, Qh, Kh, qh, np) && (rp.crossVectors(Zh, $h), t = [rp.x, rp.y, rp.z], ap(t, Qh, Kh, qh, np))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, Jh).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(Jh).length()), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (Xh[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Xh[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Xh[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Xh[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Xh[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Xh[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Xh[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Xh[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Xh)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const Xh = [new Gh, new Gh, new Gh, new Gh, new Gh, new Gh, new Gh, new Gh], Jh = new Gh, Yh = new Wh, Qh = new Gh, Kh = new Gh, qh = new Gh, Zh = new Gh, $h = new Gh, ep = new Gh, tp = new Gh, np = new Gh, rp = new Gh, ip = new Gh; function ap(e, t, n, r, i) { for (let a = 0, o = e.length - 3; a <= o; a += 3) { ip.fromArray(e, a); const o = i.x * Math.abs(ip.x) + i.y * Math.abs(ip.y) + i.z * Math.abs(ip.z), s = t.dot(ip), l = n.dot(ip), c = r.dot(ip); if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o) return !1 } return !0 } const op = new Wh, sp = new Gh, lp = new Gh; class cp { constructor(e = new Gh, t = -1) { this.isSphere = !0, this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const n = this.center; void 0 !== t ? n.copy(t) : op.setFromPoints(e).getCenter(n); let r = 0; for (let t = 0, i = e.length; t < i; t++)r = Math.max(r, n.distanceToSquared(e[t])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; sp.subVectors(e, this.center); const t = sp.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), n = .5 * (e - this.radius); this.center.addScaledVector(sp, n / e), this.radius += n } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (lp.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(sp.copy(e.center).add(lp)), this.expandByPoint(sp.copy(e.center).sub(lp))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const up = new Gh, dp = new Gh, hp = new Gh, pp = new Gh, fp = new Gh, mp = new Gh, gp = new Gh; class vp { constructor(e = new Gh, t = new Gh(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, up)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = up.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (up.copy(this.origin).addScaledVector(this.direction, t), up.distanceToSquared(e)) } distanceSqToSegment(e, t, n, r) { dp.copy(e).add(t).multiplyScalar(.5), hp.copy(t).sub(e).normalize(), pp.copy(this.origin).sub(dp); const i = .5 * e.distanceTo(t), a = -this.direction.dot(hp), o = pp.dot(this.direction), s = -pp.dot(hp), l = pp.lengthSq(), c = Math.abs(1 - a * a); let u, d, h, p; if (c > 0) if (u = a * s - o, d = a * o - s, p = i * c, u >= 0) if (d >= -p) if (d <= p) { const e = 1 / c; u *= e, d *= e, h = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * s) + l } else d = i, u = Math.max(0, -(a * d + o)), h = -u * u + d * (d + 2 * s) + l; else d = -i, u = Math.max(0, -(a * d + o)), h = -u * u + d * (d + 2 * s) + l; else d <= -p ? (u = Math.max(0, -(-a * i + o)), d = u > 0 ? -i : Math.min(Math.max(-i, -s), i), h = -u * u + d * (d + 2 * s) + l) : d <= p ? (u = 0, d = Math.min(Math.max(-i, -s), i), h = d * (d + 2 * s) + l) : (u = Math.max(0, -(a * i + o)), d = u > 0 ? i : Math.min(Math.max(-i, -s), i), h = -u * u + d * (d + 2 * s) + l); else d = a > 0 ? -i : i, u = Math.max(0, -(a * d + o)), h = -u * u + d * (d + 2 * s) + l; return n && n.copy(this.origin).addScaledVector(this.direction, u), r && r.copy(dp).addScaledVector(hp, d), h } intersectSphere(e, t) { up.subVectors(e.center, this.origin); const n = up.dot(this.direction), r = up.dot(up) - n * n, i = e.radius * e.radius; if (r > i) return null; const a = Math.sqrt(i - r), o = n - a, s = n + a; return s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } intersectPlane(e, t) { const n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, r, i, a, o, s; const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin; return l >= 0 ? (n = (e.min.x - d.x) * l, r = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, r = (e.min.x - d.x) * l), c >= 0 ? (i = (e.min.y - d.y) * c, a = (e.max.y - d.y) * c) : (i = (e.max.y - d.y) * c, a = (e.min.y - d.y) * c), n > a || i > r ? null : ((i > n || isNaN(n)) && (n = i), (a < r || isNaN(r)) && (r = a), u >= 0 ? (o = (e.min.z - d.z) * u, s = (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, s = (e.min.z - d.z) * u), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t))) } intersectsBox(e) { return null !== this.intersectBox(e, up) } intersectTriangle(e, t, n, r, i) { fp.subVectors(t, e), mp.subVectors(n, e), gp.crossVectors(fp, mp); let a, o = this.direction.dot(gp); if (o > 0) { if (r) return null; a = 1 } else { if (!(o < 0)) return null; a = -1, o = -o } pp.subVectors(this.origin, e); const s = a * this.direction.dot(mp.crossVectors(pp, mp)); if (s < 0) return null; const l = a * this.direction.dot(fp.cross(pp)); if (l < 0) return null; if (s + l > o) return null; const c = -a * pp.dot(gp); return c < 0 ? null : this.at(c / o, i) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class yp { constructor(e, t, n, r, i, a, o, s, l, c, u, d, h, p, f, m) { yp.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, r, i, a, o, s, l, c, u, d, h, p, f, m) } set(e, t, n, r, i, a, o, s, l, c, u, d, h, p, f, m) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = d, g[3] = h, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new yp).fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, r = 1 / bp.setFromMatrixColumn(e, 0).length(), i = 1 / bp.setFromMatrixColumn(e, 1).length(), a = 1 / bp.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, n = e.x, r = e.y, i = e.z, a = Math.cos(n), o = Math.sin(n), s = Math.cos(r), l = Math.sin(r), c = Math.cos(i), u = Math.sin(i); if ("XYZ" === e.order) { const e = a * c, n = a * u, r = o * c, i = o * u; t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -o * s, t[2] = i - e * l, t[6] = r + n * l, t[10] = a * s } else if ("YXZ" === e.order) { const e = s * c, n = s * u, r = l * c, i = l * u; t[0] = e + i * o, t[4] = r * o - n, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = n * o - r, t[6] = i + e * o, t[10] = a * s } else if ("ZXY" === e.order) { const e = s * c, n = s * u, r = l * c, i = l * u; t[0] = e - i * o, t[4] = -a * u, t[8] = r + n * o, t[1] = n + r * o, t[5] = a * c, t[9] = i - e * o, t[2] = -a * l, t[6] = o, t[10] = a * s } else if ("ZYX" === e.order) { const e = a * c, n = a * u, r = o * c, i = o * u; t[0] = s * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = s * u, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = o * s, t[10] = a * s } else if ("YZX" === e.order) { const e = a * s, n = a * l, r = o * s, i = o * l; t[0] = s * c, t[4] = i - e * u, t[8] = r * u + n, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = n * u + r, t[10] = e - i * u } else if ("XZY" === e.order) { const e = a * s, n = a * l, r = o * s, i = o * l; t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = e * u + i, t[5] = a * c, t[9] = n * u - r, t[2] = r * u - n, t[6] = o * c, t[10] = i * u + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(Ap, e, Sp) } lookAt(e, t, n) { const r = this.elements; return _p.subVectors(e, t), 0 === _p.lengthSq() && (_p.z = 1), _p.normalize(), Mp.crossVectors(n, _p), 0 === Mp.lengthSq() && (1 === Math.abs(n.z) ? _p.x += 1e-4 : _p.z += 1e-4, _p.normalize(), Mp.crossVectors(n, _p)), Mp.normalize(), wp.crossVectors(_p, Mp), r[0] = Mp.x, r[4] = wp.x, r[8] = _p.x, r[1] = Mp.y, r[5] = wp.y, r[9] = _p.y, r[2] = Mp.z, r[6] = wp.z, r[10] = _p.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, r = t.elements, i = this.elements, a = n[0], o = n[4], s = n[8], l = n[12], c = n[1], u = n[5], d = n[9], h = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], b = n[11], x = n[15], A = r[0], S = r[4], M = r[8], w = r[12], _ = r[1], E = r[5], C = r[9], T = r[13], R = r[2], B = r[6], I = r[10], P = r[14], L = r[3], D = r[7], k = r[11], N = r[15]; return i[0] = a * A + o * _ + s * R + l * L, i[4] = a * S + o * E + s * B + l * D, i[8] = a * M + o * C + s * I + l * k, i[12] = a * w + o * T + s * P + l * N, i[1] = c * A + u * _ + d * R + h * L, i[5] = c * S + u * E + d * B + h * D, i[9] = c * M + u * C + d * I + h * k, i[13] = c * w + u * T + d * P + h * N, i[2] = p * A + f * _ + m * R + g * L, i[6] = p * S + f * E + m * B + g * D, i[10] = p * M + f * C + m * I + g * k, i[14] = p * w + f * T + m * P + g * N, i[3] = v * A + y * _ + b * R + x * L, i[7] = v * S + y * E + b * B + x * D, i[11] = v * M + y * C + b * I + x * k, i[15] = v * w + y * T + b * P + x * N, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[4], r = e[8], i = e[12], a = e[1], o = e[5], s = e[9], l = e[13], c = e[2], u = e[6], d = e[10], h = e[14]; return e[3] * (+i * s * u - r * l * u - i * o * d + n * l * d + r * o * h - n * s * h) + e[7] * (+t * s * h - t * l * d + i * a * d - r * a * h + r * l * c - i * s * c) + e[11] * (+t * l * u - t * o * h - i * a * u + n * a * h + i * o * c - n * l * c) + e[15] * (-r * o * c - t * s * u + t * o * d + r * a * u - n * a * d + n * s * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8], u = e[9], d = e[10], h = e[11], p = e[12], f = e[13], m = e[14], g = e[15], v = u * m * l - f * d * l + f * s * h - o * m * h - u * s * g + o * d * g, y = p * d * l - c * m * l - p * s * h + a * m * h + c * s * g - a * d * g, b = c * f * l - p * u * l + p * o * h - a * f * h - c * o * g + a * u * g, x = p * u * s - c * f * s - p * o * d + a * f * d + c * o * m - a * u * m, A = t * v + n * y + r * b + i * x; if (0 === A) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const S = 1 / A; return e[0] = v * S, e[1] = (f * d * i - u * m * i - f * r * h + n * m * h + u * r * g - n * d * g) * S, e[2] = (o * m * i - f * s * i + f * r * l - n * m * l - o * r * g + n * s * g) * S, e[3] = (u * s * i - o * d * i - u * r * l + n * d * l + o * r * h - n * s * h) * S, e[4] = y * S, e[5] = (c * m * i - p * d * i + p * r * h - t * m * h - c * r * g + t * d * g) * S, e[6] = (p * s * i - a * m * i - p * r * l + t * m * l + a * r * g - t * s * g) * S, e[7] = (a * d * i - c * s * i + c * r * l - t * d * l - a * r * h + t * s * h) * S, e[8] = b * S, e[9] = (p * u * i - c * f * i - p * n * h + t * f * h + c * n * g - t * u * g) * S, e[10] = (a * f * i - p * o * i + p * n * l - t * f * l - a * n * g + t * o * g) * S, e[11] = (c * o * i - a * u * i - c * n * l + t * u * l + a * n * h - t * o * h) * S, e[12] = x * S, e[13] = (c * f * r - p * u * r + p * n * d - t * f * d - c * n * m + t * u * m) * S, e[14] = (p * o * r - a * f * r - p * n * s + t * f * s + a * n * m - t * o * m) * S, e[15] = (a * u * r - c * o * r + c * n * s - t * u * s - a * n * d + t * o * d) * S, this } scale(e) { const t = this.elements, n = e.x, r = e.y, i = e.z; return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, r)) } makeTranslation(e, t, n) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const n = Math.cos(t), r = Math.sin(t), i = 1 - n, a = e.x, o = e.y, s = e.z, l = i * a, c = i * o; return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, c * o + n, c * s - r * a, 0, l * s - r * o, c * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, r, i, a) { return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const r = this.elements, i = t._x, a = t._y, o = t._z, s = t._w, l = i + i, c = a + a, u = o + o, d = i * l, h = i * c, p = i * u, f = a * c, m = a * u, g = o * u, v = s * l, y = s * c, b = s * u, x = n.x, A = n.y, S = n.z; return r[0] = (1 - (f + g)) * x, r[1] = (h + b) * x, r[2] = (p - y) * x, r[3] = 0, r[4] = (h - b) * A, r[5] = (1 - (d + g)) * A, r[6] = (m + v) * A, r[7] = 0, r[8] = (p + y) * S, r[9] = (m - v) * S, r[10] = (1 - (d + f)) * S, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, n) { const r = this.elements; let i = bp.set(r[0], r[1], r[2]).length(); const a = bp.set(r[4], r[5], r[6]).length(), o = bp.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], xp.copy(this); const s = 1 / i, l = 1 / a, c = 1 / o; return xp.elements[0] *= s, xp.elements[1] *= s, xp.elements[2] *= s, xp.elements[4] *= l, xp.elements[5] *= l, xp.elements[6] *= l, xp.elements[8] *= c, xp.elements[9] *= c, xp.elements[10] *= c, t.setFromRotationMatrix(xp), n.x = i, n.y = a, n.z = o, this } makePerspective(e, t, n, r, i, a, o = Kd) { const s = this.elements, l = 2 * i / (t - e), c = 2 * i / (n - r), u = (t + e) / (t - e), d = (n + r) / (n - r); let h, p; if (o === Kd) h = -(a + i) / (a - i), p = -2 * a * i / (a - i); else { if (o !== qd) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o); h = -a / (a - i), p = -a * i / (a - i) } return s[0] = l, s[4] = 0, s[8] = u, s[12] = 0, s[1] = 0, s[5] = c, s[9] = d, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this } makeOrthographic(e, t, n, r, i, a, o = Kd) { const s = this.elements, l = 1 / (t - e), c = 1 / (n - r), u = 1 / (a - i), d = (t + e) * l, h = (n + r) * c; let p, f; if (o === Kd) p = (a + i) * u, f = -2 * u; else { if (o !== qd) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o); p = i * u, f = -1 * u } return s[0] = 2 * l, s[4] = 0, s[8] = 0, s[12] = -d, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = f, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } const bp = new Gh, xp = new yp, Ap = new Gh(0, 0, 0), Sp = new Gh(1, 1, 1), Mp = new Gh, wp = new Gh, _p = new Gh, Ep = new yp, Cp = new Hh; class Tp { constructor(e = 0, t = 0, n = 0, r = Tp.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, r = this._order) { return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { const r = e.elements, i = r[0], a = r[4], o = r[8], s = r[1], l = r[5], c = r[9], u = r[2], d = r[6], h = r[10]; switch (t) { case "XYZ": this._y = Math.asin(ih(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(d, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-ih(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, h), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, i), this._z = 0); break; case "ZXY": this._x = Math.asin(ih(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, h), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, i)); break; case "ZYX": this._y = Math.asin(-ih(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, h), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-a, l)); break; case "YZX": this._z = Math.asin(ih(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, h)); break; case "XZY": this._z = Math.asin(-ih(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, h), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === n && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return Ep.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ep, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return Cp.setFromEuler(this), this.setFromQuaternion(Cp, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } Tp.DEFAULT_ORDER = "XYZ"; class Rp { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e >>> 0 } enable(e) { this.mask |= 1 << e } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e } disable(e) { this.mask &= ~(1 << e) } disableAll() { this.mask = 0 } test(e) { return !!(this.mask & e.mask) } isEnabled(e) { return !!(this.mask & 1 << e) } } let Bp = 0; const Ip = new Gh, Pp = new Hh, Lp = new yp, Dp = new Gh, kp = new Gh, Np = new Gh, Fp = new Hh, Op = new Gh(1, 0, 0), Up = new Gh(0, 1, 0), zp = new Gh(0, 0, 1), Hp = { type: "added" }, Gp = { type: "removed" }, jp = { type: "childadded", child: null }, Vp = { type: "childremoved", child: null }; class Wp extends Zd { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Bp++ }), this.uuid = rh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Wp.DEFAULT_UP.clone(); const e = new Gh, t = new Tp, n = new Hh, r = new Gh(1, 1, 1); t._onChange((function () { n.setFromEuler(t, !1) })), n._onChange((function () { t.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new yp }, normalMatrix: { value: new dh } }), this.matrix = new yp, this.matrixWorld = new yp, this.matrixAutoUpdate = Wp.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Wp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Rp, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Pp.setFromAxisAngle(e, t), this.quaternion.multiply(Pp), this } rotateOnWorldAxis(e, t) { return Pp.setFromAxisAngle(e, t), this.quaternion.premultiply(Pp), this } rotateX(e) { return this.rotateOnAxis(Op, e) } rotateY(e) { return this.rotateOnAxis(Up, e) } rotateZ(e) { return this.rotateOnAxis(zp, e) } translateOnAxis(e, t) { return Ip.copy(e).applyQuaternion(this.quaternion), this.position.add(Ip.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(Op, e) } translateY(e) { return this.translateOnAxis(Up, e) } translateZ(e) { return this.translateOnAxis(zp, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Lp.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? Dp.copy(e) : Dp.set(e, t, n); const r = this.parent; this.updateWorldMatrix(!0, !1), kp.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Lp.lookAt(kp, Dp, this.up) : Lp.lookAt(Dp, kp, this.up), this.quaternion.setFromRotationMatrix(Lp), r && (Lp.extractRotation(r.matrixWorld), Pp.setFromRotationMatrix(Lp), this.quaternion.premultiply(Pp.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Hp), jp.child = e, this.dispatchEvent(jp), jp.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Gp), Vp.child = e, this.dispatchEvent(Vp), Vp.child = null), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), Lp.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Lp.multiply(e.parent.matrixWorld)), e.applyMatrix4(Lp), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Hp), jp.child = e, this.dispatchEvent(jp), jp.child = null, this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let n = 0, r = this.children.length; n < r; n++) { const r = this.children[n].getObjectByProperty(e, t); if (void 0 !== r) return r } } getObjectsByProperty(e, t, n = []) { this[e] === t && n.push(this); const r = this.children; for (let i = 0, a = r.length; i < a; i++)r[i].getObjectsByProperty(e, t, n); return n } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(kp, e, Np), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(kp, Fp, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let n = 0, r = t.length; n < r; n++)t[n].updateMatrixWorld(e) } updateWorldMatrix(e, t) { const n = this.parent; if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) { const e = this.children; for (let t = 0, n = e.length; t < n; t++)e[t].updateWorldMatrix(!1, !0) } } toJSON(e) { const t = void 0 === e || "string" == typeof e, n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const r = {}; function i(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((e => ({ boxInitialized: e.boxInitialized, boxMin: e.box.min.toArray(), boxMax: e.box.max.toArray(), sphereInitialized: e.sphereInitialized, sphereRadius: e.sphere.radius, sphereCenter: e.sphere.center.toArray() }))), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), null !== this._colorsTexture && (r.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }), null !== this.boundingBox && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() })), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = i(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const n = t.shapes; if (Array.isArray(n)) for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; i(e.shapes, r) } else i(e.shapes, n) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let n = 0, r = this.material.length; n < r; n++)t.push(i(e.materials, this.material[n])); r.material = t } else r.material = i(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let t = 0; t < this.children.length; t++)r.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let t = 0; t < this.animations.length; t++) { const n = this.animations[t]; r.animations.push(i(e.animations, n)) } } if (t) { const t = a(e.geometries), r = a(e.materials), i = a(e.textures), o = a(e.images), s = a(e.shapes), l = a(e.skeletons), c = a(e.animations), u = a(e.nodes); t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), s.length > 0 && (n.shapes = s), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u) } return n.object = r, n; function a(e) { const t = []; for (const n in e) { const r = e[n]; delete r.metadata, t.push(r) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const n = e.children[t]; this.add(n.clone()) } return this } } Wp.DEFAULT_UP = new Gh(0, 1, 0), Wp.DEFAULT_MATRIX_AUTO_UPDATE = !0, Wp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const Xp = new Gh, Jp = new Gh, Yp = new Gh, Qp = new Gh, Kp = new Gh, qp = new Gh, Zp = new Gh, $p = new Gh, ef = new Gh, tf = new Gh, nf = new Dh, rf = new Dh, af = new Dh; class of { constructor(e = new Gh, t = new Gh, n = new Gh) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, r) { r.subVectors(n, t), Xp.subVectors(e, t), r.cross(Xp); const i = r.lengthSq(); return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) } static getBarycoord(e, t, n, r, i) { Xp.subVectors(r, t), Jp.subVectors(n, t), Yp.subVectors(e, t); const a = Xp.dot(Xp), o = Xp.dot(Jp), s = Xp.dot(Yp), l = Jp.dot(Jp), c = Jp.dot(Yp), u = a * l - o * o; if (0 === u) return i.set(0, 0, 0), null; const d = 1 / u, h = (l * s - o * c) * d, p = (a * c - o * s) * d; return i.set(1 - h - p, p, h) } static containsPoint(e, t, n, r) { return null !== this.getBarycoord(e, t, n, r, Qp) && Qp.x >= 0 && Qp.y >= 0 && Qp.x + Qp.y <= 1 } static getInterpolation(e, t, n, r, i, a, o, s) { return null === this.getBarycoord(e, t, n, r, Qp) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(i, Qp.x), s.addScaledVector(a, Qp.y), s.addScaledVector(o, Qp.z), s) } static getInterpolatedAttribute(e, t, n, r, i, a) { return nf.setScalar(0), rf.setScalar(0), af.setScalar(0), nf.fromBufferAttribute(e, t), rf.fromBufferAttribute(e, n), af.fromBufferAttribute(e, r), a.setScalar(0), a.addScaledVector(nf, i.x), a.addScaledVector(rf, i.y), a.addScaledVector(af, i.z), a } static isFrontFacing(e, t, n, r) { return Xp.subVectors(n, t), Jp.subVectors(e, t), Xp.cross(Jp).dot(r) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, r) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this } setFromAttributeAndIndices(e, t, n, r) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Xp.subVectors(this.c, this.b), Jp.subVectors(this.a, this.b), .5 * Xp.cross(Jp).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return of.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return of.getBarycoord(e, this.a, this.b, this.c, t) } getInterpolation(e, t, n, r, i) { return of.getInterpolation(e, this.a, this.b, this.c, t, n, r, i) } containsPoint(e) { return of.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return of.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const n = this.a, r = this.b, i = this.c; let a, o; Kp.subVectors(r, n), qp.subVectors(i, n), $p.subVectors(e, n); const s = Kp.dot($p), l = qp.dot($p); if (s <= 0 && l <= 0) return t.copy(n); ef.subVectors(e, r); const c = Kp.dot(ef), u = qp.dot(ef); if (c >= 0 && u <= c) return t.copy(r); const d = s * u - c * l; if (d <= 0 && s >= 0 && c <= 0) return a = s / (s - c), t.copy(n).addScaledVector(Kp, a); tf.subVectors(e, i); const h = Kp.dot(tf), p = qp.dot(tf); if (p >= 0 && h <= p) return t.copy(i); const f = h * l - s * p; if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), t.copy(n).addScaledVector(qp, o); const m = c * p - h * u; if (m <= 0 && u - c >= 0 && h - p >= 0) return Zp.subVectors(i, r), o = (u - c) / (u - c + (h - p)), t.copy(r).addScaledVector(Zp, o); const g = 1 / (m + f + d); return a = f * g, o = d * g, t.copy(n).addScaledVector(Kp, a).addScaledVector(qp, o) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } const sf = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, lf = { h: 0, s: 0, l: 0 }, cf = { h: 0, s: 0, l: 0 }; function uf(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } class df { constructor(e, t, n) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n) } set(e, t, n) { if (void 0 === t && void 0 === n) { const t = e; t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t) } else this.setRGB(e, t, n); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = sd) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, wh.toWorkingColorSpace(this, t), this } setRGB(e, t, n, r = wh.workingColorSpace) { return this.r = e, this.g = t, this.b = n, wh.toWorkingColorSpace(this, r), this } setHSL(e, t, n, r = wh.workingColorSpace) { if (e = ah(e, 1), t = ih(t, 0, 1), n = ih(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else { const r = n <= .5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r; this.r = uf(i, r, e + 1 / 3), this.g = uf(i, r, e), this.b = uf(i, r, e - 1 / 3) } return wh.toWorkingColorSpace(this, r), this } setStyle(e, t = sd) { function n(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let r; if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) { let i; const a = r[1], o = r[2]; switch (a) { case "rgb": case "rgba": if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(i[4]), this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, t); if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(i[4]), this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, t); break; case "hsl": case "hsla": if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(i[4]), this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, t); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) { const n = r[1], i = n.length; if (3 === i) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t); if (6 === i) return this.setHex(parseInt(n, 16), t); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = sd) { const n = sf[e.toLowerCase()]; return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = _h(e.r), this.g = _h(e.g), this.b = _h(e.b), this } copyLinearToSRGB(e) { return this.r = Eh(e.r), this.g = Eh(e.g), this.b = Eh(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = sd) { return wh.fromWorkingColorSpace(hf.copy(this), e), 65536 * Math.round(ih(255 * hf.r, 0, 255)) + 256 * Math.round(ih(255 * hf.g, 0, 255)) + Math.round(ih(255 * hf.b, 0, 255)) } getHexString(e = sd) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = wh.workingColorSpace) { wh.fromWorkingColorSpace(hf.copy(this), t); const n = hf.r, r = hf.g, i = hf.b, a = Math.max(n, r, i), o = Math.min(n, r, i); let s, l; const c = (o + a) / 2; if (o === a) s = 0, l = 0; else { const e = a - o; switch (l = c <= .5 ? e / (a + o) : e / (2 - a - o), a) { case n: s = (r - i) / e + (r < i ? 6 : 0); break; case r: s = (i - n) / e + 2; break; case i: s = (n - r) / e + 4 }s /= 6 } return e.h = s, e.s = l, e.l = c, e } getRGB(e, t = wh.workingColorSpace) { return wh.fromWorkingColorSpace(hf.copy(this), t), e.r = hf.r, e.g = hf.g, e.b = hf.b, e } getStyle(e = sd) { wh.fromWorkingColorSpace(hf.copy(this), e); const t = hf.r, n = hf.g, r = hf.b; return e !== sd ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * r)})` } offsetHSL(e, t, n) { return this.getHSL(lf), this.setHSL(lf.h + e, lf.s + t, lf.l + n) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(lf), e.getHSL(cf); const n = oh(lf.h, cf.h, t), r = oh(lf.s, cf.s, t), i = oh(lf.l, cf.l, t); return this.setHSL(n, r, i), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const t = this.r, n = this.g, r = this.b, i = e.elements; return this.r = i[0] * t + i[3] * n + i[6] * r, this.g = i[1] * t + i[4] * n + i[7] * r, this.b = i[2] * t + i[5] * n + i[8] * r, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const hf = new df; df.NAMES = sf; let pf = 0; class ff extends Zd { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: pf++ }), this.uuid = rh(), this.name = "", this.type = "Material", this.blending = El, this.side = Sl, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = zl, this.blendDst = Hl, this.blendEquation = Il, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new df(0, 0, 0), this.blendAlpha = 0, this.depthFunc = ec, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Bd, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = gd, this.stencilZFail = gd, this.stencilZPass = gd, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const t in e) { const n = e[t]; if (void 0 === n) { console.warn(`THREE.Material: parameter '${t}' has value of undefined.`); continue } const r = this[t]; void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`) } } toJSON(e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const n = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; function r(e) { const t = []; for (const n in e) { const r = e[n]; delete r.metadata, t.push(r) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== El && (n.blending = this.blending), this.side !== Sl && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), this.blendSrc !== zl && (n.blendSrc = this.blendSrc), this.blendDst !== Hl && (n.blendDst = this.blendDst), this.blendEquation !== Il && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), this.depthFunc !== ec && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Bd && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== gd && (n.stencilFail = this.stencilFail), this.stencilZFail !== gd && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== gd && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) { const t = r(e.textures), i = r(e.images); t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i) } return n } clone() { return (new this.constructor).copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if (null !== t) { const e = t.length; n = new Array(e); for (let r = 0; r !== e; ++r)n[r] = t[r].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } onBuild() { console.warn("Material: onBuild() has been removed.") } } class mf extends ff { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new df(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Tp, this.combine = ac, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const gf = vf(); function vf() { const e = new ArrayBuffer(4), t = new Float32Array(e), n = new Uint32Array(e), r = new Uint32Array(512), i = new Uint32Array(512); for (let e = 0; e < 256; ++e) { const t = e - 127; t < -27 ? (r[e] = 0, r[256 | e] = 32768, i[e] = 24, i[256 | e] = 24) : t < -14 ? (r[e] = 1024 >> -t - 14, r[256 | e] = 1024 >> -t - 14 | 32768, i[e] = -t - 1, i[256 | e] = -t - 1) : t <= 15 ? (r[e] = t + 15 << 10, r[256 | e] = t + 15 << 10 | 32768, i[e] = 13, i[256 | e] = 13) : t < 128 ? (r[e] = 31744, r[256 | e] = 64512, i[e] = 24, i[256 | e] = 24) : (r[e] = 31744, r[256 | e] = 64512, i[e] = 13, i[256 | e] = 13) } const a = new Uint32Array(2048), o = new Uint32Array(64), s = new Uint32Array(64); for (let e = 1; e < 1024; ++e) { let t = e << 13, n = 0; for (; !(8388608 & t);)t <<= 1, n -= 8388608; t &= -8388609, n += 947912704, a[e] = t | n } for (let e = 1024; e < 2048; ++e)a[e] = 939524096 + (e - 1024 << 13); for (let e = 1; e < 31; ++e)o[e] = e << 23; o[31] = 1199570944, o[32] = 2147483648; for (let e = 33; e < 63; ++e)o[e] = 2147483648 + (e - 32 << 23); o[63] = 3347054592; for (let e = 1; e < 64; ++e)32 !== e && (s[e] = 1024); return { floatView: t, uint32View: n, baseTable: r, shiftTable: i, mantissaTable: a, exponentTable: o, offsetTable: s } } function yf(e) { Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = ih(e, -65504, 65504), gf.floatView[0] = e; const t = gf.uint32View[0], n = t >> 23 & 511; return gf.baseTable[n] + ((8388607 & t) >> gf.shiftTable[n]) } function bf(e) { const t = e >> 10; return gf.uint32View[0] = gf.mantissaTable[gf.offsetTable[t] + (1023 & e)] + gf.exponentTable[t], gf.floatView[0] } const xf = { toHalfFloat: yf, fromHalfFloat: bf }, Af = new Gh, Sf = new uh; class Mf { constructor(e, t, n = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = Ud, this.updateRanges = [], this.gpuType = jc, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (let r = 0, i = this.itemSize; r < i; r++)this.array[e + r] = t.array[n + r]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)Sf.fromBufferAttribute(this, t), Sf.applyMatrix3(e), this.setXY(t, Sf.x, Sf.y); else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)Af.fromBufferAttribute(this, t), Af.applyMatrix3(e), this.setXYZ(t, Af.x, Af.y, Af.z); return this } applyMatrix4(e) { for (let t = 0, n = this.count; t < n; t++)Af.fromBufferAttribute(this, t), Af.applyMatrix4(e), this.setXYZ(t, Af.x, Af.y, Af.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)Af.fromBufferAttribute(this, t), Af.applyNormalMatrix(e), this.setXYZ(t, Af.x, Af.y, Af.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)Af.fromBufferAttribute(this, t), Af.transformDirection(e), this.setXYZ(t, Af.x, Af.y, Af.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let n = this.array[e * this.itemSize + t]; return this.normalized && (n = sh(n, this.array)), n } setComponent(e, t, n) { return this.normalized && (n = lh(n, this.array)), this.array[e * this.itemSize + t] = n, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = sh(t, this.array)), t } setX(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = sh(t, this.array)), t } setY(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = sh(t, this.array)), t } setZ(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = sh(t, this.array)), t } setW(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.normalized && (t = lh(t, this.array), n = lh(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e *= this.itemSize, this.normalized && (t = lh(t, this.array), n = lh(n, this.array), r = lh(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this } setXYZW(e, t, n, r, i) { return e *= this.itemSize, this.normalized && (t = lh(t, this.array), n = lh(n, this.array), r = lh(r, this.array), i = lh(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== Ud && (e.usage = this.usage), e } } class wf extends Mf { constructor(e, t, n) { super(new Int8Array(e), t, n) } } class _f extends Mf { constructor(e, t, n) { super(new Uint8Array(e), t, n) } } class Ef extends Mf { constructor(e, t, n) { super(new Uint8ClampedArray(e), t, n) } } class Cf extends Mf { constructor(e, t, n) { super(new Int16Array(e), t, n) } } class Tf extends Mf { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class Rf extends Mf { constructor(e, t, n) { super(new Int32Array(e), t, n) } } class Bf extends Mf { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } class If extends Mf { constructor(e, t, n) { super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0 } getX(e) { let t = bf(this.array[e * this.itemSize]); return this.normalized && (t = sh(t, this.array)), t } setX(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize] = yf(t), this } getY(e) { let t = bf(this.array[e * this.itemSize + 1]); return this.normalized && (t = sh(t, this.array)), t } setY(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize + 1] = yf(t), this } getZ(e) { let t = bf(this.array[e * this.itemSize + 2]); return this.normalized && (t = sh(t, this.array)), t } setZ(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize + 2] = yf(t), this } getW(e) { let t = bf(this.array[e * this.itemSize + 3]); return this.normalized && (t = sh(t, this.array)), t } setW(e, t) { return this.normalized && (t = lh(t, this.array)), this.array[e * this.itemSize + 3] = yf(t), this } setXY(e, t, n) { return e *= this.itemSize, this.normalized && (t = lh(t, this.array), n = lh(n, this.array)), this.array[e + 0] = yf(t), this.array[e + 1] = yf(n), this } setXYZ(e, t, n, r) { return e *= this.itemSize, this.normalized && (t = lh(t, this.array), n = lh(n, this.array), r = lh(r, this.array)), this.array[e + 0] = yf(t), this.array[e + 1] = yf(n), this.array[e + 2] = yf(r), this } setXYZW(e, t, n, r, i) { return e *= this.itemSize, this.normalized && (t = lh(t, this.array), n = lh(n, this.array), r = lh(r, this.array), i = lh(i, this.array)), this.array[e + 0] = yf(t), this.array[e + 1] = yf(n), this.array[e + 2] = yf(r), this.array[e + 3] = yf(i), this } } class Pf extends Mf { constructor(e, t, n) { super(new Float32Array(e), t, n) } } let Lf = 0; const Df = new yp, kf = new Wp, Nf = new Gh, Ff = new Wh, Of = new Wh, Uf = new Gh; class zf extends Zd { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Lf++ }), this.uuid = rh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (ph(e) ? Bf : Tf)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const t = (new dh).getNormalMatrix(e); n.applyNormalMatrix(t), n.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return Df.makeRotationFromQuaternion(e), this.applyMatrix4(Df), this } rotateX(e) { return Df.makeRotationX(e), this.applyMatrix4(Df), this } rotateY(e) { return Df.makeRotationY(e), this.applyMatrix4(Df), this } rotateZ(e) { return Df.makeRotationZ(e), this.applyMatrix4(Df), this } translate(e, t, n) { return Df.makeTranslation(e, t, n), this.applyMatrix4(Df), this } scale(e, t, n) { return Df.makeScale(e, t, n), this.applyMatrix4(Df), this } lookAt(e) { return kf.lookAt(e), kf.updateMatrix(), this.applyMatrix4(kf.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Nf).negate(), this.translate(Nf.x, Nf.y, Nf.z), this } setFromPoints(e) { const t = []; for (let n = 0, r = e.length; n < r; n++) { const r = e[n]; t.push(r.x, r.y, r.z || 0) } return this.setAttribute("position", new Pf(t, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new Wh); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new Gh(-1 / 0, -1 / 0, -1 / 0), new Gh(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; Ff.setFromBufferAttribute(n), this.morphTargetsRelative ? (Uf.addVectors(this.boundingBox.min, Ff.min), this.boundingBox.expandByPoint(Uf), Uf.addVectors(this.boundingBox.max, Ff.max), this.boundingBox.expandByPoint(Uf)) : (this.boundingBox.expandByPoint(Ff.min), this.boundingBox.expandByPoint(Ff.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new cp); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new Gh, 1 / 0); if (e) { const n = this.boundingSphere.center; if (Ff.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; Of.setFromBufferAttribute(n), this.morphTargetsRelative ? (Uf.addVectors(Ff.min, Of.min), Ff.expandByPoint(Uf), Uf.addVectors(Ff.max, Of.max), Ff.expandByPoint(Uf)) : (Ff.expandByPoint(Of.min), Ff.expandByPoint(Of.max)) } Ff.getCenter(n); let r = 0; for (let t = 0, i = e.count; t < i; t++)Uf.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(Uf)); if (t) for (let i = 0, a = t.length; i < a; i++) { const a = t[i], o = this.morphTargetsRelative; for (let t = 0, i = a.count; t < i; t++)Uf.fromBufferAttribute(a, t), o && (Nf.fromBufferAttribute(e, t), Uf.add(Nf)), r = Math.max(r, n.distanceToSquared(Uf)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = t.position, r = t.normal, i = t.uv; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Mf(new Float32Array(4 * n.count), 4)); const a = this.getAttribute("tangent"), o = [], s = []; for (let e = 0; e < n.count; e++)o[e] = new Gh, s[e] = new Gh; const l = new Gh, c = new Gh, u = new Gh, d = new uh, h = new uh, p = new uh, f = new Gh, m = new Gh; function g(e, t, r) { l.fromBufferAttribute(n, e), c.fromBufferAttribute(n, t), u.fromBufferAttribute(n, r), d.fromBufferAttribute(i, e), h.fromBufferAttribute(i, t), p.fromBufferAttribute(i, r), c.sub(l), u.sub(l), h.sub(d), p.sub(d); const a = 1 / (h.x * p.y - p.x * h.y); isFinite(a) && (f.copy(c).multiplyScalar(p.y).addScaledVector(u, -h.y).multiplyScalar(a), m.copy(u).multiplyScalar(h.x).addScaledVector(c, -p.x).multiplyScalar(a), o[e].add(f), o[t].add(f), o[r].add(f), s[e].add(m), s[t].add(m), s[r].add(m)) } let v = this.groups; 0 === v.length && (v = [{ start: 0, count: e.count }]); for (let t = 0, n = v.length; t < n; ++t) { const n = v[t], r = n.start; for (let t = r, i = r + n.count; t < i; t += 3)g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2)) } const y = new Gh, b = new Gh, x = new Gh, A = new Gh; function S(e) { x.fromBufferAttribute(r, e), A.copy(x); const t = o[e]; y.copy(t), y.sub(x.multiplyScalar(x.dot(t))).normalize(), b.crossVectors(A, t); const n = b.dot(s[e]) < 0 ? -1 : 1; a.setXYZW(e, y.x, y.y, y.z, n) } for (let t = 0, n = v.length; t < n; ++t) { const n = v[t], r = n.start; for (let t = r, i = r + n.count; t < i; t += 3)S(e.getX(t + 0)), S(e.getX(t + 1)), S(e.getX(t + 2)) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let n = this.getAttribute("normal"); if (void 0 === n) n = new Mf(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++)n.setXYZ(e, 0, 0, 0); const r = new Gh, i = new Gh, a = new Gh, o = new Gh, s = new Gh, l = new Gh, c = new Gh, u = new Gh; if (e) for (let d = 0, h = e.count; d < h; d += 3) { const h = e.getX(d + 0), p = e.getX(d + 1), f = e.getX(d + 2); r.fromBufferAttribute(t, h), i.fromBufferAttribute(t, p), a.fromBufferAttribute(t, f), c.subVectors(a, i), u.subVectors(r, i), c.cross(u), o.fromBufferAttribute(n, h), s.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), o.add(c), s.add(c), l.add(c), n.setXYZ(h, o.x, o.y, o.z), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(f, l.x, l.y, l.z) } else for (let e = 0, o = t.count; e < o; e += 3)r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, i), u.subVectors(r, i), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, n = e.count; t < n; t++)Uf.fromBufferAttribute(e, t), Uf.normalize(), e.setXYZ(t, Uf.x, Uf.y, Uf.z) } toNonIndexed() { function e(e, t) { const n = e.array, r = e.itemSize, i = e.normalized, a = new n.constructor(t.length * r); let o = 0, s = 0; for (let i = 0, l = t.length; i < l; i++) { o = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * r; for (let e = 0; e < r; e++)a[s++] = n[o++] } return new Mf(a, r, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new zf, n = this.index.array, r = this.attributes; for (const i in r) { const a = e(r[i], n); t.setAttribute(i, a) } const i = this.morphAttributes; for (const r in i) { const a = [], o = i[r]; for (let t = 0, r = o.length; t < r; t++) { const r = e(o[t], n); a.push(r) } t.morphAttributes[r] = a } t.morphTargetsRelative = this.morphTargetsRelative; const a = this.groups; for (let e = 0, n = a.length; e < n; e++) { const n = a[e]; t.addGroup(n.start, n.count, n.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const n in t) void 0 !== t[n] && (e[n] = t[n]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const n = this.attributes; for (const t in n) { const r = n[t]; e.data.attributes[t] = r.toJSON(e.data) } const r = {}; let i = !1; for (const t in this.morphAttributes) { const n = this.morphAttributes[t], a = []; for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; a.push(r.toJSON(e.data)) } a.length > 0 && (r[t] = a, i = !0) } i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups; a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a))); const o = this.boundingSphere; return null !== o && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e } clone() { return (new this.constructor).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; null !== n && this.setIndex(n.clone(t)); const r = e.attributes; for (const e in r) { const n = r[e]; this.setAttribute(e, n.clone(t)) } const i = e.morphAttributes; for (const e in i) { const n = [], r = i[e]; for (let e = 0, i = r.length; e < i; e++)n.push(r[e].clone(t)); this.morphAttributes[e] = n } this.morphTargetsRelative = e.morphTargetsRelative; const a = e.groups; for (let e = 0, t = a.length; e < t; e++) { const t = a[e]; this.addGroup(t.start, t.count, t.materialIndex) } const o = e.boundingBox; null !== o && (this.boundingBox = o.clone()); const s = e.boundingSphere; return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const Hf = new yp, Gf = new vp, jf = new cp, Vf = new Gh, Wf = new Gh, Xf = new Gh, Jf = new Gh, Yf = new Gh, Qf = new Gh, Kf = new Gh, qf = new Gh; class Zf extends Wp { constructor(e = new zf, t = new mf) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { const t = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } getVertexPosition(e, t) { const n = this.geometry, r = n.attributes.position, i = n.morphAttributes.position, a = n.morphTargetsRelative; t.fromBufferAttribute(r, e); const o = this.morphTargetInfluences; if (i && o) { Qf.set(0, 0, 0); for (let n = 0, r = i.length; n < r; n++) { const r = o[n], s = i[n]; 0 !== r && (Yf.fromBufferAttribute(s, e), a ? Qf.addScaledVector(Yf, r) : Qf.addScaledVector(Yf.sub(t), r)) } t.add(Qf) } return t } raycast(e, t) { const n = this.geometry, r = this.material, i = this.matrixWorld; if (void 0 !== r) { if (null === n.boundingSphere && n.computeBoundingSphere(), jf.copy(n.boundingSphere), jf.applyMatrix4(i), Gf.copy(e.ray).recast(e.near), !1 === jf.containsPoint(Gf.origin)) { if (null === Gf.intersectSphere(jf, Vf)) return; if (Gf.origin.distanceToSquared(Vf) > (e.far - e.near) ** 2) return } Hf.copy(i).invert(), Gf.copy(e.ray).applyMatrix4(Hf), null !== n.boundingBox && !1 === Gf.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Gf) } } _computeIntersections(e, t, n) { let r; const i = this.geometry, a = this.material, o = i.index, s = i.attributes.position, l = i.attributes.uv, c = i.attributes.uv1, u = i.attributes.normal, d = i.groups, h = i.drawRange; if (null !== o) if (Array.isArray(a)) for (let i = 0, s = d.length; i < s; i++) { const s = d[i], p = a[s.materialIndex]; for (let i = Math.max(s.start, h.start), a = Math.min(o.count, Math.min(s.start + s.count, h.start + h.count)); i < a; i += 3)r = $f(this, p, e, n, l, c, u, o.getX(i), o.getX(i + 1), o.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = s.materialIndex, t.push(r)) } else for (let i = Math.max(0, h.start), s = Math.min(o.count, h.start + h.count); i < s; i += 3)r = $f(this, a, e, n, l, c, u, o.getX(i), o.getX(i + 1), o.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), t.push(r)); else if (void 0 !== s) if (Array.isArray(a)) for (let i = 0, o = d.length; i < o; i++) { const o = d[i], p = a[o.materialIndex]; for (let i = Math.max(o.start, h.start), a = Math.min(s.count, Math.min(o.start + o.count, h.start + h.count)); i < a; i += 3)r = $f(this, p, e, n, l, c, u, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = o.materialIndex, t.push(r)) } else for (let i = Math.max(0, h.start), o = Math.min(s.count, h.start + h.count); i < o; i += 3)r = $f(this, a, e, n, l, c, u, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), t.push(r)) } } function $f(e, t, n, r, i, a, o, s, l, c) { e.getVertexPosition(s, Wf), e.getVertexPosition(l, Xf), e.getVertexPosition(c, Jf); const u = function (e, t, n, r, i, a, o, s) { let l; if (l = t.side === Ml ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side === Sl, s), null === l) return null; qf.copy(s), qf.applyMatrix4(e.matrixWorld); const c = n.ray.origin.distanceTo(qf); return c < n.near || c > n.far ? null : { distance: c, point: qf.clone(), object: e } }(e, t, n, r, Wf, Xf, Jf, Kf); if (u) { const e = new Gh; of.getBarycoord(Kf, Wf, Xf, Jf, e), i && (u.uv = of.getInterpolatedAttribute(i, s, l, c, e, new uh)), a && (u.uv1 = of.getInterpolatedAttribute(a, s, l, c, e, new uh)), o && (u.normal = of.getInterpolatedAttribute(o, s, l, c, e, new Gh), u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1)); const t = { a: s, b: l, c, normal: new Gh, materialIndex: 0 }; of.getNormal(Wf, Xf, Jf, t.normal), u.face = t, u.barycoord = e } return u } class em extends zf { constructor(e = 1, t = 1, n = 1, r = 1, i = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: a }; const o = this; r = Math.floor(r), i = Math.floor(i), a = Math.floor(a); const s = [], l = [], c = [], u = []; let d = 0, h = 0; function p(e, t, n, r, i, a, p, f, m, g, v) { const y = a / m, b = p / g, x = a / 2, A = p / 2, S = f / 2, M = m + 1, w = g + 1; let _ = 0, E = 0; const C = new Gh; for (let a = 0; a < w; a++) { const o = a * b - A; for (let s = 0; s < M; s++) { const d = s * y - x; C[e] = d * r, C[t] = o * i, C[n] = S, l.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[n] = f > 0 ? 1 : -1, c.push(C.x, C.y, C.z), u.push(s / m), u.push(1 - a / g), _ += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < m; t++) { const n = d + t + M * e, r = d + t + M * (e + 1), i = d + (t + 1) + M * (e + 1), a = d + (t + 1) + M * e; s.push(n, r, a), s.push(r, i, a), E += 6 } o.addGroup(h, E, v), h += E, d += _ } p("z", "y", "x", -1, -1, n, t, e, a, i, 0), p("z", "y", "x", 1, -1, n, t, -e, a, i, 1), p("x", "z", "y", 1, 1, e, n, t, r, a, 2), p("x", "z", "y", 1, -1, e, n, -t, r, a, 3), p("x", "y", "z", 1, -1, e, t, n, r, i, 4), p("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(s), this.setAttribute("position", new Pf(l, 3)), this.setAttribute("normal", new Pf(c, 3)), this.setAttribute("uv", new Pf(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new em(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function tm(e) { const t = {}; for (const n in e) { t[n] = {}; for (const r in e[n]) { const i = e[n][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][r] = null) : t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i } } return t } function nm(e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = tm(e[n]); for (const e in r) t[e] = r[e] } return t } function rm(e) { const t = e.getRenderTarget(); return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : wh.workingColorSpace } const im = { clone: tm, merge: nm }; class am extends ff { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = tm(e.uniforms), this.uniformsGroups = function (e) { const t = []; for (let n = 0; n < e.length; n++)t.push(e[n].clone()); return t }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const n in this.uniforms) { const r = this.uniforms[n].value; r && r.isTexture ? t.uniforms[n] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[n] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[n] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[n] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[n] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[n] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[n] = { type: "m4", value: r.toArray() } : t.uniforms[n] = { value: r } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; const n = {}; for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0); return Object.keys(n).length > 0 && (t.extensions = n), t } } class om extends Wp { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new yp, this.projectionMatrix = new yp, this.projectionMatrixInverse = new yp, this.coordinateSystem = Kd } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } const sm = new Gh, lm = new uh, cm = new uh; class um extends om { constructor(e = 50, t = 1, n = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * nh * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(.5 * th * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * nh * Math.atan(Math.tan(.5 * th * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(e, t, n) { sm.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(sm.x, sm.y).multiplyScalar(-e / sm.z), sm.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(sm.x, sm.y).multiplyScalar(-e / sm.z) } getViewSize(e, t) { return this.getViewBounds(e, lm, cm), t.subVectors(cm, lm) } setViewOffset(e, t, n, r, i, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * th * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, i = -.5 * r; const a = this.view; if (null !== this.view && this.view.enabled) { const e = a.fullWidth, o = a.fullHeight; i += a.offsetX * r / e, t -= a.offsetY * n / o, r *= a.width / e, n *= a.height / o } const o = this.filmOffset; 0 !== o && (i += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const dm = -90; class hm extends Wp { constructor(e, t, n) { super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0; const r = new um(dm, 1, e, t); r.layers = this.layers, this.add(r); const i = new um(dm, 1, e, t); i.layers = this.layers, this.add(i); const a = new um(dm, 1, e, t); a.layers = this.layers, this.add(a); const o = new um(dm, 1, e, t); o.layers = this.layers, this.add(o); const s = new um(dm, 1, e, t); s.layers = this.layers, this.add(s); const l = new um(dm, 1, e, t); l.layers = this.layers, this.add(l) } updateCoordinateSystem() { const e = this.coordinateSystem, t = this.children.concat(), [n, r, i, a, o, s] = t; for (const e of t) this.remove(e); if (e === Kd) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), i.up.set(0, 0, -1), i.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), s.up.set(0, 1, 0), s.lookAt(0, 0, -1); else { if (e !== qd) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), i.up.set(0, 0, 1), i.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), s.up.set(0, -1, 0), s.lookAt(0, 0, -1) } for (const e of t) this.add(e), e.updateMatrixWorld() } update(e, t) { null === this.parent && this.updateMatrixWorld(); const { renderTarget: n, activeMipmapLevel: r } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [i, a, o, s, l, c] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), h = e.getActiveMipmapLevel(), p = e.xr.enabled; e.xr.enabled = !1; const f = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, i), e.setRenderTarget(n, 1, r), e.render(t, a), e.setRenderTarget(n, 2, r), e.render(t, o), e.setRenderTarget(n, 3, r), e.render(t, s), e.setRenderTarget(n, 4, r), e.render(t, l), n.texture.generateMipmaps = f, e.setRenderTarget(n, 5, r), e.render(t, c), e.setRenderTarget(u, d, h), e.xr.enabled = p, n.texture.needsPMREMUpdate = !0 } } class pm extends Lh { constructor(e, t, n, r, i, a, o, s, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : bc, n, r, i, a, o, s, l, c), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class fm extends Nh { constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const n = { width: e, height: e, depth: 1 }, r = [n, n, n, n, n, n]; this.texture = new pm(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : Pc } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { tEquirect: { value: null } }, r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t", a = new em(5, 5, 5), o = new am({ name: "CubemapFromEquirect", uniforms: tm(n), vertexShader: r, fragmentShader: i, side: Ml, blending: _l }); o.uniforms.tEquirect.value = t; const s = new Zf(a, o), l = t.minFilter; return t.minFilter === kc && (t.minFilter = Pc), new hm(1, 10, this).update(e, s), t.minFilter = l, s.geometry.dispose(), s.material.dispose(), this } clear(e, t, n, r) { const i = e.getRenderTarget(); for (let i = 0; i < 6; i++)e.setRenderTarget(this, i), e.clear(t, n, r); e.setRenderTarget(i) } } const mm = new Gh, gm = new Gh, vm = new dh; class ym { constructor(e = new Gh(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, r) { return this.normal.set(e, t, n), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { const r = mm.subVectors(n, t).cross(gm.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const n = e.delta(mm), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; const i = -(e.start.dot(this.normal) + this.constant) / r; return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(n, i) } intersectsLine(e) { const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || vm.getNormalMatrix(e), r = this.coplanarPoint(mm).applyMatrix4(e), i = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(i), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } const bm = new cp, xm = new Gh; class Am { constructor(e = new ym, t = new ym, n = new ym, r = new ym, i = new ym, a = new ym) { this.planes = [e, t, n, r, i, a] } set(e, t, n, r, i, a) { const o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this } copy(e) { const t = this.planes; for (let n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } setFromProjectionMatrix(e, t = Kd) { const n = this.planes, r = e.elements, i = r[0], a = r[1], o = r[2], s = r[3], l = r[4], c = r[5], u = r[6], d = r[7], h = r[8], p = r[9], f = r[10], m = r[11], g = r[12], v = r[13], y = r[14], b = r[15]; if (n[0].setComponents(s - i, d - l, m - h, b - g).normalize(), n[1].setComponents(s + i, d + l, m + h, b + g).normalize(), n[2].setComponents(s + a, d + c, m + p, b + v).normalize(), n[3].setComponents(s - a, d - c, m - p, b - v).normalize(), n[4].setComponents(s - o, d - u, m - f, b - y).normalize(), t === Kd) n[5].setComponents(s + o, d + u, m + f, b + y).normalize(); else { if (t !== qd) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); n[5].setComponents(o, u, f, y).normalize() } return this } intersectsObject(e) { if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), bm.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const t = e.geometry; null === t.boundingSphere && t.computeBoundingSphere(), bm.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(bm) } intersectsSprite(e) { return bm.center.set(0, 0, 0), bm.radius = .7071067811865476, bm.applyMatrix4(e.matrixWorld), this.intersectsSphere(bm) } intersectsSphere(e) { const t = this.planes, n = e.center, r = -e.radius; for (let e = 0; e < 6; e++)if (t[e].distanceToPoint(n) < r) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let n = 0; n < 6; n++) { const r = t[n]; if (xm.x = r.normal.x > 0 ? e.max.x : e.min.x, xm.y = r.normal.y > 0 ? e.max.y : e.min.y, xm.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(xm) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function Sm() { let e = null, t = !1, n = null, r = null; function i(t, a) { n(t, a), r = e.requestAnimationFrame(i) } return { start: function () { !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0) }, stop: function () { e.cancelAnimationFrame(r), t = !1 }, setAnimationLoop: function (e) { n = e }, setContext: function (t) { e = t } } } function Mm(e) { const t = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), t.get(e) }, remove: function (n) { n.isInterleavedBufferAttribute && (n = n.data); const r = t.get(n); r && (e.deleteBuffer(r.buffer), t.delete(n)) }, update: function (n, r) { if (n.isInterleavedBufferAttribute && (n = n.data), n.isGLBufferAttribute) { const e = t.get(n); return void ((!e || e.version < n.version) && t.set(n, { buffer: n.buffer, type: n.type, bytesPerElement: n.elementSize, version: n.version })) } const i = t.get(n); if (void 0 === i) t.set(n, function (t, n) { const r = t.array, i = t.usage, a = r.byteLength, o = e.createBuffer(); let s; if (e.bindBuffer(n, o), e.bufferData(n, r, i), t.onUploadCallback(), r instanceof Float32Array) s = e.FLOAT; else if (r instanceof Uint16Array) s = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT; else if (r instanceof Int16Array) s = e.SHORT; else if (r instanceof Uint32Array) s = e.UNSIGNED_INT; else if (r instanceof Int32Array) s = e.INT; else if (r instanceof Int8Array) s = e.BYTE; else if (r instanceof Uint8Array) s = e.UNSIGNED_BYTE; else { if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r); s = e.UNSIGNED_BYTE } return { buffer: o, type: s, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version, size: a } }(n, r)); else if (i.version < n.version) { if (i.size !== n.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); !function (t, n, r) { const i = n.array, a = n.updateRanges; if (e.bindBuffer(r, t), 0 === a.length) e.bufferSubData(r, 0, i); else { a.sort(((e, t) => e.start - t.start)); let t = 0; for (let e = 1; e < a.length; e++) { const n = a[t], r = a[e]; r.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, r.start + r.count - n.start) : (++t, a[t] = r) } a.length = t + 1; for (let t = 0, n = a.length; t < n; t++) { const n = a[t]; e.bufferSubData(r, n.start * i.BYTES_PER_ELEMENT, i, n.start, n.count) } n.clearUpdateRanges() } n.onUploadCallback() }(i.buffer, n, r), i.version = n.version } } } } class wm extends zf { constructor(e = 1, t = 1, n = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: r }; const i = e / 2, a = t / 2, o = Math.floor(n), s = Math.floor(r), l = o + 1, c = s + 1, u = e / o, d = t / s, h = [], p = [], f = [], m = []; for (let e = 0; e < c; e++) { const t = e * d - a; for (let n = 0; n < l; n++) { const r = n * u - i; p.push(r, -t, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - e / s) } } for (let e = 0; e < s; e++)for (let t = 0; t < o; t++) { const n = t + l * e, r = t + l * (e + 1), i = t + 1 + l * (e + 1), a = t + 1 + l * e; h.push(n, r, a), h.push(r, i, a) } this.setIndex(h), this.setAttribute("position", new Pf(p, 3)), this.setAttribute("normal", new Pf(f, 3)), this.setAttribute("uv", new Pf(m, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new wm(e.width, e.height, e.widthSegments, e.heightSegments) } } const _m = { alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif", alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif", alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif", batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif", begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;", normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif", opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif", uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif", uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif", uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}" }, Em = { common: { diffuse: { value: new df(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new dh }, alphaMap: { value: null }, alphaMapTransform: { value: new dh }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new dh } }, envmap: { envMap: { value: null }, envMapRotation: { value: new dh }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new dh } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new dh } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new dh }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new dh }, normalScale: { value: new uh(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new dh }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new dh } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new dh } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new dh } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new df(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new df(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new dh }, alphaTest: { value: 0 }, uvTransform: { value: new dh } }, sprite: { diffuse: { value: new df(16777215) }, opacity: { value: 1 }, center: { value: new uh(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new dh }, alphaMap: { value: null }, alphaMapTransform: { value: new dh }, alphaTest: { value: 0 } } }, Cm = { basic: { uniforms: nm([Em.common, Em.specularmap, Em.envmap, Em.aomap, Em.lightmap, Em.fog]), vertexShader: _m.meshbasic_vert, fragmentShader: _m.meshbasic_frag }, lambert: { uniforms: nm([Em.common, Em.specularmap, Em.envmap, Em.aomap, Em.lightmap, Em.emissivemap, Em.bumpmap, Em.normalmap, Em.displacementmap, Em.fog, Em.lights, { emissive: { value: new df(0) } }]), vertexShader: _m.meshlambert_vert, fragmentShader: _m.meshlambert_frag }, phong: { uniforms: nm([Em.common, Em.specularmap, Em.envmap, Em.aomap, Em.lightmap, Em.emissivemap, Em.bumpmap, Em.normalmap, Em.displacementmap, Em.fog, Em.lights, { emissive: { value: new df(0) }, specular: { value: new df(1118481) }, shininess: { value: 30 } }]), vertexShader: _m.meshphong_vert, fragmentShader: _m.meshphong_frag }, standard: { uniforms: nm([Em.common, Em.envmap, Em.aomap, Em.lightmap, Em.emissivemap, Em.bumpmap, Em.normalmap, Em.displacementmap, Em.roughnessmap, Em.metalnessmap, Em.fog, Em.lights, { emissive: { value: new df(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: _m.meshphysical_vert, fragmentShader: _m.meshphysical_frag }, toon: { uniforms: nm([Em.common, Em.aomap, Em.lightmap, Em.emissivemap, Em.bumpmap, Em.normalmap, Em.displacementmap, Em.gradientmap, Em.fog, Em.lights, { emissive: { value: new df(0) } }]), vertexShader: _m.meshtoon_vert, fragmentShader: _m.meshtoon_frag }, matcap: { uniforms: nm([Em.common, Em.bumpmap, Em.normalmap, Em.displacementmap, Em.fog, { matcap: { value: null } }]), vertexShader: _m.meshmatcap_vert, fragmentShader: _m.meshmatcap_frag }, points: { uniforms: nm([Em.points, Em.fog]), vertexShader: _m.points_vert, fragmentShader: _m.points_frag }, dashed: { uniforms: nm([Em.common, Em.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: _m.linedashed_vert, fragmentShader: _m.linedashed_frag }, depth: { uniforms: nm([Em.common, Em.displacementmap]), vertexShader: _m.depth_vert, fragmentShader: _m.depth_frag }, normal: { uniforms: nm([Em.common, Em.bumpmap, Em.normalmap, Em.displacementmap, { opacity: { value: 1 } }]), vertexShader: _m.meshnormal_vert, fragmentShader: _m.meshnormal_frag }, sprite: { uniforms: nm([Em.sprite, Em.fog]), vertexShader: _m.sprite_vert, fragmentShader: _m.sprite_frag }, background: { uniforms: { uvTransform: { value: new dh }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: _m.background_vert, fragmentShader: _m.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new dh } }, vertexShader: _m.backgroundCube_vert, fragmentShader: _m.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: _m.cube_vert, fragmentShader: _m.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: _m.equirect_vert, fragmentShader: _m.equirect_frag }, distanceRGBA: { uniforms: nm([Em.common, Em.displacementmap, { referencePosition: { value: new Gh }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: _m.distanceRGBA_vert, fragmentShader: _m.distanceRGBA_frag }, shadow: { uniforms: nm([Em.lights, Em.fog, { color: { value: new df(0) }, opacity: { value: 1 } }]), vertexShader: _m.shadow_vert, fragmentShader: _m.shadow_frag } }; Cm.physical = { uniforms: nm([Cm.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new dh }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new dh }, clearcoatNormalScale: { value: new uh(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new dh }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new dh }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new dh }, sheen: { value: 0 }, sheenColor: { value: new df(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new dh }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new dh }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new dh }, transmissionSamplerSize: { value: new uh }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new dh }, attenuationDistance: { value: 0 }, attenuationColor: { value: new df(0) }, specularColor: { value: new df(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new dh }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new dh }, anisotropyVector: { value: new uh }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new dh } }]), vertexShader: _m.meshphysical_vert, fragmentShader: _m.meshphysical_frag }; const Tm = { r: 0, b: 0, g: 0 }, Rm = new Tp, Bm = new yp; function Im(e, t, n, r, i, a, o) { const s = new df(0); let l, c, u = !0 === a ? 0 : 1, d = null, h = 0, p = null; function f(e) { let r = !0 === e.isScene ? e.background : null; return r && r.isTexture && (r = (e.backgroundBlurriness > 0 ? n : t).get(r)), r } function m(t, n) { t.getRGB(Tm, rm(e)), r.buffers.color.setClear(Tm.r, Tm.g, Tm.b, n, o) } return { getClearColor: function () { return s }, setClearColor: function (e, t = 1) { s.set(e), u = t, m(s, u) }, getClearAlpha: function () { return u }, setClearAlpha: function (e) { u = e, m(s, u) }, render: function (t) { let n = !1; const i = f(t); null === i ? m(s, u) : i && i.isColor && (m(i, 1), n = !0); const a = e.xr.getEnvironmentBlendMode(); "additive" === a ? r.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === a && r.buffers.color.setClear(0, 0, 0, 0, o), (e.autoClear || n) && (r.buffers.depth.setTest(!0), r.buffers.depth.setMask(!0), r.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)) }, addToRenderList: function (t, n) { const r = f(n); r && (r.isCubeTexture || r.mapping === Mc) ? (void 0 === c && (c = new Zf(new em(1, 1, 1), new am({ name: "BackgroundCubeMaterial", uniforms: tm(Cm.backgroundCube.uniforms), vertexShader: Cm.backgroundCube.vertexShader, fragmentShader: Cm.backgroundCube.fragmentShader, side: Ml, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(c.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(c)), Rm.copy(n.backgroundRotation), Rm.x *= -1, Rm.y *= -1, Rm.z *= -1, r.isCubeTexture && !1 === r.isRenderTargetTexture && (Rm.y *= -1, Rm.z *= -1), c.material.uniforms.envMap.value = r, c.material.uniforms.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(Bm.makeRotationFromEuler(Rm)), c.material.toneMapped = wh.getTransfer(r.colorSpace) !== hd, d === r && h === r.version && p === e.toneMapping || (c.material.needsUpdate = !0, d = r, h = r.version, p = e.toneMapping), c.layers.enableAll(), t.unshift(c, c.geometry, c.material, 0, 0, null)) : r && r.isTexture && (void 0 === l && (l = new Zf(new wm(2, 2), new am({ name: "BackgroundMaterial", uniforms: tm(Cm.background.uniforms), vertexShader: Cm.background.vertexShader, fragmentShader: Cm.background.fragmentShader, side: Sl, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(l)), l.material.uniforms.t2D.value = r, l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, l.material.toneMapped = wh.getTransfer(r.colorSpace) !== hd, !0 === r.matrixAutoUpdate && r.updateMatrix(), l.material.uniforms.uvTransform.value.copy(r.matrix), d === r && h === r.version && p === e.toneMapping || (l.material.needsUpdate = !0, d = r, h = r.version, p = e.toneMapping), l.layers.enableAll(), t.unshift(l, l.geometry, l.material, 0, 0, null)) } } } function Pm(e, t) { const n = e.getParameter(e.MAX_VERTEX_ATTRIBS), r = {}, i = c(null); let a = i, o = !1; function s(t) { return e.bindVertexArray(t) } function l(t) { return e.deleteVertexArray(t) } function c(e) { const t = [], r = [], i = []; for (let e = 0; e < n; e++)t[e] = 0, r[e] = 0, i[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: r, attributeDivisors: i, object: e, attributes: {}, index: null } } function u() { const e = a.newAttributes; for (let t = 0, n = e.length; t < n; t++)e[t] = 0 } function d(e) { h(e, 0) } function h(t, n) { const r = a.newAttributes, i = a.enabledAttributes, o = a.attributeDivisors; r[t] = 1, 0 === i[t] && (e.enableVertexAttribArray(t), i[t] = 1), o[t] !== n && (e.vertexAttribDivisor(t, n), o[t] = n) } function p() { const t = a.newAttributes, n = a.enabledAttributes; for (let r = 0, i = n.length; r < i; r++)n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0) } function f(t, n, r, i, a, o, s) { !0 === s ? e.vertexAttribIPointer(t, n, r, a, o) : e.vertexAttribPointer(t, n, r, i, a, o) } function m() { g(), o = !0, a !== i && (a = i, s(a.object)) } function g() { i.geometry = null, i.program = null, i.wireframe = !1 } return { setup: function (n, i, l, m, g) { let v = !1; const y = function (t, n, i) { const a = !0 === i.wireframe; let o = r[t.id]; void 0 === o && (o = {}, r[t.id] = o); let s = o[n.id]; void 0 === s && (s = {}, o[n.id] = s); let l = s[a]; return void 0 === l && (l = c(e.createVertexArray()), s[a] = l), l }(m, l, i); a !== y && (a = y, s(a.object)), v = function (e, t, n, r) { const i = a.attributes, o = t.attributes; let s = 0; const l = n.getAttributes(); for (const t in l) if (l[t].location >= 0) { const n = i[t]; let r = o[t]; if (void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (r = e.instanceColor)), void 0 === n) return !0; if (n.attribute !== r) return !0; if (r && n.data !== r.data) return !0; s++ } return a.attributesNum !== s || a.index !== r }(n, m, l, g), v && function (e, t, n, r) { const i = {}, o = t.attributes; let s = 0; const l = n.getAttributes(); for (const t in l) if (l[t].location >= 0) { let n = o[t]; void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor)); const r = {}; r.attribute = n, n && n.data && (r.data = n.data), i[t] = r, s++ } a.attributes = i, a.attributesNum = s, a.index = r }(n, m, l, g), null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER), (v || o) && (o = !1, function (n, r, i, a) { u(); const o = a.attributes, s = i.getAttributes(), l = r.defaultAttributeValues; for (const r in s) { const i = s[r]; if (i.location >= 0) { let s = o[r]; if (void 0 === s && ("instanceMatrix" === r && n.instanceMatrix && (s = n.instanceMatrix), "instanceColor" === r && n.instanceColor && (s = n.instanceColor)), void 0 !== s) { const r = s.normalized, o = s.itemSize, l = t.get(s); if (void 0 === l) continue; const c = l.buffer, u = l.type, p = l.bytesPerElement, m = u === e.INT || u === e.UNSIGNED_INT || s.gpuType === Hc; if (s.isInterleavedBufferAttribute) { const t = s.data, l = t.stride, g = s.offset; if (t.isInstancedInterleavedBuffer) { for (let e = 0; e < i.locationSize; e++)h(i.location + e, t.meshPerAttribute); !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = t.meshPerAttribute * t.count) } else for (let e = 0; e < i.locationSize; e++)d(i.location + e); e.bindBuffer(e.ARRAY_BUFFER, c); for (let e = 0; e < i.locationSize; e++)f(i.location + e, o / i.locationSize, u, r, l * p, (g + o / i.locationSize * e) * p, m) } else { if (s.isInstancedBufferAttribute) { for (let e = 0; e < i.locationSize; e++)h(i.location + e, s.meshPerAttribute); !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count) } else for (let e = 0; e < i.locationSize; e++)d(i.location + e); e.bindBuffer(e.ARRAY_BUFFER, c); for (let e = 0; e < i.locationSize; e++)f(i.location + e, o / i.locationSize, u, r, o * p, o / i.locationSize * e * p, m) } } else if (void 0 !== l) { const t = l[r]; if (void 0 !== t) switch (t.length) { case 2: e.vertexAttrib2fv(i.location, t); break; case 3: e.vertexAttrib3fv(i.location, t); break; case 4: e.vertexAttrib4fv(i.location, t); break; default: e.vertexAttrib1fv(i.location, t) } } } } p() }(n, i, l, m), null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer)) }, reset: m, resetDefaultState: g, dispose: function () { m(); for (const e in r) { const t = r[e]; for (const e in t) { const n = t[e]; for (const e in n) l(n[e].object), delete n[e]; delete t[e] } delete r[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === r[e.id]) return; const t = r[e.id]; for (const e in t) { const n = t[e]; for (const e in n) l(n[e].object), delete n[e]; delete t[e] } delete r[e.id] }, releaseStatesOfProgram: function (e) { for (const t in r) { const n = r[t]; if (void 0 === n[e.id]) continue; const i = n[e.id]; for (const e in i) l(i[e].object), delete i[e]; delete n[e.id] } }, initAttributes: u, enableAttribute: d, disableUnusedAttributes: p } } function Lm(e, t, n) { let r; function i(t, i, a) { 0 !== a && (e.drawArraysInstanced(r, t, i, a), n.update(i, r, a)) } this.setMode = function (e) { r = e }, this.render = function (t, i) { e.drawArrays(r, t, i), n.update(i, r, 1) }, this.renderInstances = i, this.renderMultiDraw = function (e, i, a) { if (0 === a) return; t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, e, 0, i, 0, a); let o = 0; for (let e = 0; e < a; e++)o += i[e]; n.update(o, r, 1) }, this.renderMultiDrawInstances = function (e, a, o, s) { if (0 === o) return; const l = t.get("WEBGL_multi_draw"); if (null === l) for (let t = 0; t < e.length; t++)i(e[t], a[t], s[t]); else { l.multiDrawArraysInstancedWEBGL(r, e, 0, a, 0, s, 0, o); let t = 0; for (let e = 0; e < o; e++)t += a[e]; for (let e = 0; e < s.length; e++)n.update(t, r, s[e]) } } } function Dm(e, t, n, r) { let i; function a(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let o = void 0 !== n.precision ? n.precision : "highp"; const s = a(o); s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); const l = !0 === n.logarithmicDepthBuffer, c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control"); if (!0 === c) { const e = t.get("EXT_clip_control"); e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) } const u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS); return { isWebGL2: !0, getMaxAnisotropy: function () { if (void 0 !== i) return i; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const n = t.get("EXT_texture_filter_anisotropic"); i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i }, getMaxPrecision: a, textureFormatReadable: function (t) { return t === qc || r.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT) }, textureTypeReadable: function (n) { const i = n === Vc && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float")); return !(n !== Fc && r.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== jc && !i) }, precision: o, logarithmicDepthBuffer: l, reverseDepthBuffer: c, maxTextures: u, maxVertexTextures: d, maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE), maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS), maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS), maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures: d > 0, maxSamples: e.getParameter(e.MAX_SAMPLES) } } function km(e) { const t = this; let n = null, r = 0, i = !1, a = !1; const o = new ym, s = new dh, l = { value: null, needsUpdate: !1 }; function c(e, n, r, i) { const a = null !== e ? e.length : 0; let c = null; if (0 !== a) { if (c = l.value, !0 !== i || null === c) { const t = r + 4 * a, i = n.matrixWorldInverse; s.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, n = r; t !== a; ++t, n += 4)o.copy(e[t]).applyMatrix4(i, s), o.normal.toArray(c, n), c[n + 3] = o.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = a, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t) { const n = 0 !== e.length || t || 0 !== r || i; return i = t, r = e.length, n }, this.beginShadows = function () { a = !0, c(null) }, this.endShadows = function () { a = !1 }, this.setGlobalState = function (e, t) { n = c(e, t, 0) }, this.setState = function (o, s, u) { const d = o.clippingPlanes, h = o.clipIntersection, p = o.clipShadows, f = e.get(o); if (!i || null === d || 0 === d.length || a && !p) a ? c(null) : (l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0); else { const e = a ? 0 : r, t = 4 * e; let i = f.clippingState || null; l.value = i, i = c(d, s, t, u); for (let e = 0; e !== t; ++e)i[e] = n[e]; f.clippingState = i, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += e } } } function Nm(e) { let t = new WeakMap; function n(e, t) { return t === Ac ? e.mapping = bc : t === Sc && (e.mapping = xc), e } function r(e) { const n = e.target; n.removeEventListener("dispose", r); const i = t.get(n); void 0 !== i && (t.delete(n), i.dispose()) } return { get: function (i) { if (i && i.isTexture) { const a = i.mapping; if (a === Ac || a === Sc) { if (t.has(i)) return n(t.get(i).texture, i.mapping); { const a = i.image; if (a && a.height > 0) { const o = new fm(a.height); return o.fromEquirectangularTexture(e, i), t.set(i, o), i.addEventListener("dispose", r), n(o.texture, i.mapping) } return null } } } return i }, dispose: function () { t = new WeakMap } } } class Fm extends om { constructor(e = -1, t = 1, n = 1, r = -1, i = .1, a = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = a, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, r, i, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let i = n - e, a = n + e, o = r + t, s = r - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; i += e * this.view.offsetX, a = i + e * this.view.width, o -= t * this.view.offsetY, s = o - t * this.view.height } this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } const Om = [.125, .215, .35, .446, .526, .582], Um = new Fm, zm = new df; let Hm = null, Gm = 0, jm = 0, Vm = !1; const Wm = (1 + Math.sqrt(5)) / 2, Xm = 1 / Wm, Jm = [new Gh(-Wm, Xm, 0), new Gh(Wm, Xm, 0), new Gh(-Xm, 0, Wm), new Gh(Xm, 0, Wm), new Gh(0, Wm, -Xm), new Gh(0, Wm, Xm), new Gh(-1, 1, -1), new Gh(1, 1, -1), new Gh(-1, 1, 1), new Gh(1, 1, 1)]; class Ym { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, n = .1, r = 100) { Hm = this._renderer.getRenderTarget(), Gm = this._renderer.getActiveCubeFace(), jm = this._renderer.getActiveMipmapLevel(), Vm = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256); const i = this._allocateTargets(); return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = Zm(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = qm(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(Hm, Gm, jm), this._renderer.xr.enabled = Vm, e.scissorTest = !1, Km(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === bc || e.mapping === xc ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Hm = this._renderer.getRenderTarget(), Gm = this._renderer.getActiveCubeFace(), jm = this._renderer.getActiveMipmapLevel(), Vm = this._renderer.xr.enabled, this._renderer.xr.enabled = !1; const n = t || this._allocateTargets(); return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = { magFilter: Pc, minFilter: Pc, generateMipmaps: !1, type: Vc, format: qc, colorSpace: ld, depthBuffer: !1 }, r = Qm(e, t, n); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Qm(e, t, n); const { _lodMax: r } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (e) { const t = [], n = [], r = []; let i = e; const a = e - 4 + 1 + Om.length; for (let o = 0; o < a; o++) { const a = Math.pow(2, i); n.push(a); let s = 1 / a; o > e - 4 ? s = Om[o - e + 4 - 1] : 0 === o && (s = 0), r.push(s); const l = 1 / (a - 2), c = -l, u = 1 + l, d = [c, c, u, c, u, u, c, c, u, u, c, u], h = 6, p = 6, f = 3, m = 2, g = 1, v = new Float32Array(f * p * h), y = new Float32Array(m * p * h), b = new Float32Array(g * p * h); for (let e = 0; e < h; e++) { const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : -1, r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0]; v.set(r, f * p * e), y.set(d, m * p * e); const i = [e, e, e, e, e, e]; b.set(i, g * p * e) } const x = new zf; x.setAttribute("position", new Mf(v, f)), x.setAttribute("uv", new Mf(y, m)), x.setAttribute("faceIndex", new Mf(b, g)), t.push(x), i > 4 && i-- } return { lodPlanes: t, sizeLods: n, sigmas: r } }(r)), this._blurMaterial = function (e, t, n) { const r = new Float32Array(20), i = new Gh(0, 1, 0); return new am({ name: "SphericalGaussianBlur", defines: { n: 20, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${e}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t", blending: _l, depthTest: !1, depthWrite: !1 }) }(r, e, t) } return r } _compileMaterial(e) { const t = new Zf(this._lodPlanes[0], e); this._renderer.compile(t, Um) } _sceneToCubeUV(e, t, n, r) { const i = new um(90, 1, t, n), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], s = this._renderer, l = s.autoClear, c = s.toneMapping; s.getClearColor(zm), s.toneMapping = lc, s.autoClear = !1; const u = new mf({ name: "PMREM.Background", side: Ml, depthWrite: !1, depthTest: !1 }), d = new Zf(new em, u); let h = !1; const p = e.background; p ? p.isColor && (u.color.copy(p), e.background = null, h = !0) : (u.color.copy(zm), h = !0); for (let t = 0; t < 6; t++) { const n = t % 3; 0 === n ? (i.up.set(0, a[t], 0), i.lookAt(o[t], 0, 0)) : 1 === n ? (i.up.set(0, 0, a[t]), i.lookAt(0, o[t], 0)) : (i.up.set(0, a[t], 0), i.lookAt(0, 0, o[t])); const l = this._cubeSize; Km(r, n * l, t > 2 ? l : 0, l, l), s.setRenderTarget(r), h && s.render(d, i), s.render(e, i) } d.geometry.dispose(), d.material.dispose(), s.toneMapping = c, s.autoClear = l, e.background = p } _textureToCubeUV(e, t) { const n = this._renderer, r = e.mapping === bc || e.mapping === xc; r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Zm()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = qm()); const i = r ? this._cubemapMaterial : this._equirectMaterial, a = new Zf(this._lodPlanes[0], i); i.uniforms.envMap.value = e; const o = this._cubeSize; Km(t, 0, 0, 3 * o, 2 * o), n.setRenderTarget(t), n.render(a, Um) } _applyPMREM(e) { const t = this._renderer, n = t.autoClear; t.autoClear = !1; const r = this._lodPlanes.length; for (let t = 1; t < r; t++) { const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]), i = Jm[(r - t - 1) % Jm.length]; this._blur(e, t - 1, t, n, i) } t.autoClear = n } _blur(e, t, n, r, i) { const a = this._pingPongRenderTarget; this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i) } _halfBlur(e, t, n, r, i, a, o) { const s = this._renderer, l = this._blurMaterial; "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"); const c = new Zf(this._lodPlanes[r], l), u = l.uniforms, d = this._sizeLods[n] - 1, h = isFinite(i) ? Math.PI / (2 * d) : 2 * Math.PI / 39, p = i / h, f = isFinite(i) ? 1 + Math.floor(3 * p) : 20; f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`); const m = []; let g = 0; for (let e = 0; e < 20; ++e) { const t = e / p, n = Math.exp(-t * t / 2); m.push(n), 0 === e ? g += n : e < f && (g += 2 * n) } for (let e = 0; e < m.length; e++)m[e] = m[e] / g; u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, o && (u.poleAxis.value = o); const { _lodMax: v } = this; u.dTheta.value = h, u.mipInt.value = v - n; const y = this._sizeLods[r]; Km(t, 3 * y * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y), s.setRenderTarget(t), s.render(c, Um) } } function Qm(e, t, n) { const r = new Nh(e, t, n); return r.texture.mapping = Mc, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r } function Km(e, t, n, r, i) { e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i) } function qm() { return new am({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t", blending: _l, depthTest: !1, depthWrite: !1 }) } function Zm() { return new am({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t", blending: _l, depthTest: !1, depthWrite: !1 }) } function $m(e) { let t = new WeakMap, n = null; function r(e) { const n = e.target; n.removeEventListener("dispose", r); const i = t.get(n); void 0 !== i && (t.delete(n), i.dispose()) } return { get: function (i) { if (i && i.isTexture) { const a = i.mapping, o = a === Ac || a === Sc, s = a === bc || a === xc; if (o || s) { let a = t.get(i); const l = void 0 !== a ? a.texture.pmremVersion : 0; if (i.isRenderTargetTexture && i.pmremVersion !== l) return null === n && (n = new Ym(e)), a = o ? n.fromEquirectangular(i, a) : n.fromCubemap(i, a), a.texture.pmremVersion = i.pmremVersion, t.set(i, a), a.texture; if (void 0 !== a) return a.texture; { const l = i.image; return o && l && l.height > 0 || s && l && function (e) { let t = 0; for (let n = 0; n < 6; n++)void 0 !== e[n] && t++; return 6 === t }(l) ? (null === n && (n = new Ym(e)), a = o ? n.fromEquirectangular(i) : n.fromCubemap(i), a.texture.pmremVersion = i.pmremVersion, t.set(i, a), i.addEventListener("dispose", r), a.texture) : null } } } return i }, dispose: function () { t = new WeakMap, null !== n && (n.dispose(), n = null) } } } function eg(e) { const t = {}; function n(n) { if (void 0 !== t[n]) return t[n]; let r; switch (n) { case "WEBGL_depth_texture": r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = e.getExtension(n) }return t[n] = r, r } return { has: function (e) { return null !== n(e) }, init: function () { n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent") }, get: function (e) { const t = n(e); return null === t && bh("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function tg(e, t, n, r) { const i = {}, a = new WeakMap; function o(e) { const s = e.target; null !== s.index && t.remove(s.index); for (const e in s.attributes) t.remove(s.attributes[e]); for (const e in s.morphAttributes) { const n = s.morphAttributes[e]; for (let e = 0, r = n.length; e < r; e++)t.remove(n[e]) } s.removeEventListener("dispose", o), delete i[s.id]; const l = a.get(s); l && (t.remove(l), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries-- } function s(e) { const n = [], r = e.index, i = e.attributes.position; let o = 0; if (null !== r) { const e = r.array; o = r.version; for (let t = 0, r = e.length; t < r; t += 3) { const r = e[t + 0], i = e[t + 1], a = e[t + 2]; n.push(r, i, i, a, a, r) } } else { if (void 0 === i) return; { const e = i.array; o = i.version; for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) { const e = t + 0, r = t + 1, i = t + 2; n.push(e, r, r, i, i, e) } } } const s = new (ph(n) ? Bf : Tf)(n, 1); s.version = o; const l = a.get(e); l && t.remove(l), a.set(e, s) } return { get: function (e, t) { return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t.id] = !0, n.memory.geometries++), t }, update: function (n) { const r = n.attributes; for (const n in r) t.update(r[n], e.ARRAY_BUFFER); const i = n.morphAttributes; for (const n in i) { const r = i[n]; for (let n = 0, i = r.length; n < i; n++)t.update(r[n], e.ARRAY_BUFFER) } }, getWireframeAttribute: function (e) { const t = a.get(e); if (t) { const n = e.index; null !== n && t.version < n.version && s(e) } else s(e); return a.get(e) } } } function ng(e, t, n) { let r, i, a; function o(t, o, s) { 0 !== s && (e.drawElementsInstanced(r, o, i, t * a, s), n.update(o, r, s)) } this.setMode = function (e) { r = e }, this.setIndex = function (e) { i = e.type, a = e.bytesPerElement }, this.render = function (t, o) { e.drawElements(r, o, i, t * a), n.update(o, r, 1) }, this.renderInstances = o, this.renderMultiDraw = function (e, a, o) { if (0 === o) return; t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, a, 0, i, e, 0, o); let s = 0; for (let e = 0; e < o; e++)s += a[e]; n.update(s, r, 1) }, this.renderMultiDrawInstances = function (e, s, l, c) { if (0 === l) return; const u = t.get("WEBGL_multi_draw"); if (null === u) for (let t = 0; t < e.length; t++)o(e[t] / a, s[t], c[t]); else { u.multiDrawElementsInstancedWEBGL(r, s, 0, i, e, 0, c, 0, l); let t = 0; for (let e = 0; e < l; e++)t += s[e]; for (let e = 0; e < c.length; e++)n.update(t, r, c[e]) } } } function rg(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (n, r, i) { switch (t.calls++, r) { case e.TRIANGLES: t.triangles += i * (n / 3); break; case e.LINES: t.lines += i * (n / 2); break; case e.LINE_STRIP: t.lines += i * (n - 1); break; case e.LINE_LOOP: t.lines += i * n; break; case e.POINTS: t.points += i * n; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", r) } } } } function ig(e, t, n) { const r = new WeakMap, i = new Dh; return { update: function (a, o, s) { const l = a.morphTargetInfluences, c = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, u = void 0 !== c ? c.length : 0; let d = r.get(o); if (void 0 === d || d.count !== u) { void 0 !== d && d.texture.dispose(); const h = void 0 !== o.morphAttributes.position, p = void 0 !== o.morphAttributes.normal, f = void 0 !== o.morphAttributes.color, m = o.morphAttributes.position || [], g = o.morphAttributes.normal || [], v = o.morphAttributes.color || []; let y = 0; !0 === h && (y = 1), !0 === p && (y = 2), !0 === f && (y = 3); let b = o.attributes.position.count * y, x = 1; b > t.maxTextureSize && (x = Math.ceil(b / t.maxTextureSize), b = t.maxTextureSize); const A = new Float32Array(b * x * 4 * u), S = new Fh(A, b, x, u); S.type = jc, S.needsUpdate = !0; const M = 4 * y; for (let _ = 0; _ < u; _++) { const E = m[_], C = g[_], T = v[_], R = b * x * 4 * _; for (let B = 0; B < E.count; B++) { const I = B * M; !0 === h && (i.fromBufferAttribute(E, B), A[R + I + 0] = i.x, A[R + I + 1] = i.y, A[R + I + 2] = i.z, A[R + I + 3] = 0), !0 === p && (i.fromBufferAttribute(C, B), A[R + I + 4] = i.x, A[R + I + 5] = i.y, A[R + I + 6] = i.z, A[R + I + 7] = 0), !0 === f && (i.fromBufferAttribute(T, B), A[R + I + 8] = i.x, A[R + I + 9] = i.y, A[R + I + 10] = i.z, A[R + I + 11] = 4 === T.itemSize ? i.w : 1) } } function w() { S.dispose(), r.delete(o), o.removeEventListener("dispose", w) } d = { count: u, texture: S, size: new uh(b, x) }, r.set(o, d), o.addEventListener("dispose", w) } if (!0 === a.isInstancedMesh && null !== a.morphTexture) s.getUniforms().setValue(e, "morphTexture", a.morphTexture, n); else { let P = 0; for (let D = 0; D < l.length; D++)P += l[D]; const L = o.morphTargetsRelative ? 1 : 1 - P; s.getUniforms().setValue(e, "morphTargetBaseInfluence", L), s.getUniforms().setValue(e, "morphTargetInfluences", l) } s.getUniforms().setValue(e, "morphTargetsTexture", d.texture, n), s.getUniforms().setValue(e, "morphTargetsTextureSize", d.size) } } } function ag(e, t, n, r) { let i = new WeakMap; function a(e) { const t = e.target; t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor) } return { update: function (o) { const s = r.render.frame, l = o.geometry, c = t.get(o, l); if (i.get(c) !== s && (t.update(c), i.set(c, s)), o.isInstancedMesh && (!1 === o.hasEventListener("dispose", a) && o.addEventListener("dispose", a), i.get(o) !== s && (n.update(o.instanceMatrix, e.ARRAY_BUFFER), null !== o.instanceColor && n.update(o.instanceColor, e.ARRAY_BUFFER), i.set(o, s))), o.isSkinnedMesh) { const e = o.skeleton; i.get(e) !== s && (e.update(), i.set(e, s)) } return c }, dispose: function () { i = new WeakMap } } } class og extends Lh { constructor(e, t, n, r, i, a, o, s, l, c = eu) { if (c !== eu && c !== tu) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && c === eu && (n = Gc), void 0 === n && c === tu && (n = Jc), super(null, r, i, a, o, s, c, n, l), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = void 0 !== o ? o : Cc, this.minFilter = void 0 !== s ? s : Cc, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.compareFunction = e.compareFunction, this } toJSON(e) { const t = super.toJSON(e); return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t } } const sg = new Lh, lg = new og(1, 1), cg = new Fh, ug = new Uh, dg = new pm, hg = [], pg = [], fg = new Float32Array(16), mg = new Float32Array(9), gg = new Float32Array(4); function vg(e, t, n) { const r = e[0]; if (r <= 0 || r > 0) return e; const i = t * n; let a = hg[i]; if (void 0 === a && (a = new Float32Array(i), hg[i] = a), 0 !== t) { r.toArray(a, 0); for (let r = 1, i = 0; r !== t; ++r)i += n, e[r].toArray(a, i) } return a } function yg(e, t) { if (e.length !== t.length) return !1; for (let n = 0, r = e.length; n < r; n++)if (e[n] !== t[n]) return !1; return !0 } function bg(e, t) { for (let n = 0, r = t.length; n < r; n++)e[n] = t[n] } function xg(e, t) { let n = pg[t]; void 0 === n && (n = new Int32Array(t), pg[t] = n); for (let r = 0; r !== t; ++r)n[r] = e.allocateTextureUnit(); return n } function Ag(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function Sg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (yg(n, t)) return; e.uniform2fv(this.addr, t), bg(n, t) } } function Mg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (yg(n, t)) return; e.uniform3fv(this.addr, t), bg(n, t) } } function wg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (yg(n, t)) return; e.uniform4fv(this.addr, t), bg(n, t) } } function _g(e, t) { const n = this.cache, r = t.elements; if (void 0 === r) { if (yg(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), bg(n, t) } else { if (yg(n, r)) return; gg.set(r), e.uniformMatrix2fv(this.addr, !1, gg), bg(n, r) } } function Eg(e, t) { const n = this.cache, r = t.elements; if (void 0 === r) { if (yg(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), bg(n, t) } else { if (yg(n, r)) return; mg.set(r), e.uniformMatrix3fv(this.addr, !1, mg), bg(n, r) } } function Cg(e, t) { const n = this.cache, r = t.elements; if (void 0 === r) { if (yg(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), bg(n, t) } else { if (yg(n, r)) return; fg.set(r), e.uniformMatrix4fv(this.addr, !1, fg), bg(n, r) } } function Tg(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function Rg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (yg(n, t)) return; e.uniform2iv(this.addr, t), bg(n, t) } } function Bg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else { if (yg(n, t)) return; e.uniform3iv(this.addr, t), bg(n, t) } } function Ig(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (yg(n, t)) return; e.uniform4iv(this.addr, t), bg(n, t) } } function Pg(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function Lg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (yg(n, t)) return; e.uniform2uiv(this.addr, t), bg(n, t) } } function Dg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else { if (yg(n, t)) return; e.uniform3uiv(this.addr, t), bg(n, t) } } function kg(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (yg(n, t)) return; e.uniform4uiv(this.addr, t), bg(n, t) } } function Ng(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); let a; r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), this.type === e.SAMPLER_2D_SHADOW ? (lg.compareFunction = Dd, a = lg) : a = sg, n.setTexture2D(t || a, i) } function Fg(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ug, i) } function Og(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || dg, i) } function Ug(e, t, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || cg, i) } function zg(e, t) { e.uniform1fv(this.addr, t) } function Hg(e, t) { const n = vg(t, this.size, 2); e.uniform2fv(this.addr, n) } function Gg(e, t) { const n = vg(t, this.size, 3); e.uniform3fv(this.addr, n) } function jg(e, t) { const n = vg(t, this.size, 4); e.uniform4fv(this.addr, n) } function Vg(e, t) { const n = vg(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function Wg(e, t) { const n = vg(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function Xg(e, t) { const n = vg(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function Jg(e, t) { e.uniform1iv(this.addr, t) } function Yg(e, t) { e.uniform2iv(this.addr, t) } function Qg(e, t) { e.uniform3iv(this.addr, t) } function Kg(e, t) { e.uniform4iv(this.addr, t) } function qg(e, t) { e.uniform1uiv(this.addr, t) } function Zg(e, t) { e.uniform2uiv(this.addr, t) } function $g(e, t) { e.uniform3uiv(this.addr, t) } function ev(e, t) { e.uniform4uiv(this.addr, t) } function tv(e, t, n) { const r = this.cache, i = t.length, a = xg(n, i); yg(r, a) || (e.uniform1iv(this.addr, a), bg(r, a)); for (let e = 0; e !== i; ++e)n.setTexture2D(t[e] || sg, a[e]) } function nv(e, t, n) { const r = this.cache, i = t.length, a = xg(n, i); yg(r, a) || (e.uniform1iv(this.addr, a), bg(r, a)); for (let e = 0; e !== i; ++e)n.setTexture3D(t[e] || ug, a[e]) } function rv(e, t, n) { const r = this.cache, i = t.length, a = xg(n, i); yg(r, a) || (e.uniform1iv(this.addr, a), bg(r, a)); for (let e = 0; e !== i; ++e)n.setTextureCube(t[e] || dg, a[e]) } function iv(e, t, n) { const r = this.cache, i = t.length, a = xg(n, i); yg(r, a) || (e.uniform1iv(this.addr, a), bg(r, a)); for (let e = 0; e !== i; ++e)n.setTexture2DArray(t[e] || cg, a[e]) } class av { constructor(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function (e) { switch (e) { case 5126: return Ag; case 35664: return Sg; case 35665: return Mg; case 35666: return wg; case 35674: return _g; case 35675: return Eg; case 35676: return Cg; case 5124: case 35670: return Tg; case 35667: case 35671: return Rg; case 35668: case 35672: return Bg; case 35669: case 35673: return Ig; case 5125: return Pg; case 36294: return Lg; case 36295: return Dg; case 36296: return kg; case 35678: case 36198: case 36298: case 36306: case 35682: return Ng; case 35679: case 36299: case 36307: return Fg; case 35680: case 36300: case 36308: case 36293: return Og; case 36289: case 36303: case 36311: case 36292: return Ug } }(t.type) } } class ov { constructor(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return zg; case 35664: return Hg; case 35665: return Gg; case 35666: return jg; case 35674: return Vg; case 35675: return Wg; case 35676: return Xg; case 5124: case 35670: return Jg; case 35667: case 35671: return Yg; case 35668: case 35672: return Qg; case 35669: case 35673: return Kg; case 5125: return qg; case 36294: return Zg; case 36295: return $g; case 36296: return ev; case 35678: case 36198: case 36298: case 36306: case 35682: return tv; case 35679: case 36299: case 36307: return nv; case 35680: case 36300: case 36308: case 36293: return rv; case 36289: case 36303: case 36311: case 36292: return iv } }(t.type) } } class sv { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, n) { const r = this.seq; for (let i = 0, a = r.length; i !== a; ++i) { const a = r[i]; a.setValue(e, t[a.id], n) } } } const lv = /(\w+)(\])?(\[|\.)?/g; function cv(e, t) { e.seq.push(t), e.map[t.id] = t } function uv(e, t, n) { const r = e.name, i = r.length; for (lv.lastIndex = 0; ;) { const a = lv.exec(r), o = lv.lastIndex; let s = a[1]; const l = "]" === a[2], c = a[3]; if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === i) { cv(n, void 0 === c ? new av(s, e, t) : new ov(s, e, t)); break } { let e = n.map[s]; void 0 === e && (e = new sv(s), cv(n, e)), n = e } } } class dv { constructor(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let r = 0; r < n; ++r) { const n = e.getActiveUniform(t, r); uv(n, e.getUniformLocation(t, n.name), this) } } setValue(e, t, n, r) { const i = this.map[t]; void 0 !== i && i.setValue(e, n, r) } setOptional(e, t, n) { const r = t[n]; void 0 !== r && this.setValue(e, n, r) } static upload(e, t, n, r) { for (let i = 0, a = t.length; i !== a; ++i) { const a = t[i], o = n[a.id]; !1 !== o.needsUpdate && a.setValue(e, o.value, r) } } static seqWithValue(e, t) { const n = []; for (let r = 0, i = e.length; r !== i; ++r) { const i = e[r]; i.id in t && n.push(i) } return n } } function hv(e, t, n) { const r = e.createShader(t); return e.shaderSource(r, n), e.compileShader(r), r } let pv = 0; function fv(e, t, n) { const r = e.getShaderParameter(t, e.COMPILE_STATUS), i = e.getShaderInfoLog(t).trim(); if (r && "" === i) return ""; const a = /ERROR: 0:(\d+)/.exec(i); if (a) { const r = parseInt(a[1]); return n.toUpperCase() + "\n\n" + i + "\n\n" + function (e, t) { const n = e.split("\n"), r = [], i = Math.max(t - 6, 0), a = Math.min(t + 6, n.length); for (let e = i; e < a; e++) { const i = e + 1; r.push(`${i === t ? ">" : " "} ${i}: ${n[e]}`) } return r.join("\n") }(e.getShaderSource(t), r) } return i } function mv(e, t) { const n = function (e) { const t = wh.getPrimaries(wh.workingColorSpace), n = wh.getPrimaries(e); let r; switch (t === n ? r = "" : t === fd && n === pd ? r = "LinearDisplayP3ToLinearSRGB" : t === pd && n === fd && (r = "LinearSRGBToLinearDisplayP3"), e) { case ld: case ud: return [r, "LinearTransferOETF"]; case sd: case cd: return [r, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space:", e), [r, "LinearTransferOETF"] } }(t); return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }` } function gv(e, t) { let n; switch (t) { case cc: n = "Linear"; break; case uc: n = "Reinhard"; break; case dc: n = "Cineon"; break; case hc: n = "ACESFilmic"; break; case fc: n = "AgX"; break; case mc: n = "Neutral"; break; case pc: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } const vv = new Gh; function yv(e) { return "" !== e } function bv(e, t) { const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps; return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function xv(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const Av = /^[ \t]*#include +<([\w\d./]+)>/gm; function Sv(e) { return e.replace(Av, wv) } const Mv = new Map; function wv(e, t) { let n = _m[t]; if (void 0 === n) { const e = Mv.get(t); if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">"); n = _m[e], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e) } return Sv(n) } const _v = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Ev(e) { return e.replace(_v, Cv) } function Cv(e, t, n, r) { let i = ""; for (let e = parseInt(t); e < parseInt(n); e++)i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return i } function Tv(e) { let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Rv(e, t, n, r) { const i = e.getContext(), a = n.defines; let o = n.vertexShader, s = n.fragmentShader; const l = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return e.shadowMapType === bl ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === xl ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === Al && (t = "SHADOWMAP_TYPE_VSM"), t }(n), c = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case bc: case xc: t = "ENVMAP_TYPE_CUBE"; break; case Mc: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), u = function (e) { let t = "ENVMAP_MODE_REFLECTION"; return e.envMap && e.envMapMode === xc && (t = "ENVMAP_MODE_REFRACTION"), t }(n), d = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case ac: t = "ENVMAP_BLENDING_MULTIPLY"; break; case oc: t = "ENVMAP_BLENDING_MIX"; break; case sc: t = "ENVMAP_BLENDING_ADD" }return t }(n), h = function (e) { const t = e.envMapCubeUVHeight; if (null === t) return null; const n = Math.log2(t) - 2, r = 1 / t; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: r, maxMip: n } }(n), p = function (e) { return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(yv).join("\n") }(n), f = function (e) { const t = []; for (const n in e) { const r = e[n]; !1 !== r && t.push("#define " + n + " " + r) } return t.join("\n") }(a), m = i.createProgram(); let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(yv).join("\n"), g.length > 0 && (g += "\n"), v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(yv).join("\n"), v.length > 0 && (v += "\n")) : (g = [Tv(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(yv).join("\n"), v = [Tv(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== lc ? "#define TONE_MAPPING" : "", n.toneMapping !== lc ? _m.tonemapping_pars_fragment : "", n.toneMapping !== lc ? gv("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", _m.colorspace_pars_fragment, mv("linearToOutputTexel", n.outputColorSpace), (wh.getLuminanceCoefficients(vv), ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${vv.x.toFixed(4)}, ${vv.y.toFixed(4)}, ${vv.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(yv).join("\n")), o = Sv(o), o = bv(o, n), o = xv(o, n), s = Sv(s), s = bv(s, n), s = xv(s, n), o = Ev(o), s = Ev(s), !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === Qd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Qd ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); const b = y + g + o, x = y + v + s, A = hv(i, i.VERTEX_SHADER, b), S = hv(i, i.FRAGMENT_SHADER, x); function M(t) { if (e.debug.checkShaderErrors) { const n = i.getProgramInfoLog(m).trim(), r = i.getShaderInfoLog(A).trim(), a = i.getShaderInfoLog(S).trim(); let o = !0, s = !0; if (!1 === i.getProgramParameter(m, i.LINK_STATUS)) if (o = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(i, m, A, S); else { const e = fv(i, A, "vertex"), r = fv(i, S, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, i.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + r) } else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== r && "" !== a || (s = !1); s && (t.diagnostics = { runnable: o, programLog: n, vertexShader: { log: r, prefix: g }, fragmentShader: { log: a, prefix: v } }) } i.deleteShader(A), i.deleteShader(S), w = new dv(i, m), _ = function (e, t) { const n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES); for (let i = 0; i < r; i++) { const r = e.getActiveAttrib(t, i), a = r.name; let o = 1; r.type === e.FLOAT_MAT2 && (o = 2), r.type === e.FLOAT_MAT3 && (o = 3), r.type === e.FLOAT_MAT4 && (o = 4), n[a] = { type: r.type, location: e.getAttribLocation(t, a), locationSize: o } } return n }(i, m) } let w, _; i.attachShader(m, A), i.attachShader(m, S), void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), this.getUniforms = function () { return void 0 === w && M(this), w }, this.getAttributes = function () { return void 0 === _ && M(this), _ }; let E = !1 === n.rendererExtensionParallelShaderCompile; return this.isReady = function () { return !1 === E && (E = i.getProgramParameter(m, 37297)), E }, this.destroy = function () { r.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0 }, this.type = n.shaderType, this.name = n.shaderName, this.id = pv++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = A, this.fragmentShader = S, this } let Bv = 0; class Iv { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, n = e.fragmentShader, r = this._getShaderStage(t), i = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e); return !1 === a.has(r) && (a.add(r), r.usedTimes++), !1 === a.has(i) && (a.add(i), i.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let n = t.get(e); return void 0 === n && (n = new Set, t.set(e, n)), n } _getShaderStage(e) { const t = this.shaderCache; let n = t.get(e); return void 0 === n && (n = new Pv(e), t.set(e, n)), n } } class Pv { constructor(e) { this.id = Bv++, this.code = e, this.usedTimes = 0 } } function Lv(e, t, n, r, i, a, o) { const s = new Rp, l = new Iv, c = new Set, u = [], d = i.logarithmicDepthBuffer, h = i.reverseDepthBuffer, p = i.vertexTextures; let f = i.precision; const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function g(e) { return c.add(e), 0 === e ? "uv" : `uv${e}` } return { getParameters: function (a, s, u, v, y) { const b = v.fog, x = y.geometry, A = a.isMeshStandardMaterial ? v.environment : null, S = (a.isMeshStandardMaterial ? n : t).get(a.envMap || A), M = S && S.mapping === Mc ? S.image.height : null, w = m[a.type]; null !== a.precision && (f = i.getMaxPrecision(a.precision), f !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", f, "instead.")); const _ = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color, E = void 0 !== _ ? _.length : 0; let C, T, R, B, I = 0; if (void 0 !== x.morphAttributes.position && (I = 1), void 0 !== x.morphAttributes.normal && (I = 2), void 0 !== x.morphAttributes.color && (I = 3), w) { const e = Cm[w]; C = e.vertexShader, T = e.fragmentShader } else C = a.vertexShader, T = a.fragmentShader, l.update(a), R = l.getVertexShaderID(a), B = l.getFragmentShaderID(a); const P = e.getRenderTarget(), L = !0 === y.isInstancedMesh, D = !0 === y.isBatchedMesh, k = !!a.map, N = !!a.matcap, F = !!S, O = !!a.aoMap, U = !!a.lightMap, z = !!a.bumpMap, H = !!a.normalMap, G = !!a.displacementMap, j = !!a.emissiveMap, V = !!a.metalnessMap, W = !!a.roughnessMap, X = a.anisotropy > 0, J = a.clearcoat > 0, Y = a.dispersion > 0, Q = a.iridescence > 0, K = a.sheen > 0, q = a.transmission > 0, Z = X && !!a.anisotropyMap, $ = J && !!a.clearcoatMap, ee = J && !!a.clearcoatNormalMap, te = J && !!a.clearcoatRoughnessMap, ne = Q && !!a.iridescenceMap, re = Q && !!a.iridescenceThicknessMap, ie = K && !!a.sheenColorMap, ae = K && !!a.sheenRoughnessMap, oe = !!a.specularMap, se = !!a.specularColorMap, le = !!a.specularIntensityMap, ce = q && !!a.transmissionMap, ue = q && !!a.thicknessMap, de = !!a.gradientMap, he = !!a.alphaMap, pe = a.alphaTest > 0, fe = !!a.alphaHash, me = !!a.extensions; let ge = lc; a.toneMapped && (null !== P && !0 !== P.isXRRenderTarget || (ge = e.toneMapping)); const ve = { shaderID: w, shaderType: a.type, shaderName: a.name, vertexShader: C, fragmentShader: T, defines: a.defines, customVertexShaderID: R, customFragmentShaderID: B, isRawShaderMaterial: !0 === a.isRawShaderMaterial, glslVersion: a.glslVersion, precision: f, batching: D, batchingColor: D && null !== y._colorsTexture, instancing: L, instancingColor: L && null !== y.instanceColor, instancingMorph: L && null !== y.morphTexture, supportsVertexTextures: p, outputColorSpace: null === P ? e.outputColorSpace : !0 === P.isXRRenderTarget ? P.texture.colorSpace : ld, alphaToCoverage: !!a.alphaToCoverage, map: k, matcap: N, envMap: F, envMapMode: F && S.mapping, envMapCubeUVHeight: M, aoMap: O, lightMap: U, bumpMap: z, normalMap: H, displacementMap: p && G, emissiveMap: j, normalMapObjectSpace: H && a.normalMapType === ad, normalMapTangentSpace: H && a.normalMapType === id, metalnessMap: V, roughnessMap: W, anisotropy: X, anisotropyMap: Z, clearcoat: J, clearcoatMap: $, clearcoatNormalMap: ee, clearcoatRoughnessMap: te, dispersion: Y, iridescence: Q, iridescenceMap: ne, iridescenceThicknessMap: re, sheen: K, sheenColorMap: ie, sheenRoughnessMap: ae, specularMap: oe, specularColorMap: se, specularIntensityMap: le, transmission: q, transmissionMap: ce, thicknessMap: ue, gradientMap: de, opaque: !1 === a.transparent && a.blending === El && !1 === a.alphaToCoverage, alphaMap: he, alphaTest: pe, alphaHash: fe, combine: a.combine, mapUv: k && g(a.map.channel), aoMapUv: O && g(a.aoMap.channel), lightMapUv: U && g(a.lightMap.channel), bumpMapUv: z && g(a.bumpMap.channel), normalMapUv: H && g(a.normalMap.channel), displacementMapUv: G && g(a.displacementMap.channel), emissiveMapUv: j && g(a.emissiveMap.channel), metalnessMapUv: V && g(a.metalnessMap.channel), roughnessMapUv: W && g(a.roughnessMap.channel), anisotropyMapUv: Z && g(a.anisotropyMap.channel), clearcoatMapUv: $ && g(a.clearcoatMap.channel), clearcoatNormalMapUv: ee && g(a.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: te && g(a.clearcoatRoughnessMap.channel), iridescenceMapUv: ne && g(a.iridescenceMap.channel), iridescenceThicknessMapUv: re && g(a.iridescenceThicknessMap.channel), sheenColorMapUv: ie && g(a.sheenColorMap.channel), sheenRoughnessMapUv: ae && g(a.sheenRoughnessMap.channel), specularMapUv: oe && g(a.specularMap.channel), specularColorMapUv: se && g(a.specularColorMap.channel), specularIntensityMapUv: le && g(a.specularIntensityMap.channel), transmissionMapUv: ce && g(a.transmissionMap.channel), thicknessMapUv: ue && g(a.thicknessMap.channel), alphaMapUv: he && g(a.alphaMap.channel), vertexTangents: !!x.attributes.tangent && (H || X), vertexColors: a.vertexColors, vertexAlphas: !0 === a.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize, pointsUvs: !0 === y.isPoints && !!x.attributes.uv && (k || he), fog: !!b, useFog: !0 === a.fog, fogExp2: !!b && b.isFogExp2, flatShading: !0 === a.flatShading, sizeAttenuation: !0 === a.sizeAttenuation, logarithmicDepthBuffer: d, reverseDepthBuffer: h, skinning: !0 === y.isSkinnedMesh, morphTargets: void 0 !== x.morphAttributes.position, morphNormals: void 0 !== x.morphAttributes.normal, morphColors: void 0 !== x.morphAttributes.color, morphTargetsCount: E, morphTextureStride: I, numDirLights: s.directional.length, numPointLights: s.point.length, numSpotLights: s.spot.length, numSpotLightMaps: s.spotLightMap.length, numRectAreaLights: s.rectArea.length, numHemiLights: s.hemi.length, numDirLightShadows: s.directionalShadowMap.length, numPointLightShadows: s.pointShadowMap.length, numSpotLightShadows: s.spotShadowMap.length, numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps, numLightProbes: s.numLightProbes, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: a.dithering, shadowMapEnabled: e.shadowMap.enabled && u.length > 0, shadowMapType: e.shadowMap.type, toneMapping: ge, decodeVideoTexture: k && !0 === a.map.isVideoTexture && wh.getTransfer(a.map.colorSpace) === hd, premultipliedAlpha: a.premultipliedAlpha, doubleSided: a.side === wl, flipSided: a.side === Ml, useDepthPacking: a.depthPacking >= 0, depthPacking: a.depthPacking || 0, index0AttributeName: a.index0AttributeName, extensionClipCullDistance: me && !0 === a.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (me && !0 === a.extensions.multiDraw || D) && r.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"), customProgramCacheKey: a.customProgramCacheKey() }; return ve.vertexUv1s = c.has(1), ve.vertexUv2s = c.has(2), ve.vertexUv3s = c.has(3), c.clear(), ve }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]); return !1 === t.isRawShaderMaterial && (function (e, t) { e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking) }(n, t), function (e, t) { s.disableAll(), t.supportsVertexTextures && s.enable(0), t.instancing && s.enable(1), t.instancingColor && s.enable(2), t.instancingMorph && s.enable(3), t.matcap && s.enable(4), t.envMap && s.enable(5), t.normalMapObjectSpace && s.enable(6), t.normalMapTangentSpace && s.enable(7), t.clearcoat && s.enable(8), t.iridescence && s.enable(9), t.alphaTest && s.enable(10), t.vertexColors && s.enable(11), t.vertexAlphas && s.enable(12), t.vertexUv1s && s.enable(13), t.vertexUv2s && s.enable(14), t.vertexUv3s && s.enable(15), t.vertexTangents && s.enable(16), t.anisotropy && s.enable(17), t.alphaHash && s.enable(18), t.batching && s.enable(19), t.dispersion && s.enable(20), t.batchingColor && s.enable(21), e.push(s.mask), s.disableAll(), t.fog && s.enable(0), t.useFog && s.enable(1), t.flatShading && s.enable(2), t.logarithmicDepthBuffer && s.enable(3), t.reverseDepthBuffer && s.enable(4), t.skinning && s.enable(5), t.morphTargets && s.enable(6), t.morphNormals && s.enable(7), t.morphColors && s.enable(8), t.premultipliedAlpha && s.enable(9), t.shadowMapEnabled && s.enable(10), t.doubleSided && s.enable(11), t.flipSided && s.enable(12), t.useDepthPacking && s.enable(13), t.dithering && s.enable(14), t.transmission && s.enable(15), t.sheen && s.enable(16), t.opaque && s.enable(17), t.pointsUvs && s.enable(18), t.decodeVideoTexture && s.enable(19), t.alphaToCoverage && s.enable(20), e.push(s.mask) }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { const t = m[e.type]; let n; if (t) { const e = Cm[t]; n = im.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (t, n) { let r; for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; if (t.cacheKey === n) { r = t, ++r.usedTimes; break } } return void 0 === r && (r = new Rv(e, n, t, a), u.push(r)), r }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = u.indexOf(e); u[t] = u[u.length - 1], u.pop(), e.destroy() } }, releaseShaderCache: function (e) { l.remove(e) }, programs: u, dispose: function () { l.dispose() } } } function Dv() { let e = new WeakMap; return { has: function (t) { return e.has(t) }, get: function (t) { let n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function (t) { e.delete(t) }, update: function (t, n, r) { e.get(t)[n] = r }, dispose: function () { e = new WeakMap } } } function kv(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function Nv(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function Fv() { const e = []; let t = 0; const n = [], r = [], i = []; function a(n, r, i, a, o, s) { let l = e[t]; return void 0 === l ? (l = { id: n.id, object: n, geometry: r, material: i, groupOrder: a, renderOrder: n.renderOrder, z: o, group: s }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = o, l.group = s), t++, l } return { opaque: n, transmissive: r, transparent: i, init: function () { t = 0, n.length = 0, r.length = 0, i.length = 0 }, push: function (e, t, o, s, l, c) { const u = a(e, t, o, s, l, c); o.transmission > 0 ? r.push(u) : !0 === o.transparent ? i.push(u) : n.push(u) }, unshift: function (e, t, o, s, l, c) { const u = a(e, t, o, s, l, c); o.transmission > 0 ? r.unshift(u) : !0 === o.transparent ? i.unshift(u) : n.unshift(u) }, finish: function () { for (let n = t, r = e.length; n < r; n++) { const t = e[n]; if (null === t.id) break; t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null } }, sort: function (e, t) { n.length > 1 && n.sort(e || kv), r.length > 1 && r.sort(t || Nv), i.length > 1 && i.sort(t || Nv) } } } function Ov() { let e = new WeakMap; return { get: function (t, n) { const r = e.get(t); let i; return void 0 === r ? (i = new Fv, e.set(t, [i])) : n >= r.length ? (i = new Fv, r.push(i)) : i = r[n], i }, dispose: function () { e = new WeakMap } } } function Uv() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": n = { direction: new Gh, color: new df }; break; case "SpotLight": n = { position: new Gh, direction: new Gh, color: new df, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new Gh, color: new df, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new Gh, skyColor: new df, groundColor: new df }; break; case "RectAreaLight": n = { color: new df, position: new Gh, halfWidth: new Gh, halfHeight: new Gh } }return e[t.id] = n, n } } } let zv = 0; function Hv(e, t) { return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0) } function Gv(e) { const t = new Uv, n = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new uh }; break; case "PointLight": n = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new uh, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let e = 0; e < 9; e++)r.probe.push(new Gh); const i = new Gh, a = new yp, o = new yp; return { setup: function (i) { let a = 0, o = 0, s = 0; for (let e = 0; e < 9; e++)r.probe[e].set(0, 0, 0); let l = 0, c = 0, u = 0, d = 0, h = 0, p = 0, f = 0, m = 0, g = 0, v = 0, y = 0; i.sort(Hv); for (let e = 0, b = i.length; e < b; e++) { const b = i[e], x = b.color, A = b.intensity, S = b.distance, M = b.shadow && b.shadow.map ? b.shadow.map.texture : null; if (b.isAmbientLight) a += x.r * A, o += x.g * A, s += x.b * A; else if (b.isLightProbe) { for (let e = 0; e < 9; e++)r.probe[e].addScaledVector(b.sh.coefficients[e], A); y++ } else if (b.isDirectionalLight) { const e = t.get(b); if (e.color.copy(b.color).multiplyScalar(b.intensity), b.castShadow) { const e = b.shadow, t = n.get(b); t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, r.directionalShadow[l] = t, r.directionalShadowMap[l] = M, r.directionalShadowMatrix[l] = b.shadow.matrix, p++ } r.directional[l] = e, l++ } else if (b.isSpotLight) { const e = t.get(b); e.position.setFromMatrixPosition(b.matrixWorld), e.color.copy(x).multiplyScalar(A), e.distance = S, e.coneCos = Math.cos(b.angle), e.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)), e.decay = b.decay, r.spot[u] = e; const i = b.shadow; if (b.map && (r.spotLightMap[g] = b.map, g++, i.updateMatrices(b), b.castShadow && v++), r.spotLightMatrix[u] = i.matrix, b.castShadow) { const e = n.get(b); e.shadowIntensity = i.intensity, e.shadowBias = i.bias, e.shadowNormalBias = i.normalBias, e.shadowRadius = i.radius, e.shadowMapSize = i.mapSize, r.spotShadow[u] = e, r.spotShadowMap[u] = M, m++ } u++ } else if (b.isRectAreaLight) { const e = t.get(b); e.color.copy(x).multiplyScalar(A), e.halfWidth.set(.5 * b.width, 0, 0), e.halfHeight.set(0, .5 * b.height, 0), r.rectArea[d] = e, d++ } else if (b.isPointLight) { const e = t.get(b); if (e.color.copy(b.color).multiplyScalar(b.intensity), e.distance = b.distance, e.decay = b.decay, b.castShadow) { const e = b.shadow, t = n.get(b); t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, r.pointShadow[c] = t, r.pointShadowMap[c] = M, r.pointShadowMatrix[c] = b.shadow.matrix, f++ } r.point[c] = e, c++ } else if (b.isHemisphereLight) { const e = t.get(b); e.skyColor.copy(b.color).multiplyScalar(A), e.groundColor.copy(b.groundColor).multiplyScalar(A), r.hemi[h] = e, h++ } } d > 0 && (!0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Em.LTC_FLOAT_1, r.rectAreaLTC2 = Em.LTC_FLOAT_2) : (r.rectAreaLTC1 = Em.LTC_HALF_1, r.rectAreaLTC2 = Em.LTC_HALF_2)), r.ambient[0] = a, r.ambient[1] = o, r.ambient[2] = s; const b = r.hash; b.directionalLength === l && b.pointLength === c && b.spotLength === u && b.rectAreaLength === d && b.hemiLength === h && b.numDirectionalShadows === p && b.numPointShadows === f && b.numSpotShadows === m && b.numSpotMaps === g && b.numLightProbes === y || (r.directional.length = l, r.spot.length = u, r.rectArea.length = d, r.point.length = c, r.hemi.length = h, r.directionalShadow.length = p, r.directionalShadowMap.length = p, r.pointShadow.length = f, r.pointShadowMap.length = f, r.spotShadow.length = m, r.spotShadowMap.length = m, r.directionalShadowMatrix.length = p, r.pointShadowMatrix.length = f, r.spotLightMatrix.length = m + g - v, r.spotLightMap.length = g, r.numSpotLightShadowsWithMaps = v, r.numLightProbes = y, b.directionalLength = l, b.pointLength = c, b.spotLength = u, b.rectAreaLength = d, b.hemiLength = h, b.numDirectionalShadows = p, b.numPointShadows = f, b.numSpotShadows = m, b.numSpotMaps = g, b.numLightProbes = y, r.version = zv++) }, setupView: function (e, t) { let n = 0, s = 0, l = 0, c = 0, u = 0; const d = t.matrixWorldInverse; for (let t = 0, h = e.length; t < h; t++) { const h = e[t]; if (h.isDirectionalLight) { const e = r.directional[n]; e.direction.setFromMatrixPosition(h.matrixWorld), i.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(i), e.direction.transformDirection(d), n++ } else if (h.isSpotLight) { const e = r.spot[l]; e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(d), e.direction.setFromMatrixPosition(h.matrixWorld), i.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(i), e.direction.transformDirection(d), l++ } else if (h.isRectAreaLight) { const e = r.rectArea[c]; e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(d), o.identity(), a.copy(h.matrixWorld), a.premultiply(d), o.extractRotation(a), e.halfWidth.set(.5 * h.width, 0, 0), e.halfHeight.set(0, .5 * h.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++ } else if (h.isPointLight) { const e = r.point[s]; e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(d), s++ } else if (h.isHemisphereLight) { const e = r.hemi[u]; e.direction.setFromMatrixPosition(h.matrixWorld), e.direction.transformDirection(d), u++ } } }, state: r } } function jv(e) { const t = new Gv(e), n = [], r = [], i = { lightsArray: n, shadowsArray: r, camera: null, lights: t, transmissionRenderTarget: {} }; return { init: function (e) { i.camera = e, n.length = 0, r.length = 0 }, state: i, setupLights: function () { t.setup(n) }, setupLightsView: function (e) { t.setupView(n, e) }, pushLight: function (e) { n.push(e) }, pushShadow: function (e) { r.push(e) } } } function Vv(e) { let t = new WeakMap; return { get: function (n, r = 0) { const i = t.get(n); let a; return void 0 === i ? (a = new jv(e), t.set(n, [a])) : r >= i.length ? (a = new jv(e), i.push(a)) : a = i[r], a }, dispose: function () { t = new WeakMap } } } class Wv extends ff { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = ed, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class Xv extends ff { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function Jv(e, t, n) { let r = new Am; const i = new uh, a = new uh, o = new Dh, s = new Wv({ depthPacking: td }), l = new Xv, c = {}, u = n.maxTextureSize, d = { [Sl]: Ml, [Ml]: Sl, [wl]: wl }, h = new am({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new uh }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p = h.clone(); p.defines.HORIZONTAL_PASS = 1; const f = new zf; f.setAttribute("position", new Mf(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const m = new Zf(f, h), g = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = bl; let v = this.type; function y(n, r) { const a = t.update(m); h.defines.VSM_SAMPLES !== n.blurSamples && (h.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, h.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Nh(i.x, i.y)), h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, a, h, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, a, p, m, null) } function b(t, n, r, i) { let a = null; const o = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial; if (void 0 !== o) a = o; else if (a = !0 === r.isPointLight ? l : s, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) { const e = a.uuid, t = n.uuid; let r = c[e]; void 0 === r && (r = {}, c[e] = r); let i = r[t]; void 0 === i && (i = a.clone(), r[t] = i, n.addEventListener("dispose", A)), a = i } return a.visible = n.visible, a.wireframe = n.wireframe, a.side = i === Al ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], a.alphaMap = n.alphaMap, a.alphaTest = n.alphaTest, a.map = n.map, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.clipIntersection = n.clipIntersection, a.displacementMap = n.displacementMap, a.displacementScale = n.displacementScale, a.displacementBias = n.displacementBias, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, !0 === r.isPointLight && !0 === a.isMeshDistanceMaterial && (e.properties.get(a).light = r), a } function x(n, i, a, o, s) { if (!1 === n.visible) return; if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === Al) && (!n.frustumCulled || r.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld); const r = t.update(n), l = n.material; if (Array.isArray(l)) { const t = r.groups; for (let c = 0, u = t.length; c < u; c++) { const u = t[c], d = l[u.materialIndex]; if (d && d.visible) { const t = b(n, d, o, s); n.onBeforeShadow(e, n, i, a, r, t, u), e.renderBufferDirect(a, null, r, t, n, u), n.onAfterShadow(e, n, i, a, r, t, u) } } } else if (l.visible) { const t = b(n, l, o, s); n.onBeforeShadow(e, n, i, a, r, t, null), e.renderBufferDirect(a, null, r, t, n, null), n.onAfterShadow(e, n, i, a, r, t, null) } } const l = n.children; for (let e = 0, t = l.length; e < t; e++)x(l[e], i, a, o, s) } function A(e) { e.target.removeEventListener("dispose", A); for (const t in c) { const n = c[t], r = e.target.uuid; r in n && (n[r].dispose(), delete n[r]) } } this.render = function (t, n, s) { if (!1 === g.enabled) return; if (!1 === g.autoUpdate && !1 === g.needsUpdate) return; if (0 === t.length) return; const l = e.getRenderTarget(), c = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), h = e.state; h.setBlending(_l), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1); const p = v !== Al && this.type === Al, f = v === Al && this.type !== Al; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], d = c.shadow; if (void 0 === d) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue } if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue; i.copy(d.mapSize); const m = d.getFrameExtents(); if (i.multiply(m), a.copy(d.mapSize), (i.x > u || i.y > u) && (i.x > u && (a.x = Math.floor(u / m.x), i.x = a.x * m.x, d.mapSize.x = a.x), i.y > u && (a.y = Math.floor(u / m.y), i.y = a.y * m.y, d.mapSize.y = a.y)), null === d.map || !0 === p || !0 === f) { const e = this.type !== Al ? { minFilter: Cc, magFilter: Cc } : {}; null !== d.map && d.map.dispose(), d.map = new Nh(i.x, i.y, e), d.map.texture.name = c.name + ".shadowMap", d.camera.updateProjectionMatrix() } e.setRenderTarget(d.map), e.clear(); const g = d.getViewportCount(); for (let e = 0; e < g; e++) { const t = d.getViewport(e); o.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w), h.viewport(o), d.updateMatrices(c, e), r = d.getFrustum(), x(n, s, d.camera, c, this.type) } !0 !== d.isPointLightShadow && this.type === Al && y(d, s), d.needsUpdate = !1 } v = this.type, g.needsUpdate = !1, e.setRenderTarget(l, c, d) } } const Yv = { [ql]: Zl, [$l]: rc, [tc]: ic, [ec]: nc, [Zl]: ql, [rc]: $l, [ic]: tc, [nc]: ec }; function Qv(e) { const t = new function () { let t = !1; const n = new Dh; let r = null; const i = new Dh(0, 0, 0, 0); return { setMask: function (n) { r === n || t || (e.colorMask(n, n, n, n), r = n) }, setLocked: function (e) { t = e }, setClear: function (t, r, a, o, s) { !0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o), !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n)) }, reset: function () { t = !1, r = null, i.set(-1, 0, 0, 0) } } }, n = new function () { let t = !1, n = !1, r = null, i = null, a = null; return { setReversed: function (e) { n = e }, setTest: function (t) { t ? U(e.DEPTH_TEST) : z(e.DEPTH_TEST) }, setMask: function (n) { r === n || t || (e.depthMask(n), r = n) }, setFunc: function (t) { if (n && (t = Yv[t]), i !== t) { switch (t) { case ql: e.depthFunc(e.NEVER); break; case Zl: e.depthFunc(e.ALWAYS); break; case $l: e.depthFunc(e.LESS); break; case ec: e.depthFunc(e.LEQUAL); break; case tc: e.depthFunc(e.EQUAL); break; case nc: e.depthFunc(e.GEQUAL); break; case rc: e.depthFunc(e.GREATER); break; case ic: e.depthFunc(e.NOTEQUAL); break; default: e.depthFunc(e.LEQUAL) }i = t } }, setLocked: function (e) { t = e }, setClear: function (t) { a !== t && (e.clearDepth(t), a = t) }, reset: function () { t = !1, r = null, i = null, a = null } } }, r = new function () { let t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, c = null; return { setTest: function (n) { t || (n ? U(e.STENCIL_TEST) : z(e.STENCIL_TEST)) }, setMask: function (r) { n === r || t || (e.stencilMask(r), n = r) }, setFunc: function (t, n, o) { r === t && i === n && a === o || (e.stencilFunc(t, n, o), r = t, i = n, a = o) }, setOp: function (t, n, r) { o === t && s === n && l === r || (e.stencilOp(t, n, r), o = t, s = n, l = r) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, c = null } } }, i = new WeakMap, a = new WeakMap; let o = {}, s = {}, l = new WeakMap, c = [], u = null, d = !1, h = null, p = null, f = null, m = null, g = null, v = null, y = null, b = new df(0, 0, 0), x = 0, A = !1, S = null, M = null, w = null, _ = null, E = null; const C = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let T = !1, R = 0; const B = e.getParameter(e.VERSION); -1 !== B.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(B)[1]), T = R >= 1) : -1 !== B.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), T = R >= 2); let I = null, P = {}; const L = e.getParameter(e.SCISSOR_BOX), D = e.getParameter(e.VIEWPORT), k = (new Dh).fromArray(L), N = (new Dh).fromArray(D); function F(t, n, r, i) { const a = new Uint8Array(4), o = e.createTexture(); e.bindTexture(t, o), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST); for (let o = 0; o < r; o++)t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, i, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage2D(n + o, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a); return o } const O = {}; function U(t) { !0 !== o[t] && (e.enable(t), o[t] = !0) } function z(t) { !1 !== o[t] && (e.disable(t), o[t] = !1) } O[e.TEXTURE_2D] = F(e.TEXTURE_2D, e.TEXTURE_2D, 1), O[e.TEXTURE_CUBE_MAP] = F(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), O[e.TEXTURE_2D_ARRAY] = F(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), O[e.TEXTURE_3D] = F(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), t.setClear(0, 0, 0, 1), n.setClear(1), r.setClear(0), U(e.DEPTH_TEST), n.setFunc(ec), V(!1), W(ml), U(e.CULL_FACE), j(_l); const H = { [Il]: e.FUNC_ADD, [Pl]: e.FUNC_SUBTRACT, [Ll]: e.FUNC_REVERSE_SUBTRACT }; H[Dl] = e.MIN, H[kl] = e.MAX; const G = { [Nl]: e.ZERO, [Fl]: e.ONE, [Ol]: e.SRC_COLOR, [zl]: e.SRC_ALPHA, [Xl]: e.SRC_ALPHA_SATURATE, [Vl]: e.DST_COLOR, [Gl]: e.DST_ALPHA, [Ul]: e.ONE_MINUS_SRC_COLOR, [Hl]: e.ONE_MINUS_SRC_ALPHA, [Wl]: e.ONE_MINUS_DST_COLOR, [jl]: e.ONE_MINUS_DST_ALPHA, [Jl]: e.CONSTANT_COLOR, [Yl]: e.ONE_MINUS_CONSTANT_COLOR, [Ql]: e.CONSTANT_ALPHA, [Kl]: e.ONE_MINUS_CONSTANT_ALPHA }; function j(t, n, r, i, a, o, s, l, c, u) { if (t !== _l) { if (!1 === d && (U(e.BLEND), d = !0), t === Bl) a = a || n, o = o || r, s = s || i, n === p && a === g || (e.blendEquationSeparate(H[n], H[a]), p = n, g = a), r === f && i === m && o === v && s === y || (e.blendFuncSeparate(G[r], G[i], G[o], G[s]), f = r, m = i, v = o, y = s), !1 !== l.equals(b) && c === x || (e.blendColor(l.r, l.g, l.b, c), b.copy(l), x = c), h = t, A = !1; else if (t !== h || u !== A) { if (p === Il && g === Il || (e.blendEquation(e.FUNC_ADD), p = Il, g = Il), u) switch (t) { case El: e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case Cl: e.blendFunc(e.ONE, e.ONE); break; case Tl: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case Rl: e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case El: e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case Cl: e.blendFunc(e.SRC_ALPHA, e.ONE); break; case Tl: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case Rl: e.blendFunc(e.ZERO, e.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }f = null, m = null, v = null, y = null, b.set(0, 0, 0), x = 0, h = t, A = u } } else !0 === d && (z(e.BLEND), d = !1) } function V(t) { S !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), S = t) } function W(t) { t !== fl ? (U(e.CULL_FACE), t !== M && (t === ml ? e.cullFace(e.BACK) : t === gl ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : z(e.CULL_FACE), M = t } function X(t, n, r) { t ? (U(e.POLYGON_OFFSET_FILL), _ === n && E === r || (e.polygonOffset(n, r), _ = n, E = r)) : z(e.POLYGON_OFFSET_FILL) } return { buffers: { color: t, depth: n, stencil: r }, enable: U, disable: z, bindFramebuffer: function (t, n) { return s[t] !== n && (e.bindFramebuffer(t, n), s[t] = n, t === e.DRAW_FRAMEBUFFER && (s[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (s[e.DRAW_FRAMEBUFFER] = n), !0) }, drawBuffers: function (t, n) { let r = c, i = !1; if (t) { r = l.get(n), void 0 === r && (r = [], l.set(n, r)); const a = t.textures; if (r.length !== a.length || r[0] !== e.COLOR_ATTACHMENT0) { for (let t = 0, n = a.length; t < n; t++)r[t] = e.COLOR_ATTACHMENT0 + t; r.length = a.length, i = !0 } } else r[0] !== e.BACK && (r[0] = e.BACK, i = !0); i && e.drawBuffers(r) }, useProgram: function (t) { return u !== t && (e.useProgram(t), u = t, !0) }, setBlending: j, setMaterial: function (i, a) { i.side === wl ? z(e.CULL_FACE) : U(e.CULL_FACE); let o = i.side === Ml; a && (o = !o), V(o), i.blending === El && !1 === i.transparent ? j(_l) : j(i.blending, i.blendEquation, i.blendSrc, i.blendDst, i.blendEquationAlpha, i.blendSrcAlpha, i.blendDstAlpha, i.blendColor, i.blendAlpha, i.premultipliedAlpha), n.setFunc(i.depthFunc), n.setTest(i.depthTest), n.setMask(i.depthWrite), t.setMask(i.colorWrite); const s = i.stencilWrite; r.setTest(s), s && (r.setMask(i.stencilWriteMask), r.setFunc(i.stencilFunc, i.stencilRef, i.stencilFuncMask), r.setOp(i.stencilFail, i.stencilZFail, i.stencilZPass)), X(i.polygonOffset, i.polygonOffsetFactor, i.polygonOffsetUnits), !0 === i.alphaToCoverage ? U(e.SAMPLE_ALPHA_TO_COVERAGE) : z(e.SAMPLE_ALPHA_TO_COVERAGE) }, setFlipSided: V, setCullFace: W, setLineWidth: function (t) { t !== w && (T && e.lineWidth(t), w = t) }, setPolygonOffset: X, setScissorTest: function (t) { t ? U(e.SCISSOR_TEST) : z(e.SCISSOR_TEST) }, activeTexture: function (t) { void 0 === t && (t = e.TEXTURE0 + C - 1), I !== t && (e.activeTexture(t), I = t) }, bindTexture: function (t, n, r) { void 0 === r && (r = null === I ? e.TEXTURE0 + C - 1 : I); let i = P[r]; void 0 === i && (i = { type: void 0, texture: void 0 }, P[r] = i), i.type === t && i.texture === n || (I !== r && (e.activeTexture(r), I = r), e.bindTexture(t, n || O[t]), i.type = t, i.texture = n) }, unbindTexture: function () { const t = P[I]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexImage3D: function () { try { e.compressedTexImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, updateUBOMapping: function (t, n) { let r = a.get(n); void 0 === r && (r = new WeakMap, a.set(n, r)); let i = r.get(t); void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i)) }, uniformBlockBinding: function (t, n) { const r = a.get(n).get(t); i.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), i.set(n, r)) }, texStorage2D: function () { try { e.texStorage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texStorage3D: function () { try { e.texStorage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage2D: function () { try { e.texSubImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage3D: function () { try { e.texSubImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage2D: function () { try { e.compressedTexSubImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage3D: function () { try { e.compressedTexSubImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === k.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), k.copy(t)) }, viewport: function (t) { !1 === N.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), N.copy(t)) }, reset: function () { e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), o = {}, I = null, P = {}, s = {}, l = new WeakMap, c = [], u = null, d = !1, h = null, p = null, f = null, m = null, g = null, v = null, y = null, b = new df(0, 0, 0), x = 0, A = !1, S = null, M = null, w = null, _ = null, E = null, k.set(0, 0, e.canvas.width, e.canvas.height), N.set(0, 0, e.canvas.width, e.canvas.height), t.reset(), n.reset(), r.reset() } } } function Kv(e, t, n, r) { const i = function (e) { switch (e) { case Fc: case Oc: return { byteLength: 1, components: 1 }; case zc: case Uc: case Vc: return { byteLength: 2, components: 1 }; case Wc: case Xc: return { byteLength: 2, components: 4 }; case Gc: case Hc: case jc: return { byteLength: 4, components: 1 }; case Yc: return { byteLength: 4, components: 3 } }throw new Error(`Unknown texture type ${e}.`) }(r); switch (n) { case Qc: case Zc: return e * t; case $c: return e * t * 2; case nu: case ru: return e * t / i.components * i.byteLength; case iu: case au: return e * t * 2 / i.components * i.byteLength; case Kc: return e * t * 3 / i.components * i.byteLength; case qc: case su: return e * t * 4 / i.components * i.byteLength; case lu: case cu: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8; case uu: case du: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16; case pu: case mu: return Math.max(e, 16) * Math.max(t, 8) / 4; case hu: case fu: return Math.max(e, 8) * Math.max(t, 8) / 2; case gu: case vu: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8; case yu: case bu: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16; case xu: return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16; case Au: return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16; case Su: return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16; case Mu: return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16; case wu: return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16; case _u: return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16; case Eu: return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16; case Cu: return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16; case Tu: return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16; case Ru: return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16; case Bu: return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16; case Iu: return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16; case Pu: return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16; case Lu: case Du: case ku: return Math.ceil(e / 4) * Math.ceil(t / 4) * 16; case Nu: case Fu: return Math.ceil(e / 4) * Math.ceil(t / 4) * 8; case Ou: case Uu: return Math.ceil(e / 4) * Math.ceil(t / 4) * 16 }throw new Error(`Unable to determine texture byte length for ${n} format.`) } const qv = { contain: function (e, t) { const n = e.image && e.image.width ? e.image.width / e.image.height : 1; return n > t ? (e.repeat.x = 1, e.repeat.y = n / t, e.offset.x = 0, e.offset.y = (1 - e.repeat.y) / 2) : (e.repeat.x = t / n, e.repeat.y = 1, e.offset.x = (1 - e.repeat.x) / 2, e.offset.y = 0), e }, cover: function (e, t) { const n = e.image && e.image.width ? e.image.width / e.image.height : 1; return n > t ? (e.repeat.x = t / n, e.repeat.y = 1, e.offset.x = (1 - e.repeat.x) / 2, e.offset.y = 0) : (e.repeat.x = 1, e.repeat.y = n / t, e.offset.x = 0, e.offset.y = (1 - e.repeat.y) / 2), e }, fill: function (e) { return e.repeat.x = 1, e.repeat.y = 1, e.offset.x = 0, e.offset.y = 0, e }, getByteLength: Kv }; function Zv(e, t, n, r, i, a, o) { const s = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), c = new uh, u = new WeakMap; let d; const h = new WeakMap; let p = !1; try { p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function f(e, t) { return p ? new OffscreenCanvas(e, t) : gh("canvas") } function m(e, t, n) { let r = 1; const i = z(e); if ((i.width > n || i.height > n) && (r = n / Math.max(i.width, i.height)), r < 1) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) { const n = Math.floor(r * i.width), a = Math.floor(r * i.height); void 0 === d && (d = f(n, a)); const o = t ? f(n, a) : d; return o.width = n, o.height = a, o.getContext("2d").drawImage(e, 0, 0, n, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + i.width + "x" + i.height + ") to (" + n + "x" + a + ")."), o } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + i.width + "x" + i.height + ")."), e } return e } function g(e) { return e.generateMipmaps && e.minFilter !== Cc && e.minFilter !== Pc } function v(t) { e.generateMipmap(t) } function y(n, r, i, a, o = !1) { if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let s = r; if (r === e.RED && (i === e.FLOAT && (s = e.R32F), i === e.HALF_FLOAT && (s = e.R16F), i === e.UNSIGNED_BYTE && (s = e.R8)), r === e.RED_INTEGER && (i === e.UNSIGNED_BYTE && (s = e.R8UI), i === e.UNSIGNED_SHORT && (s = e.R16UI), i === e.UNSIGNED_INT && (s = e.R32UI), i === e.BYTE && (s = e.R8I), i === e.SHORT && (s = e.R16I), i === e.INT && (s = e.R32I)), r === e.RG && (i === e.FLOAT && (s = e.RG32F), i === e.HALF_FLOAT && (s = e.RG16F), i === e.UNSIGNED_BYTE && (s = e.RG8)), r === e.RG_INTEGER && (i === e.UNSIGNED_BYTE && (s = e.RG8UI), i === e.UNSIGNED_SHORT && (s = e.RG16UI), i === e.UNSIGNED_INT && (s = e.RG32UI), i === e.BYTE && (s = e.RG8I), i === e.SHORT && (s = e.RG16I), i === e.INT && (s = e.RG32I)), r === e.RGB_INTEGER && (i === e.UNSIGNED_BYTE && (s = e.RGB8UI), i === e.UNSIGNED_SHORT && (s = e.RGB16UI), i === e.UNSIGNED_INT && (s = e.RGB32UI), i === e.BYTE && (s = e.RGB8I), i === e.SHORT && (s = e.RGB16I), i === e.INT && (s = e.RGB32I)), r === e.RGBA_INTEGER && (i === e.UNSIGNED_BYTE && (s = e.RGBA8UI), i === e.UNSIGNED_SHORT && (s = e.RGBA16UI), i === e.UNSIGNED_INT && (s = e.RGBA32UI), i === e.BYTE && (s = e.RGBA8I), i === e.SHORT && (s = e.RGBA16I), i === e.INT && (s = e.RGBA32I)), r === e.RGB && i === e.UNSIGNED_INT_5_9_9_9_REV && (s = e.RGB9_E5), r === e.RGBA) { const t = o ? dd : wh.getTransfer(a); i === e.FLOAT && (s = e.RGBA32F), i === e.HALF_FLOAT && (s = e.RGBA16F), i === e.UNSIGNED_BYTE && (s = t === hd ? e.SRGB8_ALPHA8 : e.RGBA8), i === e.UNSIGNED_SHORT_4_4_4_4 && (s = e.RGBA4), i === e.UNSIGNED_SHORT_5_5_5_1 && (s = e.RGB5_A1) } return s !== e.R16F && s !== e.R32F && s !== e.RG16F && s !== e.RG32F && s !== e.RGBA16F && s !== e.RGBA32F || t.get("EXT_color_buffer_float"), s } function b(t, n) { let r; return t ? null === n || n === Gc || n === Jc ? r = e.DEPTH24_STENCIL8 : n === jc ? r = e.DEPTH32F_STENCIL8 : n === zc && (r = e.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === n || n === Gc || n === Jc ? r = e.DEPTH_COMPONENT24 : n === jc ? r = e.DEPTH_COMPONENT32F : n === zc && (r = e.DEPTH_COMPONENT16), r } function x(e, t) { return !0 === g(e) || e.isFramebufferTexture && e.minFilter !== Cc && e.minFilter !== Pc ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1 } function A(e) { const t = e.target; t.removeEventListener("dispose", A), function (e) { const t = r.get(e); if (void 0 === t.__webglInit) return; const n = e.source, i = h.get(n); if (i) { const r = i[t.__cacheKey]; r.usedTimes--, 0 === r.usedTimes && M(e), 0 === Object.keys(i).length && h.delete(n) } r.remove(e) }(t), t.isVideoTexture && u.delete(t) } function S(t) { const n = t.target; n.removeEventListener("dispose", S), function (t) { const n = r.get(t); if (t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) { if (Array.isArray(n.__webglFramebuffer[t])) for (let r = 0; r < n.__webglFramebuffer[t].length; r++)e.deleteFramebuffer(n.__webglFramebuffer[t][r]); else e.deleteFramebuffer(n.__webglFramebuffer[t]); n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t]) } else { if (Array.isArray(n.__webglFramebuffer)) for (let t = 0; t < n.__webglFramebuffer.length; t++)e.deleteFramebuffer(n.__webglFramebuffer[t]); else e.deleteFramebuffer(n.__webglFramebuffer); if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer) for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]); n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer) } const i = t.textures; for (let t = 0, n = i.length; t < n; t++) { const n = r.get(i[t]); n.__webglTexture && (e.deleteTexture(n.__webglTexture), o.memory.textures--), r.remove(i[t]) } r.remove(t) }(n) } function M(t) { const n = r.get(t); e.deleteTexture(n.__webglTexture); const i = t.source; delete h.get(i)[n.__cacheKey], o.memory.textures-- } let w = 0; function _(t, i) { const a = r.get(t); if (t.isVideoTexture && function (e) { const t = o.render.frame; u.get(e) !== t && (u.set(e, t), e.update()) }(t), !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) { const e = t.image; if (null === e) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else { if (!1 !== e.complete) return void I(a, t, i); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + i) } const E = { [wc]: e.REPEAT, [_c]: e.CLAMP_TO_EDGE, [Ec]: e.MIRRORED_REPEAT }, C = { [Cc]: e.NEAREST, [Tc]: e.NEAREST_MIPMAP_NEAREST, [Bc]: e.NEAREST_MIPMAP_LINEAR, [Pc]: e.LINEAR, [Lc]: e.LINEAR_MIPMAP_NEAREST, [kc]: e.LINEAR_MIPMAP_LINEAR }, T = { [Id]: e.NEVER, [Od]: e.ALWAYS, [Pd]: e.LESS, [Dd]: e.LEQUAL, [Ld]: e.EQUAL, [Fd]: e.GEQUAL, [kd]: e.GREATER, [Nd]: e.NOTEQUAL }; function R(n, a) { if (a.type !== jc || !1 !== t.has("OES_texture_float_linear") || a.magFilter !== Pc && a.magFilter !== Lc && a.magFilter !== Bc && a.magFilter !== kc && a.minFilter !== Pc && a.minFilter !== Lc && a.minFilter !== Bc && a.minFilter !== kc || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), e.texParameteri(n, e.TEXTURE_WRAP_S, E[a.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, E[a.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, E[a.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, C[a.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, C[a.minFilter]), a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, T[a.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) { if (a.magFilter === Cc) return; if (a.minFilter !== Bc && a.minFilter !== kc) return; if (a.type === jc && !1 === t.has("OES_texture_float_linear")) return; if (a.anisotropy > 1 || r.get(a).__currentAnisotropy) { const o = t.get("EXT_texture_filter_anisotropic"); e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy } } } function B(t, n) { let r = !1; void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", A)); const i = n.source; let a = h.get(i); void 0 === a && (a = {}, h.set(i, a)); const s = function (e) { const t = []; return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join() }(n); if (s !== t.__cacheKey) { void 0 === a[s] && (a[s] = { texture: e.createTexture(), usedTimes: 0 }, o.memory.textures++, r = !0), a[s].usedTimes++; const i = a[t.__cacheKey]; void 0 !== i && (a[t.__cacheKey].usedTimes--, 0 === i.usedTimes && M(n)), t.__cacheKey = s, t.__webglTexture = a[s].texture } return r } function I(t, o, s) { let l = e.TEXTURE_2D; (o.isDataArrayTexture || o.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY), o.isData3DTexture && (l = e.TEXTURE_3D); const c = B(t, o), u = o.source; n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + s); const d = r.get(u); if (u.version !== d.__version || !0 === c) { n.activeTexture(e.TEXTURE0 + s); const t = wh.getPrimaries(wh.workingColorSpace), r = o.colorSpace === od ? null : wh.getPrimaries(o.colorSpace), h = o.colorSpace === od || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h); let p = m(o.image, !1, i.maxTextureSize); p = U(o, p); const f = a.convert(o.format, o.colorSpace), A = a.convert(o.type); let S, M = y(o.internalFormat, f, A, o.colorSpace, o.isVideoTexture); R(l, o); const w = o.mipmaps, _ = !0 !== o.isVideoTexture, E = void 0 === d.__version || !0 === c, C = u.dataReady, T = x(o, p); if (o.isDepthTexture) M = b(o.format === tu, o.type), E && (_ ? n.texStorage2D(e.TEXTURE_2D, 1, M, p.width, p.height) : n.texImage2D(e.TEXTURE_2D, 0, M, p.width, p.height, 0, f, A, null)); else if (o.isDataTexture) if (w.length > 0) { _ && E && n.texStorage2D(e.TEXTURE_2D, T, M, w[0].width, w[0].height); for (let t = 0, r = w.length; t < r; t++)S = w[t], _ ? C && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, f, A, S.data) : n.texImage2D(e.TEXTURE_2D, t, M, S.width, S.height, 0, f, A, S.data); o.generateMipmaps = !1 } else _ ? (E && n.texStorage2D(e.TEXTURE_2D, T, M, p.width, p.height), C && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, f, A, p.data)) : n.texImage2D(e.TEXTURE_2D, 0, M, p.width, p.height, 0, f, A, p.data); else if (o.isCompressedTexture) if (o.isCompressedArrayTexture) { _ && E && n.texStorage3D(e.TEXTURE_2D_ARRAY, T, M, w[0].width, w[0].height, p.depth); for (let t = 0, r = w.length; t < r; t++)if (S = w[t], o.format !== qc) if (null !== f) if (_) { if (C) if (o.layerUpdates.size > 0) { const r = Kv(S.width, S.height, o.format, o.type); for (const i of o.layerUpdates) { const a = S.data.subarray(i * r / S.data.BYTES_PER_ELEMENT, (i + 1) * r / S.data.BYTES_PER_ELEMENT); n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, i, S.width, S.height, 1, f, a, 0, 0) } o.clearLayerUpdates() } else n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, p.depth, f, S.data, 0, 0) } else n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, M, S.width, S.height, p.depth, 0, S.data, 0, 0); else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"); else _ ? C && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, p.depth, f, A, S.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, M, S.width, S.height, p.depth, 0, f, A, S.data) } else { _ && E && n.texStorage2D(e.TEXTURE_2D, T, M, w[0].width, w[0].height); for (let t = 0, r = w.length; t < r; t++)S = w[t], o.format !== qc ? null !== f ? _ ? C && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, f, S.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, M, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _ ? C && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, f, A, S.data) : n.texImage2D(e.TEXTURE_2D, t, M, S.width, S.height, 0, f, A, S.data) } else if (o.isDataArrayTexture) if (_) { if (E && n.texStorage3D(e.TEXTURE_2D_ARRAY, T, M, p.width, p.height, p.depth), C) if (o.layerUpdates.size > 0) { const t = Kv(p.width, p.height, o.format, o.type); for (const r of o.layerUpdates) { const i = p.data.subarray(r * t / p.data.BYTES_PER_ELEMENT, (r + 1) * t / p.data.BYTES_PER_ELEMENT); n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, r, p.width, p.height, 1, f, A, i) } o.clearLayerUpdates() } else n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, f, A, p.data) } else n.texImage3D(e.TEXTURE_2D_ARRAY, 0, M, p.width, p.height, p.depth, 0, f, A, p.data); else if (o.isData3DTexture) _ ? (E && n.texStorage3D(e.TEXTURE_3D, T, M, p.width, p.height, p.depth), C && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, f, A, p.data)) : n.texImage3D(e.TEXTURE_3D, 0, M, p.width, p.height, p.depth, 0, f, A, p.data); else if (o.isFramebufferTexture) { if (E) if (_) n.texStorage2D(e.TEXTURE_2D, T, M, p.width, p.height); else { let t = p.width, r = p.height; for (let i = 0; i < T; i++)n.texImage2D(e.TEXTURE_2D, i, M, t, r, 0, f, A, null), t >>= 1, r >>= 1 } } else if (w.length > 0) { if (_ && E) { const t = z(w[0]); n.texStorage2D(e.TEXTURE_2D, T, M, t.width, t.height) } for (let t = 0, r = w.length; t < r; t++)S = w[t], _ ? C && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, A, S) : n.texImage2D(e.TEXTURE_2D, t, M, f, A, S); o.generateMipmaps = !1 } else if (_) { if (E) { const t = z(p); n.texStorage2D(e.TEXTURE_2D, T, M, t.width, t.height) } C && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, A, p) } else n.texImage2D(e.TEXTURE_2D, 0, M, f, A, p); g(o) && v(l), d.__version = u.version, o.onUpdate && o.onUpdate(o) } t.__version = o.version } function P(t, i, o, l, c, u) { const d = a.convert(o.format, o.colorSpace), h = a.convert(o.type), p = y(o.internalFormat, d, h, o.colorSpace); if (!r.get(i).__hasExternalTextures) { const t = Math.max(1, i.width >> u), r = Math.max(1, i.height >> u); c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, p, t, r, i.depth, 0, d, h, null) : n.texImage2D(c, u, p, t, r, 0, d, h, null) } n.bindFramebuffer(e.FRAMEBUFFER, t), O(i) ? s.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, r.get(o).__webglTexture, 0, F(i)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, r.get(o).__webglTexture, u), n.bindFramebuffer(e.FRAMEBUFFER, null) } function L(t, n, r) { if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer) { const i = n.depthTexture, a = i && i.isDepthTexture ? i.type : null, o = b(n.stencilBuffer, a), l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, c = F(n); O(n) ? s.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, o, n.width, n.height) : r ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, o, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, o, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t) } else { const t = n.textures; for (let i = 0; i < t.length; i++) { const o = t[i], l = a.convert(o.format, o.colorSpace), c = a.convert(o.type), u = y(o.internalFormat, l, c, o.colorSpace), d = F(n); r && !1 === O(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, u, n.width, n.height) : O(n) ? s.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height) } } e.bindRenderbuffer(e.RENDERBUFFER, null) } function D(t) { const i = r.get(t), a = !0 === t.isWebGLCubeRenderTarget; if (i.__boundDepthTexture !== t.depthTexture) { const e = t.depthTexture; if (i.__depthDisposeCallback && i.__depthDisposeCallback(), e) { const t = () => { delete i.__boundDepthTexture, delete i.__depthDisposeCallback, e.removeEventListener("dispose", t) }; e.addEventListener("dispose", t), i.__depthDisposeCallback = t } i.__boundDepthTexture = e } if (t.depthTexture && !i.__autoAllocateDepthBuffer) { if (a) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, i) { if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(e.FRAMEBUFFER, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), _(i.depthTexture, 0); const a = r.get(i.depthTexture).__webglTexture, o = F(i); if (i.depthTexture.format === eu) O(i) ? s.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, o) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0); else { if (i.depthTexture.format !== tu) throw new Error("Unknown depthTexture format"); O(i) ? s.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, o) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0) } }(i.__webglFramebuffer, t) } else if (a) { i.__webglDepthbuffer = []; for (let r = 0; r < 6; r++)if (n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]), void 0 === i.__webglDepthbuffer[r]) i.__webglDepthbuffer[r] = e.createRenderbuffer(), L(i.__webglDepthbuffer[r], t, !1); else { const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, a = i.__webglDepthbuffer[r]; e.bindRenderbuffer(e.RENDERBUFFER, a), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, a) } } else if (n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer), void 0 === i.__webglDepthbuffer) i.__webglDepthbuffer = e.createRenderbuffer(), L(i.__webglDepthbuffer, t, !1); else { const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, r = i.__webglDepthbuffer; e.bindRenderbuffer(e.RENDERBUFFER, r), e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, r) } n.bindFramebuffer(e.FRAMEBUFFER, null) } const k = [], N = []; function F(e) { return Math.min(i.maxSamples, e.samples) } function O(e) { const n = r.get(e); return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture } function U(e, t) { const n = e.colorSpace, r = e.format, i = e.type; return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== ld && n !== od && (wh.getTransfer(n) === hd ? r === qc && i === Fc || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)), t } function z(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width, c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth, c.height = e.displayHeight) : (c.width = e.width, c.height = e.height), c } this.allocateTextureUnit = function () { const e = w; return e >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + i.maxTextures), w += 1, e }, this.resetTextureUnits = function () { w = 0 }, this.setTexture2D = _, this.setTexture2DArray = function (t, i) { const a = r.get(t); t.version > 0 && a.__version !== t.version ? I(a, t, i) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + i) }, this.setTexture3D = function (t, i) { const a = r.get(t); t.version > 0 && a.__version !== t.version ? I(a, t, i) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + i) }, this.setTextureCube = function (t, o) { const s = r.get(t); t.version > 0 && s.__version !== t.version ? function (t, o, s) { if (6 !== o.image.length) return; const l = B(t, o), c = o.source; n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + s); const u = r.get(c); if (c.version !== u.__version || !0 === l) { n.activeTexture(e.TEXTURE0 + s); const t = wh.getPrimaries(wh.workingColorSpace), r = o.colorSpace === od ? null : wh.getPrimaries(o.colorSpace), d = o.colorSpace === od || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d); const h = o.isCompressedTexture || o.image[0].isCompressedTexture, p = o.image[0] && o.image[0].isDataTexture, f = []; for (let e = 0; e < 6; e++)f[e] = h || p ? p ? o.image[e].image : o.image[e] : m(o.image[e], !0, i.maxCubemapSize), f[e] = U(o, f[e]); const b = f[0], A = a.convert(o.format, o.colorSpace), S = a.convert(o.type), M = y(o.internalFormat, A, S, o.colorSpace), w = !0 !== o.isVideoTexture, _ = void 0 === u.__version || !0 === l, E = c.dataReady; let C, T = x(o, b); if (R(e.TEXTURE_CUBE_MAP, o), h) { w && _ && n.texStorage2D(e.TEXTURE_CUBE_MAP, T, M, b.width, b.height); for (let t = 0; t < 6; t++) { C = f[t].mipmaps; for (let r = 0; r < C.length; r++) { const i = C[r]; o.format !== qc ? null !== A ? w ? E && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, i.width, i.height, A, i.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, M, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : w ? E && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, i.width, i.height, A, S, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, M, i.width, i.height, 0, A, S, i.data) } } } else { if (C = o.mipmaps, w && _) { C.length > 0 && T++; const t = z(f[0]); n.texStorage2D(e.TEXTURE_CUBE_MAP, T, M, t.width, t.height) } for (let t = 0; t < 6; t++)if (p) { w ? E && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, f[t].width, f[t].height, A, S, f[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, M, f[t].width, f[t].height, 0, A, S, f[t].data); for (let r = 0; r < C.length; r++) { const i = C[r].image[t].image; w ? E && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, i.width, i.height, A, S, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, M, i.width, i.height, 0, A, S, i.data) } } else { w ? E && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, A, S, f[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, M, A, S, f[t]); for (let r = 0; r < C.length; r++) { const i = C[r]; w ? E && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, A, S, i.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, M, A, S, i.image[t]) } } } g(o) && v(e.TEXTURE_CUBE_MAP), u.__version = c.version, o.onUpdate && o.onUpdate(o) } t.__version = o.version }(s, t, o) : n.bindTexture(e.TEXTURE_CUBE_MAP, s.__webglTexture, e.TEXTURE0 + o) }, this.rebindTextures = function (t, n, i) { const a = r.get(t); void 0 !== n && P(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== i && D(t) }, this.setupRenderTarget = function (t) { const i = t.texture, s = r.get(t), l = r.get(i); t.addEventListener("dispose", S); const c = t.textures, u = !0 === t.isWebGLCubeRenderTarget, d = c.length > 1; if (d || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = i.version, o.memory.textures++), u) { s.__webglFramebuffer = []; for (let t = 0; t < 6; t++)if (i.mipmaps && i.mipmaps.length > 0) { s.__webglFramebuffer[t] = []; for (let n = 0; n < i.mipmaps.length; n++)s.__webglFramebuffer[t][n] = e.createFramebuffer() } else s.__webglFramebuffer[t] = e.createFramebuffer() } else { if (i.mipmaps && i.mipmaps.length > 0) { s.__webglFramebuffer = []; for (let t = 0; t < i.mipmaps.length; t++)s.__webglFramebuffer[t] = e.createFramebuffer() } else s.__webglFramebuffer = e.createFramebuffer(); if (d) for (let t = 0, n = c.length; t < n; t++) { const n = r.get(c[t]); void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), o.memory.textures++) } if (t.samples > 0 && !1 === O(t)) { s.__webglMultisampledFramebuffer = e.createFramebuffer(), s.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, s.__webglMultisampledFramebuffer); for (let n = 0; n < c.length; n++) { const r = c[n]; s.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, s.__webglColorRenderbuffer[n]); const i = a.convert(r.format, r.colorSpace), o = a.convert(r.type), l = y(r.internalFormat, i, o, r.colorSpace, !0 === t.isXRRenderTarget), u = F(t); e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, s.__webglColorRenderbuffer[n]) } e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), L(s.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null) } } if (u) { n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), R(e.TEXTURE_CUBE_MAP, i); for (let n = 0; n < 6; n++)if (i.mipmaps && i.mipmaps.length > 0) for (let r = 0; r < i.mipmaps.length; r++)P(s.__webglFramebuffer[n][r], t, i, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r); else P(s.__webglFramebuffer[n], t, i, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0); g(i) && v(e.TEXTURE_CUBE_MAP), n.unbindTexture() } else if (d) { for (let i = 0, a = c.length; i < a; i++) { const a = c[i], o = r.get(a); n.bindTexture(e.TEXTURE_2D, o.__webglTexture), R(e.TEXTURE_2D, a), P(s.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + i, e.TEXTURE_2D, 0), g(a) && v(e.TEXTURE_2D) } n.unbindTexture() } else { let r = e.TEXTURE_2D; if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(r, l.__webglTexture), R(r, i), i.mipmaps && i.mipmaps.length > 0) for (let n = 0; n < i.mipmaps.length; n++)P(s.__webglFramebuffer[n], t, i, e.COLOR_ATTACHMENT0, r, n); else P(s.__webglFramebuffer, t, i, e.COLOR_ATTACHMENT0, r, 0); g(i) && v(r), n.unbindTexture() } t.depthBuffer && D(t) }, this.updateRenderTargetMipmap = function (t) { const i = t.textures; for (let a = 0, o = i.length; a < o; a++) { const o = i[a]; if (g(o)) { const i = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, a = r.get(o).__webglTexture; n.bindTexture(i, a), v(i), n.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (t) { if (t.samples > 0) if (!1 === O(t)) { const i = t.textures, a = t.width, o = t.height; let s = e.COLOR_BUFFER_BIT; const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, u = r.get(t), d = i.length > 1; if (d) for (let t = 0; t < i.length; t++)n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0); n.bindFramebuffer(e.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer); for (let n = 0; n < i.length; n++) { if (t.resolveDepthBuffer && (t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (s |= e.STENCIL_BUFFER_BIT)), d) { e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, u.__webglColorRenderbuffer[n]); const t = r.get(i[n]).__webglTexture; e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0) } e.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, e.NEAREST), !0 === l && (k.length = 0, N.length = 0, k.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && (k.push(c), N.push(c), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, N)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, k)) } if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), d) for (let t = 0; t < i.length; t++) { n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, u.__webglColorRenderbuffer[t]); const a = r.get(i[t]).__webglTexture; n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0) } n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer) } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) { const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT; e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n]) } }, this.setupDepthRenderbuffer = D, this.setupFrameBufferTexture = P, this.useMultisampledRTT = O } function $v(e, t) { return { convert: function (n, r = od) { let i; const a = wh.getTransfer(r); if (n === Fc) return e.UNSIGNED_BYTE; if (n === Wc) return e.UNSIGNED_SHORT_4_4_4_4; if (n === Xc) return e.UNSIGNED_SHORT_5_5_5_1; if (n === Yc) return e.UNSIGNED_INT_5_9_9_9_REV; if (n === Oc) return e.BYTE; if (n === Uc) return e.SHORT; if (n === zc) return e.UNSIGNED_SHORT; if (n === Hc) return e.INT; if (n === Gc) return e.UNSIGNED_INT; if (n === jc) return e.FLOAT; if (n === Vc) return e.HALF_FLOAT; if (n === Qc) return e.ALPHA; if (n === Kc) return e.RGB; if (n === qc) return e.RGBA; if (n === Zc) return e.LUMINANCE; if (n === $c) return e.LUMINANCE_ALPHA; if (n === eu) return e.DEPTH_COMPONENT; if (n === tu) return e.DEPTH_STENCIL; if (n === nu) return e.RED; if (n === ru) return e.RED_INTEGER; if (n === iu) return e.RG; if (n === au) return e.RG_INTEGER; if (n === su) return e.RGBA_INTEGER; if (n === lu || n === cu || n === uu || n === du) if (a === hd) { if (i = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === i) return null; if (n === lu) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (n === cu) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (n === uu) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (n === du) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (i = t.get("WEBGL_compressed_texture_s3tc"), null === i) return null; if (n === lu) return i.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === cu) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === uu) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === du) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (n === hu || n === pu || n === fu || n === mu) { if (i = t.get("WEBGL_compressed_texture_pvrtc"), null === i) return null; if (n === hu) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (n === pu) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (n === fu) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (n === mu) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (n === gu || n === vu || n === yu) { if (i = t.get("WEBGL_compressed_texture_etc"), null === i) return null; if (n === gu || n === vu) return a === hd ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2; if (n === yu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC } if (n === bu || n === xu || n === Au || n === Su || n === Mu || n === wu || n === _u || n === Eu || n === Cu || n === Tu || n === Ru || n === Bu || n === Iu || n === Pu) { if (i = t.get("WEBGL_compressed_texture_astc"), null === i) return null; if (n === bu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR; if (n === xu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR; if (n === Au) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR; if (n === Su) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR; if (n === Mu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR; if (n === wu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR; if (n === _u) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR; if (n === Eu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR; if (n === Cu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR; if (n === Tu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR; if (n === Ru) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR; if (n === Bu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR; if (n === Iu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR; if (n === Pu) return a === hd ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR } if (n === Lu || n === Du || n === ku) { if (i = t.get("EXT_texture_compression_bptc"), null === i) return null; if (n === Lu) return a === hd ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (n === Du) return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (n === ku) return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } if (n === Nu || n === Fu || n === Ou || n === Uu) { if (i = t.get("EXT_texture_compression_rgtc"), null === i) return null; if (n === Lu) return i.COMPRESSED_RED_RGTC1_EXT; if (n === Fu) return i.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (n === Ou) return i.COMPRESSED_RED_GREEN_RGTC2_EXT; if (n === Uu) return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } return n === Jc ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null } } } class ey extends um { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class ty extends Wp { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const ny = { type: "move" }; class ry { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new ty, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new ty, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Gh, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Gh), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new ty, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Gh, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Gh), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const n of e.hand.values()) this._getHandJoint(t, n) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, n) { let r = null, i = null, a = null; const o = this._targetRay, s = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) { if (l && e.hand) { a = !0; for (const r of e.hand.values()) { const e = t.getJointPose(r, n), i = this._getHandJoint(l, r); null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.matrixWorldNeedsUpdate = !0, i.jointRadius = e.radius), i.visible = null !== e } const r = l.joints["index-finger-tip"], i = l.joints["thumb-tip"], o = r.position.distanceTo(i.position), s = .02, c = .005; l.inputState.pinching && o > s + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && o <= s - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== s && e.gripSpace && (i = t.getPose(e.gripSpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1)); null !== o && (r = t.getPose(e.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(ny))) } return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this } _getHandJoint(e, t) { if (void 0 === e.joints[t.jointName]) { const n = new ty; n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n) } return e.joints[t.jointName] } } class iy { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(e, t, n) { if (null === this.texture) { const r = new Lh; e.properties.get(r).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r } } getMesh(e) { if (null !== this.texture && null === this.mesh) { const t = e.cameras[0].viewport, n = new am({ vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}", fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}", uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } }); this.mesh = new Zf(new wm(20, 20), n) } return this.mesh } reset() { this.texture = null, this.mesh = null } getDepthTexture() { return this.texture } } class ay extends Zd { constructor(e, t) { super(); const n = this; let r = null, i = 1, a = null, o = "local-floor", s = 1, l = null, c = null, u = null, d = null, h = null, p = null; const f = new iy, m = t.getContextAttributes(); let g = null, v = null; const y = [], b = [], x = new uh; let A = null; const S = new um; S.layers.enable(1), S.viewport = new Dh; const M = new um; M.layers.enable(2), M.viewport = new Dh; const w = [S, M], _ = new ey; _.layers.enable(1), _.layers.enable(2); let E = null, C = null; function T(e) { const t = b.indexOf(e.inputSource); if (-1 === t) return; const n = y[t]; void 0 !== n && (n.update(e.inputSource, e.frame, l || a), n.dispatchEvent({ type: e.type, data: e.inputSource })) } function R() { r.removeEventListener("select", T), r.removeEventListener("selectstart", T), r.removeEventListener("selectend", T), r.removeEventListener("squeeze", T), r.removeEventListener("squeezestart", T), r.removeEventListener("squeezeend", T), r.removeEventListener("end", R), r.removeEventListener("inputsourceschange", B); for (let e = 0; e < y.length; e++) { const t = b[e]; null !== t && (b[e] = null, y[e].disconnect(t)) } E = null, C = null, f.reset(), e.setRenderTarget(g), h = null, d = null, u = null, r = null, v = null, k.stop(), n.isPresenting = !1, e.setPixelRatio(A), e.setSize(x.width, x.height, !1), n.dispatchEvent({ type: "sessionend" }) } function B(e) { for (let t = 0; t < e.removed.length; t++) { const n = e.removed[t], r = b.indexOf(n); r >= 0 && (b[r] = null, y[r].disconnect(n)) } for (let t = 0; t < e.added.length; t++) { const n = e.added[t]; let r = b.indexOf(n); if (-1 === r) { for (let e = 0; e < y.length; e++) { if (e >= b.length) { b.push(n), r = e; break } if (null === b[e]) { b[e] = n, r = e; break } } if (-1 === r) break } const i = y[r]; i && i.connect(n) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = y[e]; return void 0 === t && (t = new ry, y[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = y[e]; return void 0 === t && (t = new ry, y[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = y[e]; return void 0 === t && (t = new ry, y[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { o = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return l || a }, this.setReferenceSpace = function (e) { l = e }, this.getBaseLayer = function () { return null !== d ? d : h }, this.getBinding = function () { return u }, this.getFrame = function () { return p }, this.getSession = function () { return r }, this.setSession = async function (c) { if (r = c, null !== r) { if (g = e.getRenderTarget(), r.addEventListener("select", T), r.addEventListener("selectstart", T), r.addEventListener("selectend", T), r.addEventListener("squeeze", T), r.addEventListener("squeezestart", T), r.addEventListener("squeezeend", T), r.addEventListener("end", R), r.addEventListener("inputsourceschange", B), !0 !== m.xrCompatible && await t.makeXRCompatible(), A = e.getPixelRatio(), e.getSize(x), void 0 === r.renderState.layers) { const n = { antialias: m.antialias, alpha: !0, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: i }; h = new XRWebGLLayer(r, t, n), r.updateRenderState({ baseLayer: h }), e.setPixelRatio(1), e.setSize(h.framebufferWidth, h.framebufferHeight, !1), v = new Nh(h.framebufferWidth, h.framebufferHeight, { format: qc, type: Fc, colorSpace: e.outputColorSpace, stencilBuffer: m.stencil }) } else { let n = null, a = null, o = null; m.depth && (o = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = m.stencil ? tu : eu, a = m.stencil ? Jc : Gc); const s = { colorFormat: t.RGBA8, depthFormat: o, scaleFactor: i }; u = new XRWebGLBinding(r, t), d = u.createProjectionLayer(s), r.updateRenderState({ layers: [d] }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), v = new Nh(d.textureWidth, d.textureHeight, { format: qc, type: Fc, depthTexture: new og(d.textureWidth, d.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n), stencilBuffer: m.stencil, colorSpace: e.outputColorSpace, samples: m.antialias ? 4 : 0, resolveDepthBuffer: !1 === d.ignoreDepthValues }) } v.isXRRenderTarget = !0, this.setFoveation(s), l = null, a = await r.requestReferenceSpace(o), k.setContext(r), k.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (null !== r) return r.environmentBlendMode }, this.getDepthTexture = function () { return f.getDepthTexture() }; const I = new Gh, P = new Gh; function L(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === r) return; let t = e.near, n = e.far; null !== f.texture && (f.depthNear > 0 && (t = f.depthNear), f.depthFar > 0 && (n = f.depthFar)), _.near = M.near = S.near = t, _.far = M.far = S.far = n, E === _.near && C === _.far || (r.updateRenderState({ depthNear: _.near, depthFar: _.far }), E = _.near, C = _.far); const i = e.parent, a = _.cameras; L(_, i); for (let e = 0; e < a.length; e++)L(a[e], i); 2 === a.length ? function (e, t, n) { I.setFromMatrixPosition(t.matrixWorld), P.setFromMatrixPosition(n.matrixWorld); const r = I.distanceTo(P), i = t.projectionMatrix.elements, a = n.projectionMatrix.elements, o = i[14] / (i[10] - 1), s = i[14] / (i[10] + 1), l = (i[9] + 1) / i[5], c = (i[9] - 1) / i[5], u = (i[8] - 1) / i[0], d = (a[8] + 1) / a[0], h = o * u, p = o * d, f = r / (-u + d), m = f * -u; if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === i[10]) e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse); else { const t = o + f, n = s + f, i = h - m, a = p + (r - m), u = l * s / n * t, d = c * s / n * t; e.projectionMatrix.makePerspective(i, a, u, d, t, n), e.projectionMatrixInverse.copy(e.projectionMatrix).invert() } }(_, S, M) : _.projectionMatrix.copy(S.projectionMatrix), function (e, t, n) { null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld)), e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * nh * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1) }(e, _, i) }, this.getCamera = function () { return _ }, this.getFoveation = function () { if (null !== d || null !== h) return s }, this.setFoveation = function (e) { s = e, null !== d && (d.fixedFoveation = e), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e) }, this.hasDepthSensing = function () { return null !== f.texture }, this.getDepthSensingMesh = function () { return f.getMesh(_) }; let D = null; const k = new Sm; k.setAnimationLoop((function (t, i) { if (c = i.getViewerPose(l || a), p = i, null !== c) { const t = c.views; null !== h && (e.setRenderTargetFramebuffer(v, h.framebuffer), e.setRenderTarget(v)); let n = !1; t.length !== _.cameras.length && (_.cameras.length = 0, n = !0); for (let r = 0; r < t.length; r++) { const i = t[r]; let a = null; if (null !== h) a = h.getViewport(i); else { const t = u.getViewSubImage(d, i); a = t.viewport, 0 === r && (e.setRenderTargetTextures(v, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(v)) } let o = w[r]; void 0 === o && (o = new um, o.layers.enable(r), o.viewport = new Dh, w[r] = o), o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale), o.projectionMatrix.fromArray(i.projectionMatrix), o.projectionMatrixInverse.copy(o.projectionMatrix).invert(), o.viewport.set(a.x, a.y, a.width, a.height), 0 === r && (_.matrix.copy(o.matrix), _.matrix.decompose(_.position, _.quaternion, _.scale)), !0 === n && _.cameras.push(o) } const i = r.enabledFeatures; if (i && i.includes("depth-sensing")) { const n = u.getDepthInformation(t[0]); n && n.isValid && n.texture && f.init(e, n, r.renderState) } } for (let e = 0; e < y.length; e++) { const t = b[e], n = y[e]; null !== t && void 0 !== n && n.update(t, i, l || a) } D && D(t, i), i.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: i }), p = null })), this.setAnimationLoop = function (e) { D = e }, this.dispose = function () { } } } const oy = new Tp, sy = new yp; function ly(e, t) { function n(e, t) { !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix) } function r(e, r) { e.opacity.value = r.opacity, r.color && e.diffuse.value.copy(r.color), r.emissive && e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (e.map.value = r.map, n(r.map, e.mapTransform)), r.alphaMap && (e.alphaMap.value = r.alphaMap, n(r.alphaMap, e.alphaMapTransform)), r.bumpMap && (e.bumpMap.value = r.bumpMap, n(r.bumpMap, e.bumpMapTransform), e.bumpScale.value = r.bumpScale, r.side === Ml && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, n(r.normalMap, e.normalMapTransform), e.normalScale.value.copy(r.normalScale), r.side === Ml && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, n(r.displacementMap, e.displacementMapTransform), e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, e.emissiveMapTransform)), r.specularMap && (e.specularMap.value = r.specularMap, n(r.specularMap, e.specularMapTransform)), r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest); const i = t.get(r), a = i.envMap, o = i.envMapRotation; a && (e.envMap.value = a, oy.copy(o), oy.x *= -1, oy.y *= -1, oy.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (oy.y *= -1, oy.z *= -1), e.envMapRotation.value.setFromMatrix4(sy.makeRotationFromEuler(oy)), e.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = r.reflectivity, e.ior.value = r.ior, e.refractionRatio.value = r.refractionRatio), r.lightMap && (e.lightMap.value = r.lightMap, e.lightMapIntensity.value = r.lightMapIntensity, n(r.lightMap, e.lightMapTransform)), r.aoMap && (e.aoMap.value = r.aoMap, e.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, e.aoMapTransform)) } return { refreshFogUniforms: function (t, n) { n.color.getRGB(t.fogColor.value, rm(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density) }, refreshMaterialUniforms: function (e, i, a, o, s) { i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap) }(e, i)) : i.isMeshPhongMaterial ? (r(e, i), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4) }(e, i)) : i.isMeshStandardMaterial ? (r(e, i), function (e, t) { e.metalness.value = t.metalness, t.metalnessMap && (e.metalnessMap.value = t.metalnessMap, n(t.metalnessMap, e.metalnessMapTransform)), e.roughness.value = t.roughness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap, n(t.roughnessMap, e.roughnessMapTransform)), t.envMap && (e.envMapIntensity.value = t.envMapIntensity) }(e, i), i.isMeshPhysicalMaterial && function (e, t, r) { e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), t.side === Ml && e.clearcoatNormalScale.value.negate())), t.dispersion > 0 && (e.dispersion.value = t.dispersion), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform))), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform)), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform)) }(e, i, s)) : i.isMeshMatcapMaterial ? (r(e, i), function (e, t) { t.matcap && (e.matcap.value = t.matcap) }(e, i)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i), function (e, n) { const r = t.get(n).light; e.referencePosition.value.setFromMatrixPosition(r.matrixWorld), e.nearDistance.value = r.shadow.camera.near, e.farDistance.value = r.shadow.camera.far }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform)) }(e, i), i.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, i)) : i.isPointsMaterial ? function (e, t, r, i) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * r, e.scale.value = .5 * i, t.map && (e.map.value = t.map, n(t.map, e.uvTransform)), t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest) }(e, i, a, o) : i.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform)), t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest) }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function cy(e, t, n, r) { let i = {}, a = {}, o = []; const s = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS); function l(e, t, n, r) { const i = e.value, a = t + "_" + n; if (void 0 === r[a]) return r[a] = "number" == typeof i || "boolean" == typeof i ? i : i.clone(), !0; { const e = r[a]; if ("number" == typeof i || "boolean" == typeof i) { if (e !== i) return r[a] = i, !0 } else if (!1 === e.equals(i)) return e.copy(i), !0 } return !1 } function c(e) { const t = { boundary: 0, storage: 0 }; return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t } function u(t) { const n = t.target; n.removeEventListener("dispose", u); const r = o.indexOf(n.__bindingPointIndex); o.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete a[n.id] } return { bind: function (e, t) { const n = t.program; r.uniformBlockBinding(e, n) }, update: function (n, d) { let h = i[n.id]; void 0 === h && (function (e) { const t = e.uniforms; let n = 0; for (let e = 0, r = t.length; e < r; e++) { const r = Array.isArray(t[e]) ? t[e] : [t[e]]; for (let e = 0, t = r.length; e < t; e++) { const t = r[e], i = Array.isArray(t.value) ? t.value : [t.value]; for (let e = 0, r = i.length; e < r; e++) { const r = c(i[e]), a = n % 16, o = a % r.boundary, s = a + o; n += o, 0 !== s && 16 - s < r.storage && (n += 16 - s), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += r.storage } } } const r = n % 16; r > 0 && (n += 16 - r), e.__size = n, e.__cache = {} }(n), h = function (t) { const n = function () { for (let e = 0; e < s; e++)if (-1 === o.indexOf(e)) return o.push(e), e; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 }(); t.__bindingPointIndex = n; const r = e.createBuffer(), i = t.__size, a = t.usage; return e.bindBuffer(e.UNIFORM_BUFFER, r), e.bufferData(e.UNIFORM_BUFFER, i, a), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, r), r }(n), i[n.id] = h, n.addEventListener("dispose", u)); const p = d.program; r.updateUBOMapping(n, p); const f = t.render.frame; a[n.id] !== f && (function (t) { const n = i[t.id], r = t.uniforms, a = t.__cache; e.bindBuffer(e.UNIFORM_BUFFER, n); for (let t = 0, n = r.length; t < n; t++) { const n = Array.isArray(r[t]) ? r[t] : [r[t]]; for (let r = 0, i = n.length; r < i; r++) { const i = n[r]; if (!0 === l(i, t, r, a)) { const t = i.__offset, n = Array.isArray(i.value) ? i.value : [i.value]; let r = 0; for (let a = 0; a < n.length; a++) { const o = n[a], s = c(o); "number" == typeof o || "boolean" == typeof o ? (i.__data[0] = o, e.bufferSubData(e.UNIFORM_BUFFER, t + r, i.__data)) : o.isMatrix3 ? (i.__data[0] = o.elements[0], i.__data[1] = o.elements[1], i.__data[2] = o.elements[2], i.__data[3] = 0, i.__data[4] = o.elements[3], i.__data[5] = o.elements[4], i.__data[6] = o.elements[5], i.__data[7] = 0, i.__data[8] = o.elements[6], i.__data[9] = o.elements[7], i.__data[10] = o.elements[8], i.__data[11] = 0) : (o.toArray(i.__data, r), r += s.storage / Float32Array.BYTES_PER_ELEMENT) } e.bufferSubData(e.UNIFORM_BUFFER, t, i.__data) } } } e.bindBuffer(e.UNIFORM_BUFFER, null) }(n), a[n.id] = f) }, dispose: function () { for (const t in i) e.deleteBuffer(i[t]); o = [], i = {}, a = {} } } } class uy { constructor(e = {}) { const { canvas: t = vh(), context: n = null, depth: r = !0, stencil: i = !1, alpha: a = !1, antialias: o = !1, premultipliedAlpha: s = !0, preserveDrawingBuffer: l = !1, powerPreference: c = "default", failIfMajorPerformanceCaveat: u = !1 } = e; let d; if (this.isWebGLRenderer = !0, null !== n) { if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163."); d = n.getContextAttributes().alpha } else d = a; const h = new Uint32Array(4), p = new Int32Array(4); let f = null, m = null; const g = [], v = []; this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = sd, this.toneMapping = lc, this.toneMappingExposure = 1; const y = this; let b = !1, x = 0, A = 0, S = null, M = -1, w = null; const _ = new Dh, E = new Dh; let C = null; const T = new df(0); let R = 0, B = t.width, I = t.height, P = 1, L = null, D = null; const k = new Dh(0, 0, B, I), N = new Dh(0, 0, B, I); let F = !1; const O = new Am; let U = !1, z = !1; const H = new yp, G = new yp, j = new Gh, V = new Dh, W = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; let X = !1; function J() { return null === S ? P : 1 } let Y, Q, K, q, Z, $, ee, te, ne, re, ie, ae, oe, se, le, ce, ue, de, he, pe, fe, me, ge, ve, ye = n; function be(e, n) { return t.getContext(e, n) } try { const e = { alpha: !0, depth: r, stencil: i, antialias: o, premultipliedAlpha: s, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: u }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${dl}`), t.addEventListener("webglcontextlost", Se, !1), t.addEventListener("webglcontextrestored", Me, !1), t.addEventListener("webglcontextcreationerror", we, !1), null === ye) { const t = "webgl2"; if (ye = be(t, e), null === ye) throw be(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function xe() { Y = new eg(ye), Y.init(), me = new $v(ye, Y), Q = new Dm(ye, Y, e, me), K = new Qv(ye), Q.reverseDepthBuffer && K.buffers.depth.setReversed(!0), q = new rg(ye), Z = new Dv, $ = new Zv(ye, Y, K, Z, Q, me, q), ee = new Nm(y), te = new $m(y), ne = new Mm(ye), ge = new Pm(ye, ne), re = new tg(ye, ne, q, ge), ie = new ag(ye, re, ne, q), he = new ig(ye, Q, $), ce = new km(Z), ae = new Lv(y, ee, te, Y, Q, ge, ce), oe = new ly(y, Z), se = new Ov, le = new Vv(Y), de = new Im(y, ee, te, K, ie, d, s), ue = new Jv(y, ie, Q), ve = new cy(ye, q, Q, K), pe = new Lm(ye, Y, q), fe = new ng(ye, Y, q), q.programs = ae.programs, y.capabilities = Q, y.extensions = Y, y.properties = Z, y.renderLists = se, y.shadowMap = ue, y.state = K, y.info = q } xe(); const Ae = new ay(y, ye); function Se(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0 } function Me() { console.log("THREE.WebGLRenderer: Context Restored."), b = !1; const e = q.autoReset, t = ue.enabled, n = ue.autoUpdate, r = ue.needsUpdate, i = ue.type; xe(), q.autoReset = e, ue.enabled = t, ue.autoUpdate = n, ue.needsUpdate = r, ue.type = i } function we(e) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage) } function _e(e) { const t = e.target; t.removeEventListener("dispose", _e), function (e) { (function (e) { const t = Z.get(e).programs; void 0 !== t && (t.forEach((function (e) { ae.releaseProgram(e) })), e.isShaderMaterial && ae.releaseShaderCache(e)) })(e), Z.remove(e) }(t) } function Ee(e, t, n) { !0 === e.transparent && e.side === wl && !1 === e.forceSinglePass ? (e.side = Ml, e.needsUpdate = !0, Ne(e, t, n), e.side = Sl, e.needsUpdate = !0, Ne(e, t, n), e.side = wl) : Ne(e, t, n) } this.xr = Ae, this.getContext = function () { return ye }, this.getContextAttributes = function () { return ye.getContextAttributes() }, this.forceContextLoss = function () { const e = Y.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = Y.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return P }, this.setPixelRatio = function (e) { void 0 !== e && (P = e, this.setSize(B, I, !1)) }, this.getSize = function (e) { return e.set(B, I) }, this.setSize = function (e, n, r = !0) { Ae.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (B = e, I = n, t.width = Math.floor(e * P), t.height = Math.floor(n * P), !0 === r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function (e) { return e.set(B * P, I * P).floor() }, this.setDrawingBufferSize = function (e, n, r) { B = e, I = n, P = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function (e) { return e.copy(_) }, this.getViewport = function (e) { return e.copy(k) }, this.setViewport = function (e, t, n, r) { e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, n, r), K.viewport(_.copy(k).multiplyScalar(P).round()) }, this.getScissor = function (e) { return e.copy(N) }, this.setScissor = function (e, t, n, r) { e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, r), K.scissor(E.copy(N).multiplyScalar(P).round()) }, this.getScissorTest = function () { return F }, this.setScissorTest = function (e) { K.setScissorTest(F = e) }, this.setOpaqueSort = function (e) { L = e }, this.setTransparentSort = function (e) { D = e }, this.getClearColor = function (e) { return e.copy(de.getClearColor()) }, this.setClearColor = function () { de.setClearColor.apply(de, arguments) }, this.getClearAlpha = function () { return de.getClearAlpha() }, this.setClearAlpha = function () { de.setClearAlpha.apply(de, arguments) }, this.clear = function (e = !0, t = !0, n = !0) { let r = 0; if (e) { let e = !1; if (null !== S) { const t = S.texture.format; e = t === su || t === au || t === ru } if (e) { const e = S.texture.type, t = e === Fc || e === Gc || e === zc || e === Jc || e === Wc || e === Xc, n = de.getClearColor(), r = de.getClearAlpha(), i = n.r, a = n.g, o = n.b; t ? (h[0] = i, h[1] = a, h[2] = o, h[3] = r, ye.clearBufferuiv(ye.COLOR, 0, h)) : (p[0] = i, p[1] = a, p[2] = o, p[3] = r, ye.clearBufferiv(ye.COLOR, 0, p)) } else r |= ye.COLOR_BUFFER_BIT } t && (r |= ye.DEPTH_BUFFER_BIT, ye.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1)), n && (r |= ye.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ye.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", Se, !1), t.removeEventListener("webglcontextrestored", Me, !1), t.removeEventListener("webglcontextcreationerror", we, !1), se.dispose(), le.dispose(), Z.dispose(), ee.dispose(), te.dispose(), ie.dispose(), ge.dispose(), ve.dispose(), ae.dispose(), Ae.dispose(), Ae.removeEventListener("sessionstart", Te), Ae.removeEventListener("sessionend", Re), Be.stop() }, this.renderBufferDirect = function (e, t, n, r, i, a) { null === t && (t = W); const o = i.isMesh && i.matrixWorld.determinant() < 0, s = function (e, t, n, r, i) { !0 !== t.isScene && (t = W), $.resetTextureUnits(); const a = t.fog, o = r.isMeshStandardMaterial ? t.environment : null, s = null === S ? y.outputColorSpace : !0 === S.isXRRenderTarget ? S.texture.colorSpace : ld, l = (r.isMeshStandardMaterial ? te : ee).get(r.envMap || o), c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize, u = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0), d = !!n.morphAttributes.position, h = !!n.morphAttributes.normal, p = !!n.morphAttributes.color; let f = lc; r.toneMapped && (null !== S && !0 !== S.isXRRenderTarget || (f = y.toneMapping)); const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color, v = void 0 !== g ? g.length : 0, b = Z.get(r), x = m.state.lights; if (!0 === U && (!0 === z || e !== w)) { const t = e === w && r.id === M; ce.setState(r, e, t) } let A = !1; r.version === b.__version ? b.needsLights && b.lightsStateVersion !== x.state.version || b.outputColorSpace !== s || i.isBatchedMesh && !1 === b.batching ? A = !0 : i.isBatchedMesh || !0 !== b.batching ? i.isBatchedMesh && !0 === b.batchingColor && null === i.colorTexture || i.isBatchedMesh && !1 === b.batchingColor && null !== i.colorTexture || i.isInstancedMesh && !1 === b.instancing ? A = !0 : i.isInstancedMesh || !0 !== b.instancing ? i.isSkinnedMesh && !1 === b.skinning ? A = !0 : i.isSkinnedMesh || !0 !== b.skinning ? i.isInstancedMesh && !0 === b.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === b.instancingColor && null !== i.instanceColor || i.isInstancedMesh && !0 === b.instancingMorph && null === i.morphTexture || i.isInstancedMesh && !1 === b.instancingMorph && null !== i.morphTexture || b.envMap !== l || !0 === r.fog && b.fog !== a ? A = !0 : void 0 === b.numClippingPlanes || b.numClippingPlanes === ce.numPlanes && b.numIntersection === ce.numIntersection ? (b.vertexAlphas !== c || b.vertexTangents !== u || b.morphTargets !== d || b.morphNormals !== h || b.morphColors !== p || b.toneMapping !== f || b.morphTargetsCount !== v) && (A = !0) : A = !0 : A = !0 : A = !0 : A = !0 : (A = !0, b.__version = r.version); let _ = b.currentProgram; !0 === A && (_ = Ne(r, t, i)); let E = !1, C = !1, T = !1; const R = _.getUniforms(), B = b.uniforms; if (K.useProgram(_.program) && (E = !0, C = !0, T = !0), r.id !== M && (M = r.id, C = !0), E || w !== e) { Q.reverseDepthBuffer ? (H.copy(e.projectionMatrix), function (e) { const t = e.elements; t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15] }(H), function (e) { const t = e.elements; -1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = 1 - t[14]) }(H), R.setValue(ye, "projectionMatrix", H)) : R.setValue(ye, "projectionMatrix", e.projectionMatrix), R.setValue(ye, "viewMatrix", e.matrixWorldInverse); const t = R.map.cameraPosition; void 0 !== t && t.setValue(ye, j.setFromMatrixPosition(e.matrixWorld)), Q.logarithmicDepthBuffer && R.setValue(ye, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && R.setValue(ye, "isOrthographic", !0 === e.isOrthographicCamera), w !== e && (w = e, C = !0, T = !0) } if (i.isSkinnedMesh) { R.setOptional(ye, i, "bindMatrix"), R.setOptional(ye, i, "bindMatrixInverse"); const e = i.skeleton; e && (null === e.boneTexture && e.computeBoneTexture(), R.setValue(ye, "boneTexture", e.boneTexture, $)) } i.isBatchedMesh && (R.setOptional(ye, i, "batchingTexture"), R.setValue(ye, "batchingTexture", i._matricesTexture, $), R.setOptional(ye, i, "batchingIdTexture"), R.setValue(ye, "batchingIdTexture", i._indirectTexture, $), R.setOptional(ye, i, "batchingColorTexture"), null !== i._colorsTexture && R.setValue(ye, "batchingColorTexture", i._colorsTexture, $)); const L = n.morphAttributes; var D, k; if (void 0 === L.position && void 0 === L.normal && void 0 === L.color || he.update(i, n, _), (C || b.receiveShadow !== i.receiveShadow) && (b.receiveShadow = i.receiveShadow, R.setValue(ye, "receiveShadow", i.receiveShadow)), r.isMeshGouraudMaterial && null !== r.envMap && (B.envMap.value = l, B.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), r.isMeshStandardMaterial && null === r.envMap && null !== t.environment && (B.envMapIntensity.value = t.environmentIntensity), C && (R.setValue(ye, "toneMappingExposure", y.toneMappingExposure), b.needsLights && (k = T, (D = B).ambientLightColor.needsUpdate = k, D.lightProbe.needsUpdate = k, D.directionalLights.needsUpdate = k, D.directionalLightShadows.needsUpdate = k, D.pointLights.needsUpdate = k, D.pointLightShadows.needsUpdate = k, D.spotLights.needsUpdate = k, D.spotLightShadows.needsUpdate = k, D.rectAreaLights.needsUpdate = k, D.hemisphereLights.needsUpdate = k), a && !0 === r.fog && oe.refreshFogUniforms(B, a), oe.refreshMaterialUniforms(B, r, P, I, m.state.transmissionRenderTarget[e.id]), dv.upload(ye, Fe(b), B, $)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (dv.upload(ye, Fe(b), B, $), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && R.setValue(ye, "center", i.center), R.setValue(ye, "modelViewMatrix", i.modelViewMatrix), R.setValue(ye, "normalMatrix", i.normalMatrix), R.setValue(ye, "modelMatrix", i.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial) { const e = r.uniformsGroups; for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; ve.update(n, _), ve.bind(n, _) } } return _ }(e, t, n, r, i); K.setMaterial(r, o); let l = n.index, c = 1; if (!0 === r.wireframe) { if (l = re.getWireframeAttribute(n), void 0 === l) return; c = 2 } const u = n.drawRange, d = n.attributes.position; let h = u.start * c, p = (u.start + u.count) * c; null !== a && (h = Math.max(h, a.start * c), p = Math.min(p, (a.start + a.count) * c)), null !== l ? (h = Math.max(h, 0), p = Math.min(p, l.count)) : null != d && (h = Math.max(h, 0), p = Math.min(p, d.count)); const f = p - h; if (f < 0 || f === 1 / 0) return; let g; ge.setup(i, r, s, n, l); let v = pe; if (null !== l && (g = ne.get(l), v = fe, v.setIndex(g)), i.isMesh) !0 === r.wireframe ? (K.setLineWidth(r.wireframeLinewidth * J()), v.setMode(ye.LINES)) : v.setMode(ye.TRIANGLES); else if (i.isLine) { let e = r.linewidth; void 0 === e && (e = 1), K.setLineWidth(e * J()), i.isLineSegments ? v.setMode(ye.LINES) : i.isLineLoop ? v.setMode(ye.LINE_LOOP) : v.setMode(ye.LINE_STRIP) } else i.isPoints ? v.setMode(ye.POINTS) : i.isSprite && v.setMode(ye.TRIANGLES); if (i.isBatchedMesh) if (null !== i._multiDrawInstances) v.renderMultiDrawInstances(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount, i._multiDrawInstances); else if (Y.get("WEBGL_multi_draw")) v.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount); else { const e = i._multiDrawStarts, t = i._multiDrawCounts, n = i._multiDrawCount, a = l ? ne.get(l).bytesPerElement : 1, o = Z.get(r).currentProgram.getUniforms(); for (let r = 0; r < n; r++)o.setValue(ye, "_gl_DrawID", r), v.render(e[r] / a, t[r]) } else if (i.isInstancedMesh) v.renderInstances(h, f, i.count); else if (n.isInstancedBufferGeometry) { const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0, t = Math.min(n.instanceCount, e); v.renderInstances(h, f, t) } else v.render(h, f) }, this.compile = function (e, t, n = null) { null === n && (n = e), m = le.get(n), m.init(t), v.push(m), n.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), e !== n && e.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), m.setupLights(); const r = new Set; return e.traverse((function (e) { if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return; const t = e.material; if (t) if (Array.isArray(t)) for (let i = 0; i < t.length; i++) { const a = t[i]; Ee(a, n, e), r.add(a) } else Ee(t, n, e), r.add(t) })), v.pop(), m = null, r }, this.compileAsync = function (e, t, n = null) { const r = this.compile(e, t, n); return new Promise((t => { function n() { r.forEach((function (e) { Z.get(e).currentProgram.isReady() && r.delete(e) })), 0 !== r.size ? setTimeout(n, 10) : t(e) } null !== Y.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10) })) }; let Ce = null; function Te() { Be.stop() } function Re() { Be.start() } const Be = new Sm; function Ie(e, t, n, r) { if (!1 === e.visible) return; if (e.layers.test(t.layers)) if (e.isGroup) n = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) m.pushLight(e), e.castShadow && m.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || O.intersectsSprite(e)) { r && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G); const t = ie.update(e), i = e.material; i.visible && f.push(e, t, i, n, V.z, null) } } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || O.intersectsObject(e))) { const t = ie.update(e), i = e.material; if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), V.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), V.copy(t.boundingSphere.center)), V.applyMatrix4(e.matrixWorld).applyMatrix4(G)), Array.isArray(i)) { const r = t.groups; for (let a = 0, o = r.length; a < o; a++) { const o = r[a], s = i[o.materialIndex]; s && s.visible && f.push(e, t, s, n, V.z, o) } } else i.visible && f.push(e, t, i, n, V.z, null) } const i = e.children; for (let e = 0, a = i.length; e < a; e++)Ie(i[e], t, n, r) } function Pe(e, t, n, r) { const i = e.opaque, a = e.transmissive, o = e.transparent; m.setupLightsView(n), !0 === U && ce.setGlobalState(y.clippingPlanes, n), r && K.viewport(_.copy(r)), i.length > 0 && De(i, t, n), a.length > 0 && De(a, t, n), o.length > 0 && De(o, t, n), K.buffers.depth.setTest(!0), K.buffers.depth.setMask(!0), K.buffers.color.setMask(!0), K.setPolygonOffset(!1) } function Le(e, t, n, r) { if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return; void 0 === m.state.transmissionRenderTarget[r.id] && (m.state.transmissionRenderTarget[r.id] = new Nh(1, 1, { generateMipmaps: !0, type: Y.has("EXT_color_buffer_half_float") || Y.has("EXT_color_buffer_float") ? Vc : Fc, minFilter: kc, samples: 4, stencilBuffer: i, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: wh.workingColorSpace })); const a = m.state.transmissionRenderTarget[r.id], o = r.viewport || _; a.setSize(o.z, o.w); const s = y.getRenderTarget(); y.setRenderTarget(a), y.getClearColor(T), R = y.getClearAlpha(), R < 1 && y.setClearColor(16777215, .5), y.clear(), X && de.render(n); const l = y.toneMapping; y.toneMapping = lc; const c = r.viewport; if (void 0 !== r.viewport && (r.viewport = void 0), m.setupLightsView(r), !0 === U && ce.setGlobalState(y.clippingPlanes, r), De(e, n, r), $.updateMultisampleRenderTarget(a), $.updateRenderTargetMipmap(a), !1 === Y.has("WEBGL_multisampled_render_to_texture")) { let e = !1; for (let i = 0, a = t.length; i < a; i++) { const a = t[i], o = a.object, s = a.geometry, l = a.material, c = a.group; if (l.side === wl && o.layers.test(r.layers)) { const t = l.side; l.side = Ml, l.needsUpdate = !0, ke(o, n, r, s, l, c), l.side = t, l.needsUpdate = !0, e = !0 } } !0 === e && ($.updateMultisampleRenderTarget(a), $.updateRenderTargetMipmap(a)) } y.setRenderTarget(s), y.setClearColor(T, R), void 0 !== c && (r.viewport = c), y.toneMapping = l } function De(e, t, n) { const r = !0 === t.isScene ? t.overrideMaterial : null; for (let i = 0, a = e.length; i < a; i++) { const a = e[i], o = a.object, s = a.geometry, l = null === r ? a.material : r, c = a.group; o.layers.test(n.layers) && ke(o, t, n, s, l, c) } } function ke(e, t, n, r, i, a) { e.onBeforeRender(y, t, n, r, i, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(y, t, n, r, e, a), !0 === i.transparent && i.side === wl && !1 === i.forceSinglePass ? (i.side = Ml, i.needsUpdate = !0, y.renderBufferDirect(n, t, r, i, e, a), i.side = Sl, i.needsUpdate = !0, y.renderBufferDirect(n, t, r, i, e, a), i.side = wl) : y.renderBufferDirect(n, t, r, i, e, a), e.onAfterRender(y, t, n, r, i, a) } function Ne(e, t, n) { !0 !== t.isScene && (t = W); const r = Z.get(e), i = m.state.lights, a = m.state.shadowsArray, o = i.state.version, s = ae.getParameters(e, i.state, a, t, n), l = ae.getProgramCacheKey(s); let c = r.programs; r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? te : ee).get(e.envMap || r.environment), r.envMapRotation = null !== r.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === c && (e.addEventListener("dispose", _e), c = new Map, r.programs = c); let u = c.get(l); if (void 0 !== u) { if (r.currentProgram === u && r.lightsStateVersion === o) return Oe(e, s), u } else s.uniforms = ae.getUniforms(e), e.onBeforeCompile(s, y), u = ae.acquireProgram(s, l), c.set(l, u), r.uniforms = s.uniforms; const d = r.uniforms; return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = ce.uniform), Oe(e, s), r.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), r.lightsStateVersion = o, r.needsLights && (d.ambientLightColor.value = i.state.ambient, d.lightProbe.value = i.state.probe, d.directionalLights.value = i.state.directional, d.directionalLightShadows.value = i.state.directionalShadow, d.spotLights.value = i.state.spot, d.spotLightShadows.value = i.state.spotShadow, d.rectAreaLights.value = i.state.rectArea, d.ltc_1.value = i.state.rectAreaLTC1, d.ltc_2.value = i.state.rectAreaLTC2, d.pointLights.value = i.state.point, d.pointLightShadows.value = i.state.pointShadow, d.hemisphereLights.value = i.state.hemi, d.directionalShadowMap.value = i.state.directionalShadowMap, d.directionalShadowMatrix.value = i.state.directionalShadowMatrix, d.spotShadowMap.value = i.state.spotShadowMap, d.spotLightMatrix.value = i.state.spotLightMatrix, d.spotLightMap.value = i.state.spotLightMap, d.pointShadowMap.value = i.state.pointShadowMap, d.pointShadowMatrix.value = i.state.pointShadowMatrix), r.currentProgram = u, r.uniformsList = null, u } function Fe(e) { if (null === e.uniformsList) { const t = e.currentProgram.getUniforms(); e.uniformsList = dv.seqWithValue(t.seq, e.uniforms) } return e.uniformsList } function Oe(e, t) { const n = Z.get(e); n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.batchingColor = t.batchingColor, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping } Be.setAnimationLoop((function (e) { Ce && Ce(e) })), "undefined" != typeof self && Be.setContext(self), this.setAnimationLoop = function (e) { Ce = e, Ae.setAnimationLoop(e), null === e ? Be.stop() : Be.start() }, Ae.addEventListener("sessionstart", Te), Ae.addEventListener("sessionend", Re), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === b) return; if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === Ae.enabled && !0 === Ae.isPresenting && (!0 === Ae.cameraAutoUpdate && Ae.updateCamera(t), t = Ae.getCamera()), !0 === e.isScene && e.onBeforeRender(y, e, t, S), m = le.get(e, v.length), m.init(t), v.push(m), G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), O.setFromProjectionMatrix(G), z = this.localClippingEnabled, U = ce.init(this.clippingPlanes, z), f = se.get(e, g.length), f.init(), g.push(f), !0 === Ae.enabled && !0 === Ae.isPresenting) { const e = y.xr.getDepthSensingMesh(); null !== e && Ie(e, t, -1 / 0, y.sortObjects) } Ie(e, t, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(L, D), X = !1 === Ae.enabled || !1 === Ae.isPresenting || !1 === Ae.hasDepthSensing(), X && de.addToRenderList(f, e), this.info.render.frame++, !0 === U && ce.beginShadows(); const n = m.state.shadowsArray; ue.render(n, e, t), !0 === U && ce.endShadows(), !0 === this.info.autoReset && this.info.reset(); const r = f.opaque, i = f.transmissive; if (m.setupLights(), t.isArrayCamera) { const n = t.cameras; if (i.length > 0) for (let t = 0, a = n.length; t < a; t++)Le(r, i, e, n[t]); X && de.render(e); for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; Pe(f, e, r, r.viewport) } } else i.length > 0 && Le(r, i, e, t), X && de.render(e), Pe(f, e, t); null !== S && ($.updateMultisampleRenderTarget(S), $.updateRenderTargetMipmap(S)), !0 === e.isScene && e.onAfterRender(y, e, t), ge.resetDefaultState(), M = -1, w = null, v.pop(), v.length > 0 ? (m = v[v.length - 1], !0 === U && ce.setGlobalState(y.clippingPlanes, m.state.camera)) : m = null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null }, this.getActiveCubeFace = function () { return x }, this.getActiveMipmapLevel = function () { return A }, this.getRenderTarget = function () { return S }, this.setRenderTargetTextures = function (e, t, n) { Z.get(e.texture).__webglTexture = t, Z.get(e.depthTexture).__webglTexture = n; const r = Z.get(e); r.__hasExternalTextures = !0, r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === Y.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1) }, this.setRenderTargetFramebuffer = function (e, t) { const n = Z.get(e); n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t }, this.setRenderTarget = function (e, t = 0, n = 0) { S = e, x = t, A = n; let r = !0, i = null, a = !1, o = !1; if (e) { const s = Z.get(e); if (void 0 !== s.__useDefaultFramebuffer) K.bindFramebuffer(ye.FRAMEBUFFER, null), r = !1; else if (void 0 === s.__webglFramebuffer) $.setupRenderTarget(e); else if (s.__hasExternalTextures) $.rebindTextures(e, Z.get(e.texture).__webglTexture, Z.get(e.depthTexture).__webglTexture); else if (e.depthBuffer) { const t = e.depthTexture; if (s.__boundDepthTexture !== t) { if (null !== t && Z.has(t) && (e.width !== t.image.width || e.height !== t.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."); $.setupDepthRenderbuffer(e) } } const l = e.texture; (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0); const c = Z.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (i = Array.isArray(c[t]) ? c[t][n] : c[t], a = !0) : i = e.samples > 0 && !1 === $.useMultisampledRTT(e) ? Z.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, _.copy(e.viewport), E.copy(e.scissor), C = e.scissorTest } else _.copy(k).multiplyScalar(P).floor(), E.copy(N).multiplyScalar(P).floor(), C = F; if (K.bindFramebuffer(ye.FRAMEBUFFER, i) && r && K.drawBuffers(e, i), K.viewport(_), K.scissor(E), K.setScissorTest(C), a) { const r = Z.get(e.texture); ye.framebufferTexture2D(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n) } else if (o) { const r = Z.get(e.texture), i = t || 0; ye.framebufferTextureLayer(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i) } M = -1 }, this.readRenderTargetPixels = function (e, t, n, r, i, a, o) { if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let s = Z.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) { K.bindFramebuffer(ye.FRAMEBUFFER, s); try { const o = e.texture, s = o.format, l = o.type; if (!Q.textureFormatReadable(s)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!Q.textureTypeReadable(l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ye.readPixels(t, n, r, i, me.convert(s), me.convert(l), a) } finally { const e = null !== S ? Z.get(S).__webglFramebuffer : null; K.bindFramebuffer(ye.FRAMEBUFFER, e) } } }, this.readRenderTargetPixelsAsync = async function (e, t, n, r, i, a, o) { if (!e || !e.isWebGLRenderTarget) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let s = Z.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) { const o = e.texture, l = o.format, c = o.type; if (!Q.textureFormatReadable(l)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."); if (!Q.textureTypeReadable(c)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."); if (t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i) { K.bindFramebuffer(ye.FRAMEBUFFER, s); const e = ye.createBuffer(); ye.bindBuffer(ye.PIXEL_PACK_BUFFER, e), ye.bufferData(ye.PIXEL_PACK_BUFFER, a.byteLength, ye.STREAM_READ), ye.readPixels(t, n, r, i, me.convert(l), me.convert(c), 0); const o = null !== S ? Z.get(S).__webglFramebuffer : null; K.bindFramebuffer(ye.FRAMEBUFFER, o); const u = ye.fenceSync(ye.SYNC_GPU_COMMANDS_COMPLETE, 0); return ye.flush(), await function (e, t) { return new Promise((function (n, r) { setTimeout((function i() { switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) { case e.WAIT_FAILED: r(); break; case e.TIMEOUT_EXPIRED: setTimeout(i, 4); break; default: n() } }), 4) })) }(ye, u), ye.bindBuffer(ye.PIXEL_PACK_BUFFER, e), ye.getBufferSubData(ye.PIXEL_PACK_BUFFER, 0, a), ye.deleteBuffer(e), ye.deleteSync(u), a } throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.") } }, this.copyFramebufferToTexture = function (e, t = null, n = 0) { !0 !== e.isTexture && (bh("WebGLRenderer: copyFramebufferToTexture function signature has changed."), t = arguments[0] || null, e = arguments[1]); const r = Math.pow(2, -n), i = Math.floor(e.image.width * r), a = Math.floor(e.image.height * r), o = null !== t ? t.x : 0, s = null !== t ? t.y : 0; $.setTexture2D(e, 0), ye.copyTexSubImage2D(ye.TEXTURE_2D, n, 0, 0, o, s, i, a), K.unbindTexture() }, this.copyTextureToTexture = function (e, t, n = null, r = null, i = 0) { let a, o, s, l, c, u; !0 !== e.isTexture && (bh("WebGLRenderer: copyTextureToTexture function signature has changed."), r = arguments[0] || null, e = arguments[1], t = arguments[2], i = arguments[3] || 0, n = null), null !== n ? (a = n.max.x - n.min.x, o = n.max.y - n.min.y, s = n.min.x, l = n.min.y) : (a = e.image.width, o = e.image.height, s = 0, l = 0), null !== r ? (c = r.x, u = r.y) : (c = 0, u = 0); const d = me.convert(t.format), h = me.convert(t.type); $.setTexture2D(t, 0), ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL, t.flipY), ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), ye.pixelStorei(ye.UNPACK_ALIGNMENT, t.unpackAlignment); const p = ye.getParameter(ye.UNPACK_ROW_LENGTH), f = ye.getParameter(ye.UNPACK_IMAGE_HEIGHT), m = ye.getParameter(ye.UNPACK_SKIP_PIXELS), g = ye.getParameter(ye.UNPACK_SKIP_ROWS), v = ye.getParameter(ye.UNPACK_SKIP_IMAGES), y = e.isCompressedTexture ? e.mipmaps[i] : e.image; ye.pixelStorei(ye.UNPACK_ROW_LENGTH, y.width), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, y.height), ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, s), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, l), e.isDataTexture ? ye.texSubImage2D(ye.TEXTURE_2D, i, c, u, a, o, d, h, y.data) : e.isCompressedTexture ? ye.compressedTexSubImage2D(ye.TEXTURE_2D, i, c, u, y.width, y.height, d, y.data) : ye.texSubImage2D(ye.TEXTURE_2D, i, c, u, a, o, d, h, y), ye.pixelStorei(ye.UNPACK_ROW_LENGTH, p), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, f), ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, m), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, g), ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, v), 0 === i && t.generateMipmaps && ye.generateMipmap(ye.TEXTURE_2D), K.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, n = null, r = null, i = 0) { let a, o, s, l, c, u, d, h, p; !0 !== e.isTexture && (bh("WebGLRenderer: copyTextureToTexture3D function signature has changed."), n = arguments[0] || null, r = arguments[1] || null, e = arguments[2], t = arguments[3], i = arguments[4] || 0); const f = e.isCompressedTexture ? e.mipmaps[i] : e.image; null !== n ? (a = n.max.x - n.min.x, o = n.max.y - n.min.y, s = n.max.z - n.min.z, l = n.min.x, c = n.min.y, u = n.min.z) : (a = f.width, o = f.height, s = f.depth, l = 0, c = 0, u = 0), null !== r ? (d = r.x, h = r.y, p = r.z) : (d = 0, h = 0, p = 0); const m = me.convert(t.format), g = me.convert(t.type); let v; if (t.isData3DTexture) $.setTexture3D(t, 0), v = ye.TEXTURE_3D; else { if (!t.isDataArrayTexture && !t.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); $.setTexture2DArray(t, 0), v = ye.TEXTURE_2D_ARRAY } ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL, t.flipY), ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), ye.pixelStorei(ye.UNPACK_ALIGNMENT, t.unpackAlignment); const y = ye.getParameter(ye.UNPACK_ROW_LENGTH), b = ye.getParameter(ye.UNPACK_IMAGE_HEIGHT), x = ye.getParameter(ye.UNPACK_SKIP_PIXELS), A = ye.getParameter(ye.UNPACK_SKIP_ROWS), S = ye.getParameter(ye.UNPACK_SKIP_IMAGES); ye.pixelStorei(ye.UNPACK_ROW_LENGTH, f.width), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, f.height), ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, l), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, c), ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, u), e.isDataTexture || e.isData3DTexture ? ye.texSubImage3D(v, i, d, h, p, a, o, s, m, g, f.data) : t.isCompressedArrayTexture ? ye.compressedTexSubImage3D(v, i, d, h, p, a, o, s, m, f.data) : ye.texSubImage3D(v, i, d, h, p, a, o, s, m, g, f), ye.pixelStorei(ye.UNPACK_ROW_LENGTH, y), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, b), ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, x), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, A), ye.pixelStorei(ye.UNPACK_SKIP_IMAGES, S), 0 === i && t.generateMipmaps && ye.generateMipmap(v), K.unbindTexture() }, this.initRenderTarget = function (e) { void 0 === Z.get(e).__webglFramebuffer && $.setupRenderTarget(e) }, this.initTexture = function (e) { e.isCubeTexture ? $.setTextureCube(e, 0) : e.isData3DTexture ? $.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? $.setTexture2DArray(e, 0) : $.setTexture2D(e, 0), K.unbindTexture() }, this.resetState = function () { x = 0, A = 0, S = null, K.reset(), ge.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return Kd } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; const t = this.getContext(); t.drawingBufferColorSpace = e === cd ? "display-p3" : "srgb", t.unpackColorSpace = wh.workingColorSpace === ud ? "display-p3" : "srgb" } } class dy { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new df(e), this.density = t } clone() { return new dy(this.color, this.density) } toJSON() { return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density } } } class hy { constructor(e, t = 1, n = 1e3) { this.isFog = !0, this.name = "", this.color = new df(e), this.near = t, this.far = n } clone() { return new hy(this.color, this.near, this.far) } toJSON() { return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far } } } class py extends Wp { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Tp, this.environmentIntensity = 1, this.environmentRotation = new Tp, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t } } class fy { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Ud, this.updateRanges = [], this.version = 0, this.uuid = rh() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.stride, n *= t.stride; for (let r = 0, i = this.stride; r < i; r++)this.array[e + r] = t.array[n + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = rh()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = rh()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const my = new Gh; class gy { constructor(e, t, n, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, n = this.data.count; t < n; t++)my.fromBufferAttribute(this, t), my.applyMatrix4(e), this.setXYZ(t, my.x, my.y, my.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)my.fromBufferAttribute(this, t), my.applyNormalMatrix(e), this.setXYZ(t, my.x, my.y, my.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)my.fromBufferAttribute(this, t), my.transformDirection(e), this.setXYZ(t, my.x, my.y, my.z); return this } getComponent(e, t) { let n = this.array[e * this.data.stride + this.offset + t]; return this.normalized && (n = sh(n, this.array)), n } setComponent(e, t, n) { return this.normalized && (n = lh(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this } setX(e, t) { return this.normalized && (t = lh(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = lh(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = lh(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = lh(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = sh(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = sh(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = sh(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = sh(t, this.array)), t } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.normalized && (t = lh(t, this.array), n = lh(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = lh(t, this.array), n = lh(n, this.array), r = lh(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this } setXYZW(e, t, n, r, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = lh(t, this.array), n = lh(n, this.array), r = lh(r, this.array), i = lh(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this } clone(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return new Mf(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new gy(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class vy extends ff { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new df(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let yy; const by = new Gh, xy = new Gh, Ay = new Gh, Sy = new uh, My = new uh, wy = new yp, _y = new Gh, Ey = new Gh, Cy = new Gh, Ty = new uh, Ry = new uh, By = new uh; class Iy extends Wp { constructor(e = new vy) { if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === yy) { yy = new zf; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new fy(e, 5); yy.setIndex([0, 1, 2, 0, 2, 3]), yy.setAttribute("position", new gy(t, 3, 0, !1)), yy.setAttribute("uv", new gy(t, 2, 3, !1)) } this.geometry = yy, this.material = e, this.center = new uh(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), xy.setFromMatrixScale(this.matrixWorld), wy.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Ay.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && xy.multiplyScalar(-Ay.z); const n = this.material.rotation; let r, i; 0 !== n && (i = Math.cos(n), r = Math.sin(n)); const a = this.center; Py(_y.set(-.5, -.5, 0), Ay, a, xy, r, i), Py(Ey.set(.5, -.5, 0), Ay, a, xy, r, i), Py(Cy.set(.5, .5, 0), Ay, a, xy, r, i), Ty.set(0, 0), Ry.set(1, 0), By.set(1, 1); let o = e.ray.intersectTriangle(_y, Ey, Cy, !1, by); if (null === o && (Py(Ey.set(-.5, .5, 0), Ay, a, xy, r, i), Ry.set(0, 1), o = e.ray.intersectTriangle(_y, Cy, Ey, !1, by), null === o)) return; const s = e.ray.origin.distanceTo(by); s < e.near || s > e.far || t.push({ distance: s, point: by.clone(), uv: of.getInterpolation(by, _y, Ey, Cy, Ty, Ry, By, new uh), face: null, object: this }) } copy(e, t) { return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function Py(e, t, n, r, i, a) { Sy.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (My.x = a * Sy.x - i * Sy.y, My.y = i * Sy.x + a * Sy.y) : My.copy(Sy), e.copy(t), e.x += My.x, e.y += My.y, e.applyMatrix4(wy) } const Ly = new Gh, Dy = new Gh; class ky extends Wp { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; this.addLevel(n.object.clone(), n.distance, n.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, n = 0) { t = Math.abs(t); const r = this.levels; let i; for (i = 0; i < r.length && !(t < r[i].distance); i++); return r.splice(i, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this } removeLevel(e) { const t = this.levels; for (let n = 0; n < t.length; n++)if (t[n].distance === e) { const e = t.splice(n, 1); return this.remove(e[0].object), !0 } return !1 } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let n, r; for (n = 1, r = t.length; n < r; n++) { let r = t[n].distance; if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r) break } return t[n - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { Ly.setFromMatrixPosition(this.matrixWorld); const n = e.ray.origin.distanceTo(Ly); this.getObjectForDistance(n).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { Ly.setFromMatrixPosition(e.matrixWorld), Dy.setFromMatrixPosition(this.matrixWorld); const n = Ly.distanceTo(Dy) / e.zoom; let r, i; for (t[0].object.visible = !0, r = 1, i = t.length; r < i; r++) { let e = t[r].distance; if (t[r].object.visible && (e -= e * t[r].hysteresis), !(n >= e)) break; t[r - 1].object.visible = !1, t[r].object.visible = !0 } for (this._currentLevel = r - 1; r < i; r++)t[r].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = []; const n = this.levels; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; t.object.levels.push({ object: r.object.uuid, distance: r.distance, hysteresis: r.hysteresis }) } return t } } const Ny = new Gh, Fy = new Dh, Oy = new Dh, Uy = new Gh, zy = new yp, Hy = new Gh, Gy = new cp, jy = new yp, Vy = new vp; class Wy extends Zf { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = gc, this.bindMatrix = new yp, this.bindMatrixInverse = new yp, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; null === this.boundingBox && (this.boundingBox = new Wh), this.boundingBox.makeEmpty(); const t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, Hy), this.boundingBox.expandByPoint(Hy) } computeBoundingSphere() { const e = this.geometry; null === this.boundingSphere && (this.boundingSphere = new cp), this.boundingSphere.makeEmpty(); const t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, Hy), this.boundingSphere.expandByPoint(Hy) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { const n = this.material, r = this.matrixWorld; void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Gy.copy(this.boundingSphere), Gy.applyMatrix4(r), !1 !== e.ray.intersectsSphere(Gy) && (jy.copy(r).invert(), Vy.copy(e.ray).applyMatrix4(jy), null !== this.boundingBox && !1 === Vy.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Vy))) } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Dh, t = this.geometry.attributes.skinWeight; for (let n = 0, r = t.count; n < r; n++) { e.fromBufferAttribute(t, n); const r = 1 / e.manhattanLength(); r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === gc ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === vc ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, t) { const n = this.skeleton, r = this.geometry; Fy.fromBufferAttribute(r.attributes.skinIndex, e), Oy.fromBufferAttribute(r.attributes.skinWeight, e), Ny.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const r = Oy.getComponent(e); if (0 !== r) { const i = Fy.getComponent(e); zy.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(Uy.copy(Ny).applyMatrix4(zy), r) } } return t.applyMatrix4(this.bindMatrixInverse) } } class Xy extends Wp { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class Jy extends Lh { constructor(e = null, t = 1, n = 1, r, i, a, o, s, l = Cc, c = Cc, u, d) { super(null, a, o, s, l, c, r, i, u, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const Yy = new yp, Qy = new yp; class Ky { constructor(e = [], t = []) { this.uuid = rh(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new yp) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new yp; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture; for (let r = 0, i = e.length; r < i; r++) { const i = e[r] ? e[r].matrixWorld : Qy; Yy.multiplyMatrices(i, t[r]), Yy.toArray(n, 16 * r) } null !== r && (r.needsUpdate = !0) } clone() { return new Ky(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length); e = 4 * Math.ceil(e / 4), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const n = new Jy(t, e, e, qc, jc); return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this } getBoneByName(e) { for (let t = 0, n = this.bones.length; t < n; t++) { const n = this.bones[t]; if (n.name === e) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let n = 0, r = e.bones.length; n < r; n++) { const r = e.bones[n]; let i = t[r]; void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Xy), this.bones.push(i), this.boneInverses.push((new yp).fromArray(e.boneInverses[n])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for (let r = 0, i = t.length; r < i; r++) { const i = t[r]; e.bones.push(i.uuid); const a = n[r]; e.boneInverses.push(a.toArray()) } return e } } class qy extends Mf { constructor(e, t, n, r = 1) { super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const Zy = new yp, $y = new yp, eb = [], tb = new Wh, nb = new yp, rb = new Zf, ib = new cp; class ab extends Zf { constructor(e, t, n) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new qy(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null; for (let e = 0; e < n; e++)this.setMatrixAt(e, nb) } computeBoundingBox() { const e = this.geometry, t = this.count; null === this.boundingBox && (this.boundingBox = new Wh), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let n = 0; n < t; n++)this.getMatrixAt(n, Zy), tb.copy(e.boundingBox).applyMatrix4(Zy), this.boundingBox.union(tb) } computeBoundingSphere() { const e = this.geometry, t = this.count; null === this.boundingSphere && (this.boundingSphere = new cp), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let n = 0; n < t; n++)this.getMatrixAt(n, Zy), ib.copy(e.boundingSphere).applyMatrix4(Zy), this.boundingSphere.union(ib) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } getMorphAt(e, t) { const n = t.morphTargetInfluences, r = this.morphTexture.source.data.data, i = e * (n.length + 1) + 1; for (let e = 0; e < n.length; e++)n[e] = r[i + e] } raycast(e, t) { const n = this.matrixWorld, r = this.count; if (rb.geometry = this.geometry, rb.material = this.material, void 0 !== rb.material && (null === this.boundingSphere && this.computeBoundingSphere(), ib.copy(this.boundingSphere), ib.applyMatrix4(n), !1 !== e.ray.intersectsSphere(ib))) for (let i = 0; i < r; i++) { this.getMatrixAt(i, Zy), $y.multiplyMatrices(n, Zy), rb.matrixWorld = $y, rb.raycast(e, eb); for (let e = 0, n = eb.length; e < n; e++) { const n = eb[e]; n.instanceId = i, n.object = this, t.push(n) } eb.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new qy(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } setMorphAt(e, t) { const n = t.morphTargetInfluences, r = n.length + 1; null === this.morphTexture && (this.morphTexture = new Jy(new Float32Array(r * this.count), r, this.count, nu, jc)); const i = this.morphTexture.source.data.data; let a = 0; for (let e = 0; e < n.length; e++)a += n[e]; const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, s = r * e; i[s] = o, i.set(n, s + 1) } updateMorphTargets() { } dispose() { return this.dispatchEvent({ type: "dispose" }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this } } function ob(e, t) { return e.z - t.z } function sb(e, t) { return t.z - e.z } class lb { constructor() { this.index = 0, this.pool = [], this.list = [] } push(e, t, n) { const r = this.pool, i = this.list; this.index >= r.length && r.push({ start: -1, count: -1, z: -1, index: -1 }); const a = r[this.index]; i.push(a), this.index++, a.start = e.start, a.count = e.count, a.z = t, a.index = n } reset() { this.list.length = 0, this.index = 0 } } const cb = new yp, ub = new yp, db = new yp, hb = new df(1, 1, 1), pb = new yp, fb = new Am, mb = new Wh, gb = new cp, vb = new Gh, yb = new Gh, bb = new Gh, xb = new lb, Ab = new Zf, Sb = []; function Mb(e, t, n = 0) { const r = t.itemSize; if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) { const i = e.count; for (let a = 0; a < i; a++)for (let i = 0; i < r; i++)t.setComponent(a + n, i, e.getComponent(a, i)) } else t.array.set(e.array, n * r); t.needsUpdate = !0 } class wb extends Zf { get maxInstanceCount() { return this._maxInstanceCount } constructor(e, t, n = 2 * t, r) { super(new zf, r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawInfo = [], this._availableInstanceIds = [], this._drawRanges = [], this._reservedRanges = [], this._bounds = [], this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture() } _initMatricesTexture() { let e = Math.sqrt(4 * this._maxInstanceCount); e = 4 * Math.ceil(e / 4), e = Math.max(e, 4); const t = new Float32Array(e * e * 4), n = new Jy(t, e, e, qc, jc); this._matricesTexture = n } _initIndirectTexture() { let e = Math.sqrt(this._maxInstanceCount); e = Math.ceil(e); const t = new Uint32Array(e * e), n = new Jy(t, e, e, ru, Gc); this._indirectTexture = n } _initColorsTexture() { let e = Math.sqrt(this._maxInstanceCount); e = Math.ceil(e); const t = new Float32Array(e * e * 4).fill(1), n = new Jy(t, e, e, qc, jc); n.colorSpace = wh.workingColorSpace, this._colorsTexture = n } _initializeGeometry(e) { const t = this.geometry, n = this._maxVertexCount, r = this._maxIndexCount; if (!1 === this._geometryInitialized) { for (const r in e.attributes) { const i = e.getAttribute(r), { array: a, itemSize: o, normalized: s } = i, l = new a.constructor(n * o), c = new Mf(l, o, s); t.setAttribute(r, c) } if (null !== e.getIndex()) { const e = n > 65535 ? new Uint32Array(r) : new Uint16Array(r); t.setIndex(new Mf(e, 1)) } this._geometryInitialized = !0 } } _validateGeometry(e) { const t = this.geometry; if (Boolean(e.getIndex()) !== Boolean(t.getIndex())) throw new Error('BatchedMesh: All geometries must consistently have "index".'); for (const n in t.attributes) { if (!e.hasAttribute(n)) throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`); const r = e.getAttribute(n), i = t.getAttribute(n); if (r.itemSize !== i.itemSize || r.normalized !== i.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.") } } setCustomSort(e) { return this.customSort = e, this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new Wh); const e = this.boundingBox, t = this._drawInfo; e.makeEmpty(); for (let n = 0, r = t.length; n < r; n++) { if (!1 === t[n].active) continue; const r = t[n].geometryIndex; this.getMatrixAt(n, cb), this.getBoundingBoxAt(r, mb).applyMatrix4(cb), e.union(mb) } } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new cp); const e = this.boundingSphere, t = this._drawInfo; e.makeEmpty(); for (let n = 0, r = t.length; n < r; n++) { if (!1 === t[n].active) continue; const r = t[n].geometryIndex; this.getMatrixAt(n, cb), this.getBoundingSphereAt(r, gb).applyMatrix4(cb), e.union(gb) } } addInstance(e) { if (this._drawInfo.length >= this.maxInstanceCount && 0 === this._availableInstanceIds.length) throw new Error("BatchedMesh: Maximum item count reached."); const t = { visible: !0, active: !0, geometryIndex: e }; let n = null; this._availableInstanceIds.length > 0 ? (n = this._availableInstanceIds.pop(), this._drawInfo[n] = t) : (n = this._drawInfo.length, this._drawInfo.push(t)); const r = this._matricesTexture, i = r.image.data; db.toArray(i, 16 * n), r.needsUpdate = !0; const a = this._colorsTexture; return a && (hb.toArray(a.image.data, 4 * n), a.needsUpdate = !0), n } addGeometry(e, t = -1, n = -1) { if (this._initializeGeometry(e), this._validateGeometry(e), this._drawInfo.length >= this._maxInstanceCount) throw new Error("BatchedMesh: Maximum item count reached."); const r = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 }; let i = null; const a = this._reservedRanges, o = this._drawRanges, s = this._bounds; 0 !== this._geometryCount && (i = a[a.length - 1]), r.vertexCount = -1 === t ? e.getAttribute("position").count : t, r.vertexStart = null === i ? 0 : i.vertexStart + i.vertexCount; const l = e.getIndex(), c = null !== l; if (c && (r.indexCount = -1 === n ? l.count : n, r.indexStart = null === i ? 0 : i.indexStart + i.indexCount), -1 !== r.indexStart && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size."); const u = this._geometryCount; return this._geometryCount++, a.push(r), o.push({ start: c ? r.indexStart : r.vertexStart, count: -1 }), s.push({ boxInitialized: !1, box: new Wh, sphereInitialized: !1, sphere: new cp }), this.setGeometryAt(u, e), u } setGeometryAt(e, t) { if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached."); this._validateGeometry(t); const n = this.geometry, r = null !== n.getIndex(), i = n.getIndex(), a = t.getIndex(), o = this._reservedRanges[e]; if (r && a.count > o.indexCount || t.attributes.position.count > o.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry."); const s = o.vertexStart, l = o.vertexCount; for (const e in n.attributes) { const r = t.getAttribute(e), i = n.getAttribute(e); Mb(r, i, s); const a = r.itemSize; for (let e = r.count, t = l; e < t; e++) { const t = s + e; for (let e = 0; e < a; e++)i.setComponent(t, e, 0) } i.needsUpdate = !0, i.addUpdateRange(s * a, l * a) } if (r) { const e = o.indexStart; for (let t = 0; t < a.count; t++)i.setX(e + t, s + a.getX(t)); for (let t = a.count, n = o.indexCount; t < n; t++)i.setX(e + t, s); i.needsUpdate = !0, i.addUpdateRange(e, o.indexCount) } const c = this._bounds[e]; null !== t.boundingBox ? (c.box.copy(t.boundingBox), c.boxInitialized = !0) : c.boxInitialized = !1, null !== t.boundingSphere ? (c.sphere.copy(t.boundingSphere), c.sphereInitialized = !0) : c.sphereInitialized = !1; const u = this._drawRanges[e], d = t.getAttribute("position"); return u.count = r ? a.count : d.count, this._visibilityChanged = !0, e } deleteInstance(e) { const t = this._drawInfo; return e >= t.length || !1 === t[e].active || (t[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0), this } getBoundingBoxAt(e, t) { if (e >= this._geometryCount) return null; const n = this._bounds[e], r = n.box, i = this.geometry; if (!1 === n.boxInitialized) { r.makeEmpty(); const t = i.index, a = i.attributes.position, o = this._drawRanges[e]; for (let e = o.start, n = o.start + o.count; e < n; e++) { let n = e; t && (n = t.getX(n)), r.expandByPoint(vb.fromBufferAttribute(a, n)) } n.boxInitialized = !0 } return t.copy(r), t } getBoundingSphereAt(e, t) { if (e >= this._geometryCount) return null; const n = this._bounds[e], r = n.sphere, i = this.geometry; if (!1 === n.sphereInitialized) { r.makeEmpty(), this.getBoundingBoxAt(e, mb), mb.getCenter(r.center); const t = i.index, a = i.attributes.position, o = this._drawRanges[e]; let s = 0; for (let e = o.start, n = o.start + o.count; e < n; e++) { let n = e; t && (n = t.getX(n)), vb.fromBufferAttribute(a, n), s = Math.max(s, r.center.distanceToSquared(vb)) } r.radius = Math.sqrt(s), n.sphereInitialized = !0 } return t.copy(r), t } setMatrixAt(e, t) { const n = this._drawInfo, r = this._matricesTexture, i = this._matricesTexture.image.data; return e >= n.length || !1 === n[e].active || (t.toArray(i, 16 * e), r.needsUpdate = !0), this } getMatrixAt(e, t) { const n = this._drawInfo, r = this._matricesTexture.image.data; return e >= n.length || !1 === n[e].active ? null : t.fromArray(r, 16 * e) } setColorAt(e, t) { null === this._colorsTexture && this._initColorsTexture(); const n = this._colorsTexture, r = this._colorsTexture.image.data, i = this._drawInfo; return e >= i.length || !1 === i[e].active || (t.toArray(r, 4 * e), n.needsUpdate = !0), this } getColorAt(e, t) { const n = this._colorsTexture.image.data, r = this._drawInfo; return e >= r.length || !1 === r[e].active ? null : t.fromArray(n, 4 * e) } setVisibleAt(e, t) { const n = this._drawInfo; return e >= n.length || !1 === n[e].active || n[e].visible === t || (n[e].visible = t, this._visibilityChanged = !0), this } getVisibleAt(e) { const t = this._drawInfo; return !(e >= t.length || !1 === t[e].active) && t[e].visible } setGeometryIdAt(e, t) { const n = this._drawInfo; return e >= n.length || !1 === n[e].active || t < 0 || t >= this._geometryCount ? null : (n[e].geometryIndex = t, this) } getGeometryIdAt(e) { const t = this._drawInfo; return e >= t.length || !1 === t[e].active ? -1 : t[e].geometryIndex } getGeometryRangeAt(e, t = {}) { if (e < 0 || e >= this._geometryCount) return null; const n = this._drawRanges[e]; return t.start = n.start, t.count = n.count, t } raycast(e, t) { const n = this._drawInfo, r = this._drawRanges, i = this.matrixWorld, a = this.geometry; Ab.material = this.material, Ab.geometry.index = a.index, Ab.geometry.attributes = a.attributes, null === Ab.geometry.boundingBox && (Ab.geometry.boundingBox = new Wh), null === Ab.geometry.boundingSphere && (Ab.geometry.boundingSphere = new cp); for (let a = 0, o = n.length; a < o; a++) { if (!n[a].visible || !n[a].active) continue; const o = n[a].geometryIndex, s = r[o]; Ab.geometry.setDrawRange(s.start, s.count), this.getMatrixAt(a, Ab.matrixWorld).premultiply(i), this.getBoundingBoxAt(o, Ab.geometry.boundingBox), this.getBoundingSphereAt(o, Ab.geometry.boundingSphere), Ab.raycast(e, Sb); for (let e = 0, n = Sb.length; e < n; e++) { const n = Sb[e]; n.object = this, n.batchId = a, t.push(n) } Sb.length = 0 } Ab.material = null, Ab.geometry.index = null, Ab.geometry.attributes = {}, Ab.geometry.setDrawRange(0, 1 / 0) } copy(e) { return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = null !== e.boundingBox ? e.boundingBox.clone() : null, this.boundingSphere = null !== e.boundingSphere ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((e => ({ ...e }))), this._reservedRanges = e._reservedRanges.map((e => ({ ...e }))), this._drawInfo = e._drawInfo.map((e => ({ ...e }))), this._bounds = e._bounds.map((e => ({ boxInitialized: e.boxInitialized, box: e.box.clone(), sphereInitialized: e.sphereInitialized, sphere: e.sphere.clone() }))), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), null !== this._colorsTexture && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this } dispose() { return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, null !== this._colorsTexture && (this._colorsTexture.dispose(), this._colorsTexture = null), this } onBeforeRender(e, t, n, r, i) { if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return; const a = r.getIndex(), o = null === a ? 1 : a.array.BYTES_PER_ELEMENT, s = this._drawInfo, l = this._multiDrawStarts, c = this._multiDrawCounts, u = this._drawRanges, d = this.perObjectFrustumCulled, h = this._indirectTexture, p = h.image.data; d && (pb.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), fb.setFromProjectionMatrix(pb, e.coordinateSystem)); let f = 0; if (this.sortObjects) { ub.copy(this.matrixWorld).invert(), vb.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ub), yb.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(ub); for (let e = 0, t = s.length; e < t; e++)if (s[e].visible && s[e].active) { const t = s[e].geometryIndex; this.getMatrixAt(e, cb), this.getBoundingSphereAt(t, gb).applyMatrix4(cb); let n = !1; if (d && (n = !fb.intersectsSphere(gb)), !n) { const n = bb.subVectors(gb.center, vb).dot(yb); xb.push(u[t], n, e) } } const e = xb.list, t = this.customSort; null === t ? e.sort(i.transparent ? sb : ob) : t.call(this, e, n); for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; l[f] = n.start * o, c[f] = n.count, p[f] = n.index, f++ } xb.reset() } else for (let e = 0, t = s.length; e < t; e++)if (s[e].visible && s[e].active) { const t = s[e].geometryIndex; let n = !1; if (d && (this.getMatrixAt(e, cb), this.getBoundingSphereAt(t, gb).applyMatrix4(cb), n = !fb.intersectsSphere(gb)), !n) { const n = u[t]; l[f] = n.start * o, c[f] = n.count, p[f] = e, f++ } } h.needsUpdate = !0, this._multiDrawCount = f, this._visibilityChanged = !1 } onBeforeShadow(e, t, n, r, i, a) { this.onBeforeRender(e, null, r, i, a) } } class _b extends ff { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new df(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const Eb = new Gh, Cb = new Gh, Tb = new yp, Rb = new vp, Bb = new cp, Ib = new Gh, Pb = new Gh; class Lb extends Wp { constructor(e = new zf, t = new _b) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (null === e.index) { const t = e.attributes.position, n = [0]; for (let e = 1, r = t.count; e < r; e++)Eb.fromBufferAttribute(t, e - 1), Cb.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += Eb.distanceTo(Cb); e.setAttribute("lineDistance", new Pf(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const n = this.geometry, r = this.matrixWorld, i = e.params.Line.threshold, a = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), Bb.copy(n.boundingSphere), Bb.applyMatrix4(r), Bb.radius += i, !1 === e.ray.intersectsSphere(Bb)) return; Tb.copy(r).invert(), Rb.copy(e.ray).applyMatrix4(Tb); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, l = this.isLineSegments ? 2 : 1, c = n.index, u = n.attributes.position; if (null !== c) { const n = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); for (let i = n, a = r - 1; i < a; i += l) { const n = c.getX(i), r = c.getX(i + 1), a = Db(this, e, Rb, s, n, r); a && t.push(a) } if (this.isLineLoop) { const i = c.getX(r - 1), a = c.getX(n), o = Db(this, e, Rb, s, i, a); o && t.push(o) } } else { const n = Math.max(0, a.start), r = Math.min(u.count, a.start + a.count); for (let i = n, a = r - 1; i < a; i += l) { const n = Db(this, e, Rb, s, i, i + 1); n && t.push(n) } if (this.isLineLoop) { const i = Db(this, e, Rb, s, r - 1, n); i && t.push(i) } } } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { const t = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function Db(e, t, n, r, i, a) { const o = e.geometry.attributes.position; if (Eb.fromBufferAttribute(o, i), Cb.fromBufferAttribute(o, a), n.distanceSqToSegment(Eb, Cb, Ib, Pb) > r) return; Ib.applyMatrix4(e.matrixWorld); const s = t.ray.origin.distanceTo(Ib); return s < t.near || s > t.far ? void 0 : { distance: s, point: Pb.clone().applyMatrix4(e.matrixWorld), index: i, face: null, faceIndex: null, barycoord: null, object: e } } const kb = new Gh, Nb = new Gh; class Fb extends Lb { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (null === e.index) { const t = e.attributes.position, n = []; for (let e = 0, r = t.count; e < r; e += 2)kb.fromBufferAttribute(t, e), Nb.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + kb.distanceTo(Nb); e.setAttribute("lineDistance", new Pf(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class Ob extends Lb { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class Ub extends ff { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new df(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const zb = new yp, Hb = new vp, Gb = new cp, jb = new Gh; class Vb extends Wp { constructor(e = new zf, t = new Ub) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, t) { const n = this.geometry, r = this.matrixWorld, i = e.params.Points.threshold, a = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), Gb.copy(n.boundingSphere), Gb.applyMatrix4(r), Gb.radius += i, !1 === e.ray.intersectsSphere(Gb)) return; zb.copy(r).invert(), Hb.copy(e.ray).applyMatrix4(zb); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, l = n.index, c = n.attributes.position; if (null !== l) for (let n = Math.max(0, a.start), i = Math.min(l.count, a.start + a.count); n < i; n++) { const i = l.getX(n); jb.fromBufferAttribute(c, i), Wb(jb, i, s, r, e, t, this) } else for (let n = Math.max(0, a.start), i = Math.min(c.count, a.start + a.count); n < i; n++)jb.fromBufferAttribute(c, n), Wb(jb, n, s, r, e, t, this) } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const n = e[t[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++) { const t = n[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function Wb(e, t, n, r, i, a, o) { const s = Hb.distanceSqToPoint(e); if (s < n) { const n = new Gh; Hb.closestPointToPoint(e, n), n.applyMatrix4(r); const l = i.ray.origin.distanceTo(n); if (l < i.near || l > i.far) return; a.push({ distance: l, distanceToRay: Math.sqrt(s), point: n, index: t, face: null, faceIndex: null, barycoord: null, object: o }) } } class Xb extends Lh { constructor(e, t, n, r, i, a, o, s, l) { super(e, t, n, r, i, a, o, s, l), this.isVideoTexture = !0, this.minFilter = void 0 !== a ? a : Pc, this.magFilter = void 0 !== i ? i : Pc, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() { c.needsUpdate = !0, e.requestVideoFrameCallback(t) })) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class Jb extends Lh { constructor(e, t) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Cc, this.minFilter = Cc, this.generateMipmaps = !1, this.needsUpdate = !0 } } class Yb extends Lh { constructor(e, t, n, r, i, a, o, s, l, c, u, d) { super(null, a, o, s, l, c, r, i, u, d), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class Qb extends Yb { constructor(e, t, n, r, i, a) { super(e, t, n, i, a), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = _c, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class Kb extends Yb { constructor(e, t, n) { super(void 0, e[0].width, e[0].height, t, n, bc), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class qb extends Lh { constructor(e, t, n, r, i, a, o, s, l) { super(e, t, n, r, i, a, o, s, l), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class Zb { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const n = this.getUtoTmapping(e); return this.getPoint(n, t) } getPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPointAt(n / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let n, r = this.getPoint(0), i = 0; t.push(0); for (let a = 1; a <= e; a++)n = this.getPoint(a / e), i += n.distanceTo(r), t.push(i), r = n; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const n = this.getLengths(); let r = 0; const i = n.length; let a; a = t || e * n[i - 1]; let o, s = 0, l = i - 1; for (; s <= l;)if (r = Math.floor(s + (l - s) / 2), o = n[r] - a, o < 0) s = r + 1; else { if (!(o > 0)) { l = r; break } l = r - 1 } if (r = l, n[r] === a) return r / (i - 1); const c = n[r]; return (r + (a - c) / (n[r + 1] - c)) / (i - 1) } getTangent(e, t) { const n = 1e-4; let r = e - n, i = e + n; r < 0 && (r = 0), i > 1 && (i = 1); const a = this.getPoint(r), o = this.getPoint(i), s = t || (a.isVector2 ? new uh : new Gh); return s.copy(o).sub(a).normalize(), s } getTangentAt(e, t) { const n = this.getUtoTmapping(e); return this.getTangent(n, t) } computeFrenetFrames(e, t) { const n = new Gh, r = [], i = [], a = [], o = new Gh, s = new yp; for (let t = 0; t <= e; t++) { const n = t / e; r[t] = this.getTangentAt(n, new Gh) } i[0] = new Gh, a[0] = new Gh; let l = Number.MAX_VALUE; const c = Math.abs(r[0].x), u = Math.abs(r[0].y), d = Math.abs(r[0].z); c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), d <= l && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]); for (let t = 1; t <= e; t++) { if (i[t] = i[t - 1].clone(), a[t] = a[t - 1].clone(), o.crossVectors(r[t - 1], r[t]), o.length() > Number.EPSILON) { o.normalize(); const e = Math.acos(ih(r[t - 1].dot(r[t]), -1, 1)); i[t].applyMatrix4(s.makeRotationAxis(o, e)) } a[t].crossVectors(r[t], i[t]) } if (!0 === t) { let t = Math.acos(ih(i[0].dot(i[e]), -1, 1)); t /= e, r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (t = -t); for (let n = 1; n <= e; n++)i[n].applyMatrix4(s.makeRotationAxis(r[n], t * n)), a[n].crossVectors(r[n], i[n]) } return { tangents: r, normals: i, binormals: a } } clone() { return (new this.constructor).copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class $b extends Zb { constructor(e = 0, t = 0, n = 1, r = 1, i = 0, a = 2 * Math.PI, o = !1, s = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s } getPoint(e, t = new uh) { const n = t, r = 2 * Math.PI; let i = this.aEndAngle - this.aStartAngle; const a = Math.abs(i) < Number.EPSILON; for (; i < 0;)i += r; for (; i > r;)i -= r; i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r); const o = this.aStartAngle + e * i; let s = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), n = s - this.aX, r = l - this.aY; s = n * e - r * t + this.aX, l = n * t + r * e + this.aY } return n.set(s, l) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class ex extends $b { constructor(e, t, n, r, i, a) { super(e, t, n, n, r, i, a), this.isArcCurve = !0, this.type = "ArcCurve" } } function tx() { let e = 0, t = 0, n = 0, r = 0; function i(i, a, o, s) { e = i, t = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s } return { initCatmullRom: function (e, t, n, r, a) { i(t, n, a * (n - e), a * (r - t)) }, initNonuniformCatmullRom: function (e, t, n, r, a, o, s) { let l = (t - e) / a - (n - e) / (a + o) + (n - t) / o, c = (n - t) / o - (r - t) / (o + s) + (r - n) / s; l *= o, c *= o, i(t, n, l, c) }, calc: function (i) { const a = i * i; return e + t * i + n * a + r * (a * i) } } } const nx = new Gh, rx = new tx, ix = new tx, ax = new tx; class ox extends Zb { constructor(e = [], t = !1, n = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r } getPoint(e, t = new Gh) { const n = t, r = this.points, i = r.length, a = (i - (this.closed ? 0 : 1)) * e; let o, s, l = Math.floor(a), c = a - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? o = r[(l - 1) % i] : (nx.subVectors(r[0], r[1]).add(r[0]), o = nx); const u = r[l % i], d = r[(l + 1) % i]; if (this.closed || l + 2 < i ? s = r[(l + 2) % i] : (nx.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), s = nx), "centripetal" === this.curveType || "chordal" === this.curveType) { const e = "chordal" === this.curveType ? .5 : .25; let t = Math.pow(o.distanceToSquared(u), e), n = Math.pow(u.distanceToSquared(d), e), r = Math.pow(d.distanceToSquared(s), e); n < 1e-4 && (n = 1), t < 1e-4 && (t = n), r < 1e-4 && (r = n), rx.initNonuniformCatmullRom(o.x, u.x, d.x, s.x, t, n, r), ix.initNonuniformCatmullRom(o.y, u.y, d.y, s.y, t, n, r), ax.initNonuniformCatmullRom(o.z, u.z, d.z, s.z, t, n, r) } else "catmullrom" === this.curveType && (rx.initCatmullRom(o.x, u.x, d.x, s.x, this.tension), ix.initCatmullRom(o.y, u.y, d.y, s.y, this.tension), ax.initCatmullRom(o.z, u.z, d.z, s.z, this.tension)); return n.set(rx.calc(c), ix.calc(c), ax.calc(c)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new Gh).fromArray(n)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function sx(e, t, n, r, i) { const a = .5 * (r - t), o = .5 * (i - n), s = e * e; return (2 * n - 2 * r + a + o) * (e * s) + (-3 * n + 3 * r - 2 * a - o) * s + a * e + n } function lx(e, t, n, r) { return function (e, t) { const n = 1 - e; return n * n * t }(e, t) + function (e, t) { return 2 * (1 - e) * e * t }(e, n) + function (e, t) { return e * e * t }(e, r) } function cx(e, t, n, r, i) { return function (e, t) { const n = 1 - e; return n * n * n * t }(e, t) + function (e, t) { const n = 1 - e; return 3 * n * n * e * t }(e, n) + function (e, t) { return 3 * (1 - e) * e * e * t }(e, r) + function (e, t) { return e * e * e * t }(e, i) } class ux extends Zb { constructor(e = new uh, t = new uh, n = new uh, r = new uh) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new uh) { const n = t, r = this.v0, i = this.v1, a = this.v2, o = this.v3; return n.set(cx(e, r.x, i.x, a.x, o.x), cx(e, r.y, i.y, a.y, o.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class dx extends Zb { constructor(e = new Gh, t = new Gh, n = new Gh, r = new Gh) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r } getPoint(e, t = new Gh) { const n = t, r = this.v0, i = this.v1, a = this.v2, o = this.v3; return n.set(cx(e, r.x, i.x, a.x, o.x), cx(e, r.y, i.y, a.y, o.y), cx(e, r.z, i.z, a.z, o.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class hx extends Zb { constructor(e = new uh, t = new uh) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new uh) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new uh) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class px extends Zb { constructor(e = new Gh, t = new Gh) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new Gh) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new Gh) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class fx extends Zb { constructor(e = new uh, t = new uh, n = new uh) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new uh) { const n = t, r = this.v0, i = this.v1, a = this.v2; return n.set(lx(e, r.x, i.x, a.x), lx(e, r.y, i.y, a.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class mx extends Zb { constructor(e = new Gh, t = new Gh, n = new Gh) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new Gh) { const n = t, r = this.v0, i = this.v1, a = this.v2; return n.set(lx(e, r.x, i.x, a.x), lx(e, r.y, i.y, a.y), lx(e, r.z, i.z, a.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class gx extends Zb { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new uh) { const n = t, r = this.points, i = (r.length - 1) * e, a = Math.floor(i), o = i - a, s = r[0 === a ? a : a - 1], l = r[a], c = r[a > r.length - 2 ? r.length - 1 : a + 1], u = r[a > r.length - 3 ? r.length - 1 : a + 2]; return n.set(sx(o, s.x, l.x, c.x, u.x), sx(o, s.y, l.y, c.y, u.y)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new uh).fromArray(n)) } return this } } var vx = Object.freeze({ __proto__: null, ArcCurve: ex, CatmullRomCurve3: ox, CubicBezierCurve: ux, CubicBezierCurve3: dx, EllipseCurve: $b, LineCurve: hx, LineCurve3: px, QuadraticBezierCurve: fx, QuadraticBezierCurve3: mx, SplineCurve: gx }); class yx extends Zb { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); if (!e.equals(t)) { const n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3"; this.curves.push(new vx[n](t, e)) } return this } getPoint(e, t) { const n = e * this.getLength(), r = this.getCurveLengths(); let i = 0; for (; i < r.length;) { if (r[i] >= n) { const e = r[i] - n, a = this.curves[i], o = a.getLength(), s = 0 === o ? 0 : 1 - e / o; return a.getPointAt(s, t) } i++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let n = 0, r = this.curves.length; n < r; n++)t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let n; for (let r = 0, i = this.curves; r < i.length; r++) { const a = i[r], o = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o); for (let e = 0; e < s.length; e++) { const r = s[e]; n && n.equals(r) || (t.push(r), n = r) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push(n.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, n = this.curves.length; t < n; t++) { const n = this.curves[t]; e.curves.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push((new vx[n.type]).fromJSON(n)) } return this } } class bx extends yx { constructor(e) { super(), this.type = "Path", this.currentPoint = new uh, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const n = new hx(this.currentPoint.clone(), new uh(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, n, r) { const i = new fx(this.currentPoint.clone(), new uh(e, t), new uh(n, r)); return this.curves.push(i), this.currentPoint.set(n, r), this } bezierCurveTo(e, t, n, r, i, a) { const o = new ux(this.currentPoint.clone(), new uh(e, t), new uh(n, r), new uh(i, a)); return this.curves.push(o), this.currentPoint.set(i, a), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), n = new gx(t); return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, n, r, i, a) { const o = this.currentPoint.x, s = this.currentPoint.y; return this.absarc(e + o, t + s, n, r, i, a), this } absarc(e, t, n, r, i, a) { return this.absellipse(e, t, n, n, r, i, a), this } ellipse(e, t, n, r, i, a, o, s) { const l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, n, r, i, a, o, s), this } absellipse(e, t, n, r, i, a, o, s) { const l = new $b(e, t, n, r, i, a, o, s); if (this.curves.length > 0) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); const c = l.getPoint(1); return this.currentPoint.copy(c), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class xx extends zf { constructor(e = [new uh(0, -.5), new uh(.5, 0), new uh(0, .5)], t = 12, n = 0, r = 2 * Math.PI) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: r }, t = Math.floor(t), r = ih(r, 0, 2 * Math.PI); const i = [], a = [], o = [], s = [], l = [], c = 1 / t, u = new Gh, d = new uh, h = new Gh, p = new Gh, f = new Gh; let m = 0, g = 0; for (let t = 0; t <= e.length - 1; t++)switch (t) { case 0: m = e[t + 1].x - e[t].x, g = e[t + 1].y - e[t].y, h.x = 1 * g, h.y = -m, h.z = 0 * g, f.copy(h), h.normalize(), s.push(h.x, h.y, h.z); break; case e.length - 1: s.push(f.x, f.y, f.z); break; default: m = e[t + 1].x - e[t].x, g = e[t + 1].y - e[t].y, h.x = 1 * g, h.y = -m, h.z = 0 * g, p.copy(h), h.x += f.x, h.y += f.y, h.z += f.z, h.normalize(), s.push(h.x, h.y, h.z), f.copy(p) }for (let i = 0; i <= t; i++) { const h = n + i * c * r, p = Math.sin(h), f = Math.cos(h); for (let n = 0; n <= e.length - 1; n++) { u.x = e[n].x * p, u.y = e[n].y, u.z = e[n].x * f, a.push(u.x, u.y, u.z), d.x = i / t, d.y = n / (e.length - 1), o.push(d.x, d.y); const r = s[3 * n + 0] * p, c = s[3 * n + 1], h = s[3 * n + 0] * f; l.push(r, c, h) } } for (let n = 0; n < t; n++)for (let t = 0; t < e.length - 1; t++) { const r = t + n * e.length, a = r, o = r + e.length, s = r + e.length + 1, l = r + 1; i.push(a, o, l), i.push(s, l, o) } this.setIndex(i), this.setAttribute("position", new Pf(a, 3)), this.setAttribute("uv", new Pf(o, 2)), this.setAttribute("normal", new Pf(l, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new xx(e.points, e.segments, e.phiStart, e.phiLength) } } class Ax extends xx { constructor(e = 1, t = 1, n = 4, r = 8) { const i = new bx; i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: n, radialSegments: r } } static fromJSON(e) { return new Ax(e.radius, e.length, e.capSegments, e.radialSegments) } } class Sx extends zf { constructor(e = 1, t = 32, n = 0, r = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: r }, t = Math.max(3, t); const i = [], a = [], o = [], s = [], l = new Gh, c = new uh; a.push(0, 0, 0), o.push(0, 0, 1), s.push(.5, .5); for (let i = 0, u = 3; i <= t; i++, u += 3) { const d = n + i / t * r; l.x = e * Math.cos(d), l.y = e * Math.sin(d), a.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (a[u] / e + 1) / 2, c.y = (a[u + 1] / e + 1) / 2, s.push(c.x, c.y) } for (let e = 1; e <= t; e++)i.push(e, e + 1, 0); this.setIndex(i), this.setAttribute("position", new Pf(a, 3)), this.setAttribute("normal", new Pf(o, 3)), this.setAttribute("uv", new Pf(s, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Sx(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class Mx extends zf { constructor(e = 1, t = 1, n = 1, r = 32, i = 1, a = !1, o = 0, s = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: a, thetaStart: o, thetaLength: s }; const l = this; r = Math.floor(r), i = Math.floor(i); const c = [], u = [], d = [], h = []; let p = 0; const f = [], m = n / 2; let g = 0; function v(n) { const i = p, a = new uh, f = new Gh; let v = 0; const y = !0 === n ? e : t, b = !0 === n ? 1 : -1; for (let e = 1; e <= r; e++)u.push(0, m * b, 0), d.push(0, b, 0), h.push(.5, .5), p++; const x = p; for (let e = 0; e <= r; e++) { const t = e / r * s + o, n = Math.cos(t), i = Math.sin(t); f.x = y * i, f.y = m * b, f.z = y * n, u.push(f.x, f.y, f.z), d.push(0, b, 0), a.x = .5 * n + .5, a.y = .5 * i * b + .5, h.push(a.x, a.y), p++ } for (let e = 0; e < r; e++) { const t = i + e, r = x + e; !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), v += 3 } l.addGroup(g, v, !0 === n ? 1 : 2), g += v } !function () { const a = new Gh, v = new Gh; let y = 0; const b = (t - e) / n; for (let l = 0; l <= i; l++) { const c = [], g = l / i, y = g * (t - e) + e; for (let e = 0; e <= r; e++) { const t = e / r, i = t * s + o, l = Math.sin(i), f = Math.cos(i); v.x = y * l, v.y = -g * n + m, v.z = y * f, u.push(v.x, v.y, v.z), a.set(l, b, f).normalize(), d.push(a.x, a.y, a.z), h.push(t, 1 - g), c.push(p++) } f.push(c) } for (let n = 0; n < r; n++)for (let r = 0; r < i; r++) { const i = f[r][n], a = f[r + 1][n], o = f[r + 1][n + 1], s = f[r][n + 1]; e > 0 && (c.push(i, a, s), y += 3), t > 0 && (c.push(a, o, s), y += 3) } l.addGroup(g, y, 0), g += y }(), !1 === a && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new Pf(u, 3)), this.setAttribute("normal", new Pf(d, 3)), this.setAttribute("uv", new Pf(h, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Mx(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class wx extends Mx { constructor(e = 1, t = 1, n = 32, r = 1, i = !1, a = 0, o = 2 * Math.PI) { super(0, e, t, n, r, i, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: r, openEnded: i, thetaStart: a, thetaLength: o } } static fromJSON(e) { return new wx(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class _x extends zf { constructor(e = [], t = [], n = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: r }; const i = [], a = []; function o(e, t, n, r) { const i = r + 1, a = []; for (let r = 0; r <= i; r++) { a[r] = []; const o = e.clone().lerp(n, r / i), s = t.clone().lerp(n, r / i), l = i - r; for (let e = 0; e <= l; e++)a[r][e] = 0 === e && r === i ? o : o.clone().lerp(s, e / l) } for (let e = 0; e < i; e++)for (let t = 0; t < 2 * (i - e) - 1; t++) { const n = Math.floor(t / 2); t % 2 == 0 ? (s(a[e][n + 1]), s(a[e + 1][n]), s(a[e][n])) : (s(a[e][n + 1]), s(a[e + 1][n + 1]), s(a[e + 1][n])) } } function s(e) { i.push(e.x, e.y, e.z) } function l(t, n) { const r = 3 * t; n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2] } function c(e, t, n, r) { r < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === n.x && 0 === n.z && (a[t] = r / 2 / Math.PI + .5) } function u(e) { return Math.atan2(e.z, -e.x) } !function (e) { const n = new Gh, r = new Gh, i = new Gh; for (let a = 0; a < t.length; a += 3)l(t[a + 0], n), l(t[a + 1], r), l(t[a + 2], i), o(n, r, i, e) }(r), function (e) { const t = new Gh; for (let n = 0; n < i.length; n += 3)t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z }(n), function () { const e = new Gh; for (let n = 0; n < i.length; n += 3) { e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2]; const r = u(e) / 2 / Math.PI + .5, o = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5); a.push(r, 1 - o) } var t; (function () { const e = new Gh, t = new Gh, n = new Gh, r = new Gh, o = new uh, s = new uh, l = new uh; for (let d = 0, h = 0; d < i.length; d += 9, h += 6) { e.set(i[d + 0], i[d + 1], i[d + 2]), t.set(i[d + 3], i[d + 4], i[d + 5]), n.set(i[d + 6], i[d + 7], i[d + 8]), o.set(a[h + 0], a[h + 1]), s.set(a[h + 2], a[h + 3]), l.set(a[h + 4], a[h + 5]), r.copy(e).add(t).add(n).divideScalar(3); const p = u(r); c(o, h + 0, e, p), c(s, h + 2, t, p), c(l, h + 4, n, p) } })(), function () { for (let e = 0; e < a.length; e += 6) { const t = a[e + 0], n = a[e + 2], r = a[e + 4], i = Math.max(t, n, r), o = Math.min(t, n, r); i > .9 && o < .1 && (t < .2 && (a[e + 0] += 1), n < .2 && (a[e + 2] += 1), r < .2 && (a[e + 4] += 1)) } }() }(), this.setAttribute("position", new Pf(i, 3)), this.setAttribute("normal", new Pf(i.slice(), 3)), this.setAttribute("uv", new Pf(a, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new _x(e.vertices, e.indices, e.radius, e.details) } } class Ex extends _x { constructor(e = 1, t = 0) { const n = (1 + Math.sqrt(5)) / 2, r = 1 / n; super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Ex(e.radius, e.detail) } } const Cx = new Gh, Tx = new Gh, Rx = new Gh, Bx = new of; class Ix extends zf { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, null !== e) { const n = 4, r = Math.pow(10, n), i = Math.cos(th * t), a = e.getIndex(), o = e.getAttribute("position"), s = a ? a.count : o.count, l = [0, 0, 0], c = ["a", "b", "c"], u = new Array(3), d = {}, h = []; for (let e = 0; e < s; e += 3) { a ? (l[0] = a.getX(e), l[1] = a.getX(e + 1), l[2] = a.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2); const { a: t, b: n, c: s } = Bx; if (t.fromBufferAttribute(o, l[0]), n.fromBufferAttribute(o, l[1]), s.fromBufferAttribute(o, l[2]), Bx.getNormal(Rx), u[0] = `${Math.round(t.x * r)},${Math.round(t.y * r)},${Math.round(t.z * r)}`, u[1] = `${Math.round(n.x * r)},${Math.round(n.y * r)},${Math.round(n.z * r)}`, u[2] = `${Math.round(s.x * r)},${Math.round(s.y * r)},${Math.round(s.z * r)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0]) for (let e = 0; e < 3; e++) { const t = (e + 1) % 3, n = u[e], r = u[t], a = Bx[c[e]], o = Bx[c[t]], s = `${n}_${r}`, p = `${r}_${n}`; p in d && d[p] ? (Rx.dot(d[p].normal) <= i && (h.push(a.x, a.y, a.z), h.push(o.x, o.y, o.z)), d[p] = null) : s in d || (d[s] = { index0: l[e], index1: l[t], normal: Rx.clone() }) } } for (const e in d) if (d[e]) { const { index0: t, index1: n } = d[e]; Cx.fromBufferAttribute(o, t), Tx.fromBufferAttribute(o, n), h.push(Cx.x, Cx.y, Cx.z), h.push(Tx.x, Tx.y, Tx.z) } this.setAttribute("position", new Pf(h, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } class Px extends bx { constructor(e) { super(e), this.uuid = rh(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let n = 0, r = this.holes.length; n < r; n++)t[n] = this.holes[n].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, n = this.holes.length; t < n; t++) { const n = this.holes[t]; e.holes.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push((new bx).fromJSON(n)) } return this } } function Lx(e, t, n, r, i) { let a, o; if (i === function (e, t, n, r) { let i = 0; for (let a = t, o = n - r; a < n; a += r)i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a; return i }(e, t, n, r) > 0) for (a = t; a < n; a += r)o = eA(a, e[a], e[a + 1], o); else for (a = n - r; a >= t; a -= r)o = eA(a, e[a], e[a + 1], o); return o && Yx(o, o.next) && (tA(o), o = o.next), o } function Dx(e, t) { if (!e) return e; t || (t = e); let n, r = e; do { if (n = !1, r.steiner || !Yx(r, r.next) && 0 !== Jx(r.prev, r, r.next)) r = r.next; else { if (tA(r), r = t = r.prev, r === r.next) break; n = !0 } } while (n || r !== t); return t } function kx(e, t, n, r, i, a, o) { if (!e) return; !o && a && function (e, t, n, r) { let i = e; do { 0 === i.z && (i.z = jx(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== e); i.prevZ.nextZ = null, i.prevZ = null, function (e) { let t, n, r, i, a, o, s, l, c = 1; do { for (n = e, e = null, a = null, o = 0; n;) { for (o++, r = n, s = 0, t = 0; t < c && (s++, r = r.nextZ, r); t++); for (l = c; s > 0 || l > 0 && r;)0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i; n = r } a.nextZ = null, c *= 2 } while (o > 1) }(i) }(e, r, i, a); let s, l, c = e; for (; e.prev !== e.next;)if (s = e.prev, l = e.next, a ? Fx(e, r, i, a) : Nx(e)) t.push(s.i / n | 0), t.push(e.i / n | 0), t.push(l.i / n | 0), tA(e), e = l.next, c = l.next; else if ((e = l) === c) { o ? 1 === o ? kx(e = Ox(Dx(e), t, n), t, n, r, i, a, 2) : 2 === o && Ux(e, t, n, r, i, a) : kx(Dx(e), t, n, r, i, a, 1); break } } function Nx(e) { const t = e.prev, n = e, r = e.next; if (Jx(t, n, r) >= 0) return !1; const i = t.x, a = n.x, o = r.x, s = t.y, l = n.y, c = r.y, u = i < a ? i < o ? i : o : a < o ? a : o, d = s < l ? s < c ? s : c : l < c ? l : c, h = i > a ? i > o ? i : o : a > o ? a : o, p = s > l ? s > c ? s : c : l > c ? l : c; let f = r.next; for (; f !== t;) { if (f.x >= u && f.x <= h && f.y >= d && f.y <= p && Wx(i, s, a, l, o, c, f.x, f.y) && Jx(f.prev, f, f.next) >= 0) return !1; f = f.next } return !0 } function Fx(e, t, n, r) { const i = e.prev, a = e, o = e.next; if (Jx(i, a, o) >= 0) return !1; const s = i.x, l = a.x, c = o.x, u = i.y, d = a.y, h = o.y, p = s < l ? s < c ? s : c : l < c ? l : c, f = u < d ? u < h ? u : h : d < h ? d : h, m = s > l ? s > c ? s : c : l > c ? l : c, g = u > d ? u > h ? u : h : d > h ? d : h, v = jx(p, f, t, n, r), y = jx(m, g, t, n, r); let b = e.prevZ, x = e.nextZ; for (; b && b.z >= v && x && x.z <= y;) { if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== i && b !== o && Wx(s, u, l, d, c, h, b.x, b.y) && Jx(b.prev, b, b.next) >= 0) return !1; if (b = b.prevZ, x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== i && x !== o && Wx(s, u, l, d, c, h, x.x, x.y) && Jx(x.prev, x, x.next) >= 0) return !1; x = x.nextZ } for (; b && b.z >= v;) { if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== i && b !== o && Wx(s, u, l, d, c, h, b.x, b.y) && Jx(b.prev, b, b.next) >= 0) return !1; b = b.prevZ } for (; x && x.z <= y;) { if (x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== i && x !== o && Wx(s, u, l, d, c, h, x.x, x.y) && Jx(x.prev, x, x.next) >= 0) return !1; x = x.nextZ } return !0 } function Ox(e, t, n) { let r = e; do { const i = r.prev, a = r.next.next; !Yx(i, a) && Qx(i, r, r.next, a) && Zx(i, a) && Zx(a, i) && (t.push(i.i / n | 0), t.push(r.i / n | 0), t.push(a.i / n | 0), tA(r), tA(r.next), r = e = a), r = r.next } while (r !== e); return Dx(r) } function Ux(e, t, n, r, i, a) { let o = e; do { let e = o.next.next; for (; e !== o.prev;) { if (o.i !== e.i && Xx(o, e)) { let s = $x(o, e); return o = Dx(o, o.next), s = Dx(s, s.next), kx(o, t, n, r, i, a, 0), void kx(s, t, n, r, i, a, 0) } e = e.next } o = o.next } while (o !== e) } function zx(e, t) { return e.x - t.x } function Hx(e, t) { const n = function (e, t) { let n, r = t, i = -1 / 0; const a = e.x, o = e.y; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { const e = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (e <= a && e > i && (i = e, n = r.x < r.next.x ? r : r.next, e === a)) return n } r = r.next } while (r !== t); if (!n) return null; const s = n, l = n.x, c = n.y; let u, d = 1 / 0; r = n; do { a >= r.x && r.x >= l && a !== r.x && Wx(o < c ? a : i, o, l, c, o < c ? i : a, o, r.x, r.y) && (u = Math.abs(o - r.y) / (a - r.x), Zx(r, e) && (u < d || u === d && (r.x > n.x || r.x === n.x && Gx(n, r))) && (n = r, d = u)), r = r.next } while (r !== s); return n }(e, t); if (!n) return t; const r = $x(n, e); return Dx(r, r.next), Dx(n, n.next) } function Gx(e, t) { return Jx(e.prev, e, t.prev) < 0 && Jx(t.next, e, e.next) < 0 } function jx(e, t, n, r, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function Vx(e) { let t = e, n = e; do { (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next } while (t !== e); return n } function Wx(e, t, n, r, i, a, o, s) { return (i - o) * (t - s) >= (e - o) * (a - s) && (e - o) * (r - s) >= (n - o) * (t - s) && (n - o) * (a - s) >= (i - o) * (r - s) } function Xx(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { let n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Qx(n, n.next, e, t)) return !0; n = n.next } while (n !== e); return !1 }(e, t) && (Zx(e, t) && Zx(t, e) && function (e, t) { let n = e, r = !1; const i = (e.x + t.x) / 2, a = (e.y + t.y) / 2; do { n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== e); return r }(e, t) && (Jx(e.prev, e, t.prev) || Jx(e, t.prev, t)) || Yx(e, t) && Jx(e.prev, e, e.next) > 0 && Jx(t.prev, t, t.next) > 0) } function Jx(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function Yx(e, t) { return e.x === t.x && e.y === t.y } function Qx(e, t, n, r) { const i = qx(Jx(e, t, n)), a = qx(Jx(e, t, r)), o = qx(Jx(n, r, e)), s = qx(Jx(n, r, t)); return i !== a && o !== s || !(0 !== i || !Kx(e, n, t)) || !(0 !== a || !Kx(e, r, t)) || !(0 !== o || !Kx(n, e, r)) || !(0 !== s || !Kx(n, t, r)) } function Kx(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function qx(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function Zx(e, t) { return Jx(e.prev, e, e.next) < 0 ? Jx(e, t, e.next) >= 0 && Jx(e, e.prev, t) >= 0 : Jx(e, t, e.prev) < 0 || Jx(e, e.next, t) < 0 } function $x(e, t) { const n = new nA(e.i, e.x, e.y), r = new nA(t.i, t.x, t.y), i = e.next, a = t.prev; return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r } function eA(e, t, n, r) { const i = new nA(e, t, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function tA(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function nA(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class rA { static area(e) { const t = e.length; let n = 0; for (let r = t - 1, i = 0; i < t; r = i++)n += e[r].x * e[i].y - e[i].x * e[r].y; return .5 * n } static isClockWise(e) { return rA.area(e) < 0 } static triangulateShape(e, t) { const n = [], r = [], i = []; iA(e), aA(n, e); let a = e.length; t.forEach(iA); for (let e = 0; e < t.length; e++)r.push(a), a += t[e].length, aA(n, t[e]); const o = function (e, t, n = 2) { const r = t && t.length, i = r ? t[0] * n : e.length; let a = Lx(e, 0, i, n, !0); const o = []; if (!a || a.next === a.prev) return o; let s, l, c, u, d, h, p; if (r && (a = function (e, t, n, r) { const i = []; let a, o, s, l, c; for (a = 0, o = t.length; a < o; a++)s = t[a] * r, l = a < o - 1 ? t[a + 1] * r : e.length, c = Lx(e, s, l, r, !1), c === c.next && (c.steiner = !0), i.push(Vx(c)); for (i.sort(zx), a = 0; a < i.length; a++)n = Hx(i[a], n); return n }(e, t, a, n)), e.length > 80 * n) { s = c = e[0], l = u = e[1]; for (let t = n; t < i; t += n)d = e[t], h = e[t + 1], d < s && (s = d), h < l && (l = h), d > c && (c = d), h > u && (u = h); p = Math.max(c - s, u - l), p = 0 !== p ? 32767 / p : 0 } return kx(a, o, n, s, l, p, 0), o }(n, r); for (let e = 0; e < o.length; e += 3)i.push(o.slice(e, e + 3)); return i } } function iA(e) { const t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function aA(e, t) { for (let n = 0; n < t.length; n++)e.push(t[n].x), e.push(t[n].y) } class oA extends zf { constructor(e = new Px([new uh(.5, .5), new uh(-.5, .5), new uh(-.5, -.5), new uh(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const n = this, r = [], i = []; for (let t = 0, n = e.length; t < n; t++)a(e[t]); function a(e) { const a = [], o = void 0 !== t.curveSegments ? t.curveSegments : 12, s = void 0 !== t.steps ? t.steps : 1, l = void 0 !== t.depth ? t.depth : 1; let c = void 0 === t.bevelEnabled || t.bevelEnabled, u = void 0 !== t.bevelThickness ? t.bevelThickness : .2, d = void 0 !== t.bevelSize ? t.bevelSize : u - .1, h = void 0 !== t.bevelOffset ? t.bevelOffset : 0, p = void 0 !== t.bevelSegments ? t.bevelSegments : 3; const f = t.extrudePath, m = void 0 !== t.UVGenerator ? t.UVGenerator : sA; let g, v, y, b, x, A = !1; f && (g = f.getSpacedPoints(s), A = !0, c = !1, v = f.computeFrenetFrames(s, !1), y = new Gh, b = new Gh, x = new Gh), c || (p = 0, u = 0, d = 0, h = 0); const S = e.extractPoints(o); let M = S.shape; const w = S.holes; if (!rA.isClockWise(M)) { M = M.reverse(); for (let e = 0, t = w.length; e < t; e++) { const t = w[e]; rA.isClockWise(t) && (w[e] = t.reverse()) } } const _ = rA.triangulateShape(M, w), E = M; for (let e = 0, t = w.length; e < t; e++) { const t = w[e]; M = M.concat(t) } function C(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().addScaledVector(t, n) } const T = M.length, R = _.length; function B(e, t, n) { let r, i, a; const o = e.x - t.x, s = e.y - t.y, l = n.x - e.x, c = n.y - e.y, u = o * o + s * s, d = o * c - s * l; if (Math.abs(d) > Number.EPSILON) { const d = Math.sqrt(u), h = Math.sqrt(l * l + c * c), p = t.x - s / d, f = t.y + o / d, m = ((n.x - c / h - p) * c - (n.y + l / h - f) * l) / (o * c - s * l); r = p + o * m - e.x, i = f + s * m - e.y; const g = r * r + i * i; if (g <= 2) return new uh(r, i); a = Math.sqrt(g / 2) } else { let e = !1; o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0), e ? (r = -s, i = o, a = Math.sqrt(u)) : (r = o, i = s, a = Math.sqrt(u / 2)) } return new uh(r / a, i / a) } const I = []; for (let e = 0, t = E.length, n = t - 1, r = e + 1; e < t; e++, n++, r++)n === t && (n = 0), r === t && (r = 0), I[e] = B(E[e], E[n], E[r]); const P = []; let L, D = I.concat(); for (let e = 0, t = w.length; e < t; e++) { const t = w[e]; L = []; for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++)r === n && (r = 0), i === n && (i = 0), L[e] = B(t[e], t[r], t[i]); P.push(L), D = D.concat(L) } for (let e = 0; e < p; e++) { const t = e / p, n = u * Math.cos(t * Math.PI / 2), r = d * Math.sin(t * Math.PI / 2) + h; for (let e = 0, t = E.length; e < t; e++) { const t = C(E[e], I[e], r); F(t.x, t.y, -n) } for (let e = 0, t = w.length; e < t; e++) { const t = w[e]; L = P[e]; for (let e = 0, i = t.length; e < i; e++) { const i = C(t[e], L[e], r); F(i.x, i.y, -n) } } } const k = d + h; for (let e = 0; e < T; e++) { const t = c ? C(M[e], D[e], k) : M[e]; A ? (b.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), x.copy(g[0]).add(b).add(y), F(x.x, x.y, x.z)) : F(t.x, t.y, 0) } for (let e = 1; e <= s; e++)for (let t = 0; t < T; t++) { const n = c ? C(M[t], D[t], k) : M[t]; A ? (b.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), x.copy(g[e]).add(b).add(y), F(x.x, x.y, x.z)) : F(n.x, n.y, l / s * e) } for (let e = p - 1; e >= 0; e--) { const t = e / p, n = u * Math.cos(t * Math.PI / 2), r = d * Math.sin(t * Math.PI / 2) + h; for (let e = 0, t = E.length; e < t; e++) { const t = C(E[e], I[e], r); F(t.x, t.y, l + n) } for (let e = 0, t = w.length; e < t; e++) { const t = w[e]; L = P[e]; for (let e = 0, i = t.length; e < i; e++) { const i = C(t[e], L[e], r); A ? F(i.x, i.y + g[s - 1].y, g[s - 1].x + n) : F(i.x, i.y, l + n) } } } function N(e, t) { let n = e.length; for (; --n >= 0;) { const r = n; let i = n - 1; i < 0 && (i = e.length - 1); for (let e = 0, n = s + 2 * p; e < n; e++) { const n = T * e, a = T * (e + 1); U(t + r + n, t + i + n, t + i + a, t + r + a) } } } function F(e, t, n) { a.push(e), a.push(t), a.push(n) } function O(e, t, i) { z(e), z(t), z(i); const a = r.length / 3, o = m.generateTopUV(n, r, a - 3, a - 2, a - 1); H(o[0]), H(o[1]), H(o[2]) } function U(e, t, i, a) { z(e), z(t), z(a), z(t), z(i), z(a); const o = r.length / 3, s = m.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1); H(s[0]), H(s[1]), H(s[3]), H(s[1]), H(s[2]), H(s[3]) } function z(e) { r.push(a[3 * e + 0]), r.push(a[3 * e + 1]), r.push(a[3 * e + 2]) } function H(e) { i.push(e.x), i.push(e.y) } !function () { const e = r.length / 3; if (c) { let e = 0, t = T * e; for (let e = 0; e < R; e++) { const n = _[e]; O(n[2] + t, n[1] + t, n[0] + t) } e = s + 2 * p, t = T * e; for (let e = 0; e < R; e++) { const n = _[e]; O(n[0] + t, n[1] + t, n[2] + t) } } else { for (let e = 0; e < R; e++) { const t = _[e]; O(t[2], t[1], t[0]) } for (let e = 0; e < R; e++) { const t = _[e]; O(t[0] + T * s, t[1] + T * s, t[2] + T * s) } } n.addGroup(e, r.length / 3 - e, 0) }(), function () { const e = r.length / 3; let t = 0; N(E, t), t += E.length; for (let e = 0, n = w.length; e < n; e++) { const n = w[e]; N(n, t), t += n.length } n.addGroup(e, r.length / 3 - e, 1) }() } this.setAttribute("position", new Pf(r, 3)), this.setAttribute("uv", new Pf(i, 2)), this.computeVertexNormals() } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return function (e, t, n) { if (n.shapes = [], Array.isArray(e)) for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; n.shapes.push(r.uuid) } else n.shapes.push(e.uuid); return n.options = Object.assign({}, t), void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n }(this.parameters.shapes, this.parameters.options, e) } static fromJSON(e, t) { const n = []; for (let r = 0, i = e.shapes.length; r < i; r++) { const i = t[e.shapes[r]]; n.push(i) } const r = e.options.extrudePath; return void 0 !== r && (e.options.extrudePath = (new vx[r.type]).fromJSON(r)), new oA(n, e.options) } } const sA = { generateTopUV: function (e, t, n, r, i) { const a = t[3 * n], o = t[3 * n + 1], s = t[3 * r], l = t[3 * r + 1], c = t[3 * i], u = t[3 * i + 1]; return [new uh(a, o), new uh(s, l), new uh(c, u)] }, generateSideWallUV: function (e, t, n, r, i, a) { const o = t[3 * n], s = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * r], u = t[3 * r + 1], d = t[3 * r + 2], h = t[3 * i], p = t[3 * i + 1], f = t[3 * i + 2], m = t[3 * a], g = t[3 * a + 1], v = t[3 * a + 2]; return Math.abs(s - u) < Math.abs(o - c) ? [new uh(o, 1 - l), new uh(c, 1 - d), new uh(h, 1 - f), new uh(m, 1 - v)] : [new uh(s, 1 - l), new uh(u, 1 - d), new uh(p, 1 - f), new uh(g, 1 - v)] } }; class lA extends _x { constructor(e = 1, t = 0) { const n = (1 + Math.sqrt(5)) / 2; super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new lA(e.radius, e.detail) } } class cA extends _x { constructor(e = 1, t = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new cA(e.radius, e.detail) } } class uA extends zf { constructor(e = .5, t = 1, n = 32, r = 1, i = 0, a = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: r, thetaStart: i, thetaLength: a }, n = Math.max(3, n); const o = [], s = [], l = [], c = []; let u = e; const d = (t - e) / (r = Math.max(1, r)), h = new Gh, p = new uh; for (let e = 0; e <= r; e++) { for (let e = 0; e <= n; e++) { const r = i + e / n * a; h.x = u * Math.cos(r), h.y = u * Math.sin(r), s.push(h.x, h.y, h.z), l.push(0, 0, 1), p.x = (h.x / t + 1) / 2, p.y = (h.y / t + 1) / 2, c.push(p.x, p.y) } u += d } for (let e = 0; e < r; e++) { const t = e * (n + 1); for (let e = 0; e < n; e++) { const r = e + t, i = r, a = r + n + 1, s = r + n + 2, l = r + 1; o.push(i, a, l), o.push(a, s, l) } } this.setIndex(o), this.setAttribute("position", new Pf(s, 3)), this.setAttribute("normal", new Pf(l, 3)), this.setAttribute("uv", new Pf(c, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new uA(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class dA extends zf { constructor(e = new Px([new uh(0, .5), new uh(-.5, -.5), new uh(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const n = [], r = [], i = [], a = []; let o = 0, s = 0; if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++)l(e[t]), this.addGroup(o, s, t), o += s, s = 0; function l(e) { const o = r.length / 3, l = e.extractPoints(t); let c = l.shape; const u = l.holes; !1 === rA.isClockWise(c) && (c = c.reverse()); for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; !0 === rA.isClockWise(t) && (u[e] = t.reverse()) } const d = rA.triangulateShape(c, u); for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; c = c.concat(t) } for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; r.push(t.x, t.y, 0), i.push(0, 0, 1), a.push(t.x, t.y) } for (let e = 0, t = d.length; e < t; e++) { const t = d[e], r = t[0] + o, i = t[1] + o, a = t[2] + o; n.push(r, i, a), s += 3 } } this.setIndex(n), this.setAttribute("position", new Pf(r, 3)), this.setAttribute("normal", new Pf(i, 3)), this.setAttribute("uv", new Pf(a, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (let n = 0, r = e.length; n < r; n++) { const r = e[n]; t.shapes.push(r.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } static fromJSON(e, t) { const n = []; for (let r = 0, i = e.shapes.length; r < i; r++) { const i = t[e.shapes[r]]; n.push(i) } return new dA(n, e.curveSegments) } } class hA extends zf { constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, a = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: a, thetaLength: o }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n)); const s = Math.min(a + o, Math.PI); let l = 0; const c = [], u = new Gh, d = new Gh, h = [], p = [], f = [], m = []; for (let h = 0; h <= n; h++) { const g = [], v = h / n; let y = 0; 0 === h && 0 === a ? y = .5 / t : h === n && s === Math.PI && (y = -.5 / t); for (let n = 0; n <= t; n++) { const s = n / t; u.x = -e * Math.cos(r + s * i) * Math.sin(a + v * o), u.y = e * Math.cos(a + v * o), u.z = e * Math.sin(r + s * i) * Math.sin(a + v * o), p.push(u.x, u.y, u.z), d.copy(u).normalize(), f.push(d.x, d.y, d.z), m.push(s + y, 1 - v), g.push(l++) } c.push(g) } for (let e = 0; e < n; e++)for (let r = 0; r < t; r++) { const t = c[e][r + 1], i = c[e][r], o = c[e + 1][r], l = c[e + 1][r + 1]; (0 !== e || a > 0) && h.push(t, i, l), (e !== n - 1 || s < Math.PI) && h.push(i, o, l) } this.setIndex(h), this.setAttribute("position", new Pf(p, 3)), this.setAttribute("normal", new Pf(f, 3)), this.setAttribute("uv", new Pf(m, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new hA(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class pA extends _x { constructor(e = 1, t = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new pA(e.radius, e.detail) } } class fA extends zf { constructor(e = 1, t = .4, n = 12, r = 48, i = 2 * Math.PI) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i }, n = Math.floor(n), r = Math.floor(r); const a = [], o = [], s = [], l = [], c = new Gh, u = new Gh, d = new Gh; for (let a = 0; a <= n; a++)for (let h = 0; h <= r; h++) { const p = h / r * i, f = a / n * Math.PI * 2; u.x = (e + t * Math.cos(f)) * Math.cos(p), u.y = (e + t * Math.cos(f)) * Math.sin(p), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), d.subVectors(u, c).normalize(), s.push(d.x, d.y, d.z), l.push(h / r), l.push(a / n) } for (let e = 1; e <= n; e++)for (let t = 1; t <= r; t++) { const n = (r + 1) * e + t - 1, i = (r + 1) * (e - 1) + t - 1, o = (r + 1) * (e - 1) + t, s = (r + 1) * e + t; a.push(n, i, s), a.push(i, o, s) } this.setIndex(a), this.setAttribute("position", new Pf(o, 3)), this.setAttribute("normal", new Pf(s, 3)), this.setAttribute("uv", new Pf(l, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new fA(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class mA extends zf { constructor(e = 1, t = .4, n = 64, r = 8, i = 2, a = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: r, p: i, q: a }, n = Math.floor(n), r = Math.floor(r); const o = [], s = [], l = [], c = [], u = new Gh, d = new Gh, h = new Gh, p = new Gh, f = new Gh, m = new Gh, g = new Gh; for (let o = 0; o <= n; ++o) { const y = o / n * i * Math.PI * 2; v(y, i, a, e, h), v(y + .01, i, a, e, p), m.subVectors(p, h), g.addVectors(p, h), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize(); for (let e = 0; e <= r; ++e) { const i = e / r * Math.PI * 2, a = -t * Math.cos(i), p = t * Math.sin(i); u.x = h.x + (a * g.x + p * f.x), u.y = h.y + (a * g.y + p * f.y), u.z = h.z + (a * g.z + p * f.z), s.push(u.x, u.y, u.z), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(o / n), c.push(e / r) } } for (let e = 1; e <= n; e++)for (let t = 1; t <= r; t++) { const n = (r + 1) * (e - 1) + (t - 1), i = (r + 1) * e + (t - 1), a = (r + 1) * e + t, s = (r + 1) * (e - 1) + t; o.push(n, i, s), o.push(i, a, s) } function v(e, t, n, r, i) { const a = Math.cos(e), o = Math.sin(e), s = n / t * e, l = Math.cos(s); i.x = r * (2 + l) * .5 * a, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(s) * .5 } this.setIndex(o), this.setAttribute("position", new Pf(s, 3)), this.setAttribute("normal", new Pf(l, 3)), this.setAttribute("uv", new Pf(c, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new mA(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class gA extends zf { constructor(e = new mx(new Gh(-1, -1, 0), new Gh(-1, 1, 0), new Gh(1, 1, 0)), t = 64, n = 1, r = 8, i = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: r, closed: i }; const a = e.computeFrenetFrames(t, i); this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals; const o = new Gh, s = new Gh, l = new uh; let c = new Gh; const u = [], d = [], h = [], p = []; function f(i) { c = e.getPointAt(i / t, c); const l = a.normals[i], h = a.binormals[i]; for (let e = 0; e <= r; e++) { const t = e / r * Math.PI * 2, i = Math.sin(t), a = -Math.cos(t); s.x = a * l.x + i * h.x, s.y = a * l.y + i * h.y, s.z = a * l.z + i * h.z, s.normalize(), d.push(s.x, s.y, s.z), o.x = c.x + n * s.x, o.y = c.y + n * s.y, o.z = c.z + n * s.z, u.push(o.x, o.y, o.z) } } !function () { for (let e = 0; e < t; e++)f(e); f(!1 === i ? t : 0), function () { for (let e = 0; e <= t; e++)for (let n = 0; n <= r; n++)l.x = e / t, l.y = n / r, h.push(l.x, l.y) }(), function () { for (let e = 1; e <= t; e++)for (let t = 1; t <= r; t++) { const n = (r + 1) * (e - 1) + (t - 1), i = (r + 1) * e + (t - 1), a = (r + 1) * e + t, o = (r + 1) * (e - 1) + t; p.push(n, i, o), p.push(i, a, o) } }() }(), this.setIndex(p), this.setAttribute("position", new Pf(u, 3)), this.setAttribute("normal", new Pf(d, 3)), this.setAttribute("uv", new Pf(h, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new gA((new vx[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class vA extends zf { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, null !== e) { const t = [], n = new Set, r = new Gh, i = new Gh; if (null !== e.index) { const a = e.attributes.position, o = e.index; let s = e.groups; 0 === s.length && (s = [{ start: 0, count: o.count, materialIndex: 0 }]); for (let e = 0, l = s.length; e < l; ++e) { const l = s[e], c = l.start; for (let e = c, s = c + l.count; e < s; e += 3)for (let s = 0; s < 3; s++) { const l = o.getX(e + s), c = o.getX(e + (s + 1) % 3); r.fromBufferAttribute(a, l), i.fromBufferAttribute(a, c), !0 === yA(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z)) } } } else { const a = e.attributes.position; for (let e = 0, o = a.count / 3; e < o; e++)for (let o = 0; o < 3; o++) { const s = 3 * e + o, l = 3 * e + (o + 1) % 3; r.fromBufferAttribute(a, s), i.fromBufferAttribute(a, l), !0 === yA(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z)) } } this.setAttribute("position", new Pf(t, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function yA(e, t, n) { const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`, i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`; return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0) } var bA = Object.freeze({ __proto__: null, BoxGeometry: em, CapsuleGeometry: Ax, CircleGeometry: Sx, ConeGeometry: wx, CylinderGeometry: Mx, DodecahedronGeometry: Ex, EdgesGeometry: Ix, ExtrudeGeometry: oA, IcosahedronGeometry: lA, LatheGeometry: xx, OctahedronGeometry: cA, PlaneGeometry: wm, PolyhedronGeometry: _x, RingGeometry: uA, ShapeGeometry: dA, SphereGeometry: hA, TetrahedronGeometry: pA, TorusGeometry: fA, TorusKnotGeometry: mA, TubeGeometry: gA, WireframeGeometry: vA }); class xA extends ff { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new df(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class AA extends am { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class SA extends ff { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new df(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new df(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = id, this.normalScale = new uh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Tp, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class MA extends SA { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new uh(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return ih(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (e) { this.ior = (1 + .4 * e) / (1 - .4 * e) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new df(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new df(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new df(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get dispersion() { return this._dispersion } set dispersion(e) { this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class wA extends ff { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new df(16777215), this.specular = new df(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new df(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = id, this.normalScale = new uh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Tp, this.combine = ac, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class _A extends ff { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new df(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new df(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = id, this.normalScale = new uh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class EA extends ff { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = id, this.normalScale = new uh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class CA extends ff { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new df(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new df(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = id, this.normalScale = new uh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Tp, this.combine = ac, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class TA extends ff { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new df(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = id, this.normalScale = new uh(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class RA extends _b { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function BA(e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) } function IA(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) } function PA(e) { const t = e.length, n = new Array(t); for (let e = 0; e !== t; ++e)n[e] = e; return n.sort((function (t, n) { return e[t] - e[n] })), n } function LA(e, t, n) { const r = e.length, i = new e.constructor(r); for (let a = 0, o = 0; o !== r; ++a) { const r = n[a] * t; for (let n = 0; n !== t; ++n)i[o++] = e[r + n] } return i } function DA(e, t, n, r) { let i = 1, a = e[0]; for (; void 0 !== a && void 0 === a[r];)a = e[i++]; if (void 0 === a) return; let o = a[r]; if (void 0 !== o) if (Array.isArray(o)) do { o = a[r], void 0 !== o && (t.push(a.time), n.push.apply(n, o)), a = e[i++] } while (void 0 !== a); else if (void 0 !== o.toArray) do { o = a[r], void 0 !== o && (t.push(a.time), o.toArray(n, n.length)), a = e[i++] } while (void 0 !== a); else do { o = a[r], void 0 !== o && (t.push(a.time), n.push(o)), a = e[i++] } while (void 0 !== a) } const kA = { convertArray: BA, isTypedArray: IA, getKeyframeOrder: PA, sortedArray: LA, flattenJSON: DA, subclip: function (e, t, n, r, i = 30) { const a = e.clone(); a.name = t; const o = []; for (let e = 0; e < a.tracks.length; ++e) { const t = a.tracks[e], s = t.getValueSize(), l = [], c = []; for (let e = 0; e < t.times.length; ++e) { const a = t.times[e] * i; if (!(a < n || a >= r)) { l.push(t.times[e]); for (let n = 0; n < s; ++n)c.push(t.values[e * s + n]) } } 0 !== l.length && (t.times = BA(l, t.times.constructor), t.values = BA(c, t.values.constructor), o.push(t)) } a.tracks = o; let s = 1 / 0; for (let e = 0; e < a.tracks.length; ++e)s > a.tracks[e].times[0] && (s = a.tracks[e].times[0]); for (let e = 0; e < a.tracks.length; ++e)a.tracks[e].shift(-1 * s); return a.resetDuration(), a }, makeClipAdditive: function (e, t = 0, n = e, r = 30) { r <= 0 && (r = 30); const i = n.tracks.length, a = t / r; for (let t = 0; t < i; ++t) { const r = n.tracks[t], i = r.ValueTypeName; if ("bool" === i || "string" === i) continue; const o = e.tracks.find((function (e) { return e.name === r.name && e.ValueTypeName === i })); if (void 0 === o) continue; let s = 0; const l = r.getValueSize(); r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3); let c = 0; const u = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3); const d = r.times.length - 1; let h; if (a <= r.times[0]) { const e = s, t = l - s; h = r.values.slice(e, t) } else if (a >= r.times[d]) { const e = d * l + s, t = e + l - s; h = r.values.slice(e, t) } else { const e = r.createInterpolant(), t = s, n = l - s; e.evaluate(a), h = e.resultBuffer.slice(t, n) } "quaternion" === i && (new Hh).fromArray(h).normalize().conjugate().toArray(h); const p = o.times.length; for (let e = 0; e < p; ++e) { const t = e * u + c; if ("quaternion" === i) Hh.multiplyQuaternionsFlat(o.values, t, h, 0, o.values, t); else { const e = u - 2 * c; for (let n = 0; n < e; ++n)o.values[t + n] -= h[n] } } } return e.blendMode = Ku, e } }; class NA { constructor(e, t, n, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let n = this._cachedIndex, r = t[n], i = t[n - 1]; e: { t: { let a; n: { r: if (!(e < r)) { for (let a = n + 2; ;) { if (void 0 === r) { if (e < i) break r; return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } if (n === a) break; if (i = r, r = t[++n], e < r) break t } a = t.length; break n } if (e >= i) break e; { const o = t[1]; e < o && (n = 2, i = o); for (let a = n - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0); if (n === a) break; if (r = i, i = t[--n - 1], e >= i) break t } a = n, n = 0 } } for (; n < a;) { const r = n + a >>> 1; e < t[r] ? a = r : n = r + 1 } if (r = t[n], i = t[n - 1], void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0); if (void 0 === r) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } this._cachedIndex = n, this.intervalChanged_(n, i, r) } return this.interpolate_(n, i, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r; for (let e = 0; e !== r; ++e)t[e] = n[i + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class FA extends NA { constructor(e, t, n, r) { super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Xu, endingEnd: Xu } } intervalChanged_(e, t, n) { const r = this.parameterPositions; let i = e - 2, a = e + 1, o = r[i], s = r[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case Ju: i = e, o = 2 * t - n; break; case Yu: i = r.length - 2, o = t + r[i] - r[i + 1]; break; default: i = e, o = n }if (void 0 === s) switch (this.getSettings_().endingEnd) { case Ju: a = e, s = 2 * n - t; break; case Yu: a = 1, s = n + r[1] - r[0]; break; default: a = e - 1, s = t }const l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = a * c } interpolate_(e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, h = this._weightNext, p = (n - t) / (r - t), f = p * p, m = f * p, g = -d * m + 2 * d * f - d * p, v = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1, y = (-1 - h) * m + (1.5 + h) * f + .5 * p, b = h * m - h * f; for (let e = 0; e !== o; ++e)i[e] = g * a[c + e] + v * a[l + e] + y * a[s + e] + b * a[u + e]; return i } } class OA extends NA { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (n - t) / (r - t), u = 1 - c; for (let e = 0; e !== o; ++e)i[e] = a[l + e] * u + a[s + e] * c; return i } } class UA extends NA { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class zA { constructor(e, t, n, r) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = BA(t, this.TimeBufferType), this.values = BA(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: BA(e.times, Array), values: BA(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (n.interpolation = t) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new UA(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new OA(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new FA(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case ju: t = this.InterpolantFactoryMethodDiscrete; break; case Vu: t = this.InterpolantFactoryMethodLinear; break; case Wu: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return ju; case this.InterpolantFactoryMethodLinear: return Vu; case this.InterpolantFactoryMethodSmooth: return Wu } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let n = 0, r = t.length; n !== r; ++n)t[n] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let n = 0, r = t.length; n !== r; ++n)t[n] *= e } return this } trim(e, t) { const n = this.times, r = n.length; let i = 0, a = r - 1; for (; i !== r && n[i] < e;)++i; for (; -1 !== a && n[a] > t;)--a; if (++a, 0 !== i || a !== r) { i >= a && (a = Math.max(a, 1), i = a - 1); const e = this.getValueSize(); this.times = n.slice(i, a), this.values = this.values.slice(i * e, a * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const n = this.times, r = this.values, i = n.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let a = null; for (let t = 0; t !== i; t++) { const r = n[t]; if ("number" == typeof r && isNaN(r)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1; break } if (null !== a && a > r) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, a), e = !1; break } a = r } if (void 0 !== r && IA(r)) for (let t = 0, n = r.length; t !== n; ++t) { const n = r[t]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1; break } } return e } optimize() { const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), r = this.getInterpolation() === Wu, i = e.length - 1; let a = 1; for (let o = 1; o < i; ++o) { let i = !1; const s = e[o]; if (s !== e[o + 1] && (1 !== o || s !== e[0])) if (r) i = !0; else { const e = o * n, r = e - n, a = e + n; for (let o = 0; o !== n; ++o) { const n = t[e + o]; if (n !== t[r + o] || n !== t[a + o]) { i = !0; break } } } if (i) { if (o !== a) { e[a] = e[o]; const r = o * n, i = a * n; for (let e = 0; e !== n; ++e)t[i + e] = t[r + e] } ++a } } if (i > 0) { e[a] = e[i]; for (let e = i * n, r = a * n, o = 0; o !== n; ++o)t[r + o] = t[e + o]; ++a } return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this } clone() { const e = this.times.slice(), t = this.values.slice(), n = new (0, this.constructor)(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } } zA.prototype.TimeBufferType = Float32Array, zA.prototype.ValueBufferType = Float32Array, zA.prototype.DefaultInterpolation = Vu; class HA extends zA { constructor(e, t, n) { super(e, t, n) } } HA.prototype.ValueTypeName = "bool", HA.prototype.ValueBufferType = Array, HA.prototype.DefaultInterpolation = ju, HA.prototype.InterpolantFactoryMethodLinear = void 0, HA.prototype.InterpolantFactoryMethodSmooth = void 0; class GA extends zA { } GA.prototype.ValueTypeName = "color"; class jA extends zA { } jA.prototype.ValueTypeName = "number"; class VA extends NA { constructor(e, t, n, r) { super(e, t, n, r) } interpolate_(e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - t) / (r - t); let l = e * o; for (let e = l + o; l !== e; l += 4)Hh.slerpFlat(i, 0, a, l - o, a, l, s); return i } } class WA extends zA { InterpolantFactoryMethodLinear(e) { return new VA(this.times, this.values, this.getValueSize(), e) } } WA.prototype.ValueTypeName = "quaternion", WA.prototype.InterpolantFactoryMethodSmooth = void 0; class XA extends zA { constructor(e, t, n) { super(e, t, n) } } XA.prototype.ValueTypeName = "string", XA.prototype.ValueBufferType = Array, XA.prototype.DefaultInterpolation = ju, XA.prototype.InterpolantFactoryMethodLinear = void 0, XA.prototype.InterpolantFactoryMethodSmooth = void 0; class JA extends zA { } JA.prototype.ValueTypeName = "vector"; class YA { constructor(e = "", t = -1, n = [], r = Qu) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = rh(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], n = e.tracks, r = 1 / (e.fps || 1); for (let e = 0, i = n.length; e !== i; ++e)t.push(QA(n[e]).scale(r)); const i = new this(e.name, e.duration, t, e.blendMode); return i.uuid = e.uuid, i } static toJSON(e) { const t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, r = n.length; e !== r; ++e)t.push(zA.toJSON(n[e])); return r } static CreateFromMorphTargetSequence(e, t, n, r) { const i = t.length, a = []; for (let e = 0; e < i; e++) { let o = [], s = []; o.push((e + i - 1) % i, e, (e + 1) % i), s.push(0, 1, 0); const l = PA(o); o = LA(o, 1, l), s = LA(s, 1, l), r || 0 !== o[0] || (o.push(i), s.push(s[0])), a.push(new jA(".morphTargetInfluences[" + t[e].name + "]", o, s).scale(1 / n)) } return new this(e, -1, a) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const t = e; n = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < n.length; e++)if (n[e].name === t) return n[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, n) { const r = {}, i = /^([\w-]*?)([\d]+)$/; for (let t = 0, n = e.length; t < n; t++) { const n = e[t], a = n.name.match(i); if (a && a.length > 1) { const e = a[1]; let t = r[e]; t || (r[e] = t = []), t.push(n) } } const a = []; for (const e in r) a.push(this.CreateFromMorphTargetSequence(e, r[e], t, n)); return a } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (e, t, n, r, i) { if (0 !== n.length) { const a = [], o = []; DA(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o)) } }, r = [], i = e.name || "default", a = e.fps || 30, o = e.blendMode; let s = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const i = l[e].keys; if (i && 0 !== i.length) if (i[0].morphTargets) { const e = {}; let t; for (t = 0; t < i.length; t++)if (i[t].morphTargets) for (let n = 0; n < i[t].morphTargets.length; n++)e[i[t].morphTargets[n]] = -1; for (const n in e) { const e = [], a = []; for (let r = 0; r !== i[t].morphTargets.length; ++r) { const r = i[t]; e.push(r.time), a.push(r.morphTarget === n ? 1 : 0) } r.push(new jA(".morphTargetInfluence[" + n + "]", e, a)) } s = e.length * a } else { const a = ".bones[" + t[e].name + "]"; n(JA, a + ".position", i, "pos", r), n(WA, a + ".quaternion", i, "rot", r), n(JA, a + ".scale", i, "scl", r) } } return 0 === r.length ? null : new this(i, s, r, o) } resetDuration() { let e = 0; for (let t = 0, n = this.tracks.length; t !== n; ++t) { const n = this.tracks[t]; e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function QA(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return jA; case "vector": case "vector2": case "vector3": case "vector4": return JA; case "color": return GA; case "quaternion": return WA; case "bool": case "boolean": return HA; case "string": return XA }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], n = []; DA(e.keys, t, n, "value"), e.times = t, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const KA = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class qA { constructor(e, t, n) { const r = this; let i, a = !1, o = 0, s = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { s++, !1 === a && void 0 !== r.onStart && r.onStart(e, o, s), a = !0 }, this.itemEnd = function (e) { o++, void 0 !== r.onProgress && r.onProgress(e, o, s), o === s && (a = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function (e) { return i ? i(e) : e }, this.setURLModifier = function (e) { return i = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, n = l.length; t < n; t += 2) { const n = l[t], r = l[t + 1]; if (n.global && (n.lastIndex = 0), n.test(e)) return r } return null } } } const ZA = new qA; class $A { constructor(e) { this.manager = void 0 !== e ? e : ZA, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const n = this; return new Promise((function (r, i) { n.load(e, r, t, i) })) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } $A.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const eS = {}; class tS extends Error { constructor(e, t) { super(e), this.response = t } } class nS extends $A { constructor(e) { super(e) } load(e, t, n, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const i = KA.get(e); if (void 0 !== i) return this.manager.itemStart(e), setTimeout((() => { t && t(i), this.manager.itemEnd(e) }), 0), i; if (void 0 !== eS[e]) return void eS[e].push({ onLoad: t, onProgress: n, onError: r }); eS[e] = [], eS[e].push({ onLoad: t, onProgress: n, onError: r }); const a = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o = this.mimeType, s = this.responseType; fetch(a).then((t => { if (200 === t.status || 0 === t.status) { if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t; const n = eS[e], r = t.body.getReader(), i = t.headers.get("X-File-Size") || t.headers.get("Content-Length"), a = i ? parseInt(i) : 0, o = 0 !== a; let s = 0; const l = new ReadableStream({ start(e) { !function t() { r.read().then((({ done: r, value: i }) => { if (r) e.close(); else { s += i.byteLength; const r = new ProgressEvent("progress", { lengthComputable: o, loaded: s, total: a }); for (let e = 0, t = n.length; e < t; e++) { const t = n[e]; t.onProgress && t.onProgress(r) } e.enqueue(i), t() } }), (t => { e.error(t) })) }() } }); return new Response(l) } throw new tS(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t) })).then((e => { switch (s) { case "arraybuffer": return e.arrayBuffer(); case "blob": return e.blob(); case "document": return e.text().then((e => (new DOMParser).parseFromString(e, o))); case "json": return e.json(); default: if (void 0 === o) return e.text(); { const t = /charset="?([^;"\s]*)"?/i.exec(o), n = t && t[1] ? t[1].toLowerCase() : void 0, r = new TextDecoder(n); return e.arrayBuffer().then((e => r.decode(e))) } } })).then((t => { KA.add(e, t); const n = eS[e]; delete eS[e]; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; r.onLoad && r.onLoad(t) } })).catch((t => { const n = eS[e]; if (void 0 === n) throw this.manager.itemError(e), t; delete eS[e]; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; r.onError && r.onError(t) } this.manager.itemError(e) })).finally((() => { this.manager.itemEnd(e) })), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class rS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = new nS(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }), n, r) } parse(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = YA.parse(e[n]); t.push(r) } return t } } class iS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = [], o = new Yb, s = new nS(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials); let l = 0; function c(c) { s.load(e[c], (function (e) { const n = i.parse(e, !0); a[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = Pc), o.image = a, o.format = n.format, o.needsUpdate = !0, t && t(o)) }), n, r) } if (Array.isArray(e)) for (let t = 0, n = e.length; t < n; ++t)c(t); else s.load(e, (function (e) { const n = i.parse(e, !0); if (n.isCubemap) { const e = n.mipmaps.length / n.mipmapCount; for (let t = 0; t < e; t++) { a[t] = { mipmaps: [] }; for (let e = 0; e < n.mipmapCount; e++)a[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), a[t].format = n.format, a[t].width = n.width, a[t].height = n.height } o.image = a } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps; 1 === n.mipmapCount && (o.minFilter = Pc), o.format = n.format, o.needsUpdate = !0, t && t(o) }), n, r); return o } } class aS extends $A { constructor(e) { super(e) } load(e, t, n, r) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const i = this, a = KA.get(e); if (void 0 !== a) return i.manager.itemStart(e), setTimeout((function () { t && t(a), i.manager.itemEnd(e) }), 0), a; const o = gh("img"); function s() { c(), KA.add(e, this), t && t(this), i.manager.itemEnd(e) } function l(t) { c(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) } function c() { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1) } return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o } } class oS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = new pm; i.colorSpace = sd; const a = new aS(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); let o = 0; function s(n) { a.load(e[n], (function (e) { i.images[n] = e, o++, 6 === o && (i.needsUpdate = !0, t && t(i)) }), void 0, r) } for (let t = 0; t < e.length; ++t)s(t); return i } } class sS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = new Jy, o = new nS(this.manager); return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, (function (e) { let n; try { n = i.parse(e) } catch (e) { if (void 0 === r) return void console.error(e); r(e) } void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : _c, a.wrapT = void 0 !== n.wrapT ? n.wrapT : _c, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Pc, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Pc, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace && (a.colorSpace = n.colorSpace), void 0 !== n.flipY && (a.flipY = n.flipY), void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = kc), 1 === n.mipmapCount && (a.minFilter = Pc), void 0 !== n.generateMipmaps && (a.generateMipmaps = n.generateMipmaps), a.needsUpdate = !0, t && t(a, n) }), n, r), a } } class lS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = new Lh, a = new aS(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function (e) { i.image = e, i.needsUpdate = !0, void 0 !== t && t(i) }), n, r), i } } class cS extends Wp { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new df(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t } } class uS extends cS { constructor(e, t, n) { super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Wp.DEFAULT_UP), this.updateMatrix(), this.groundColor = new df(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const dS = new yp, hS = new Gh, pS = new Gh; class fS { constructor(e) { this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new uh(512, 512), this.map = null, this.mapPass = null, this.matrix = new yp, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Am, this._frameExtents = new uh(1, 1), this._viewportCount = 1, this._viewports = [new Dh(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; hS.setFromMatrixPosition(e.matrixWorld), t.position.copy(hS), pS.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(pS), t.updateMatrixWorld(), dS.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dS), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(dS) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class mS extends fS { constructor() { super(new um(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, n = 2 * nh * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, i = e.distance || t.far; n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class gS extends cS { constructor(e, t, n = 0, r = Math.PI / 3, i = 0, a = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Wp.DEFAULT_UP), this.updateMatrix(), this.target = new Wp, this.distance = n, this.angle = r, this.penumbra = i, this.decay = a, this.map = null, this.shadow = new mS } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const vS = new yp, yS = new Gh, bS = new Gh; class xS extends fS { constructor() { super(new um(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new uh(4, 2), this._viewportCount = 6, this._viewports = [new Dh(2, 1, 1, 1), new Dh(0, 1, 1, 1), new Dh(3, 1, 1, 1), new Dh(1, 1, 1, 1), new Dh(3, 0, 1, 1), new Dh(1, 0, 1, 1)], this._cubeDirections = [new Gh(1, 0, 0), new Gh(-1, 0, 0), new Gh(0, 0, 1), new Gh(0, 0, -1), new Gh(0, 1, 0), new Gh(0, -1, 0)], this._cubeUps = [new Gh(0, 1, 0), new Gh(0, 1, 0), new Gh(0, 1, 0), new Gh(0, 1, 0), new Gh(0, 0, 1), new Gh(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, r = this.matrix, i = e.distance || n.far; i !== n.far && (n.far = i, n.updateProjectionMatrix()), yS.setFromMatrixPosition(e.matrixWorld), n.position.copy(yS), bS.copy(n.position), bS.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(bS), n.updateMatrixWorld(), r.makeTranslation(-yS.x, -yS.y, -yS.z), vS.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vS) } } class AS extends cS { constructor(e, t, n = 0, r = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new xS } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class SS extends fS { constructor() { super(new Fm(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class MS extends cS { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Wp.DEFAULT_UP), this.updateMatrix(), this.target = new Wp, this.shadow = new SS } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class wS extends cS { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class _S extends cS { constructor(e, t, n = 10, r = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class ES { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new Gh) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const n = e.x, r = e.y, i = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * r), t.addScaledVector(a[2], .488603 * i), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], n * r * 1.092548), t.addScaledVector(a[5], r * i * 1.092548), t.addScaledVector(a[6], .315392 * (3 * i * i - 1)), t.addScaledVector(a[7], n * i * 1.092548), t.addScaledVector(a[8], .546274 * (n * n - r * r)), t } getIrradianceAt(e, t) { const n = e.x, r = e.y, i = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * i), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * r), t.addScaledVector(a[5], .858086 * r * i), t.addScaledVector(a[6], .743125 * i * i - .247708), t.addScaledVector(a[7], .858086 * n * i), t.addScaledVector(a[8], .429043 * (n * n - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(e, t = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].fromArray(e, t + 3 * r); return this } toArray(e = [], t = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].toArray(e, t + 3 * r); return e } static getBasisAt(e, t) { const n = e.x, r = e.y, i = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r) } } class CS extends cS { constructor(e = new ES, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class TS extends $A { constructor(e) { super(e), this.textures = {} } load(e, t, n, r) { const i = this, a = new nS(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, (function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }), n, r) } parse(e) { const t = this.textures; function n(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } const r = this.createMaterialFromType(e.type); if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = (new df).setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.dispersion && (r.dispersion = e.dispersion), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.anisotropy && (r.anisotropy = e.anisotropy), void 0 !== e.anisotropyRotation && (r.anisotropyRotation = e.anisotropyRotation), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.alphaHash && (r.alphaHash = e.alphaHash), void 0 !== e.depthFunc && (r.depthFunc = e.depthFunc), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.blendSrc && (r.blendSrc = e.blendSrc), void 0 !== e.blendDst && (r.blendDst = e.blendDst), void 0 !== e.blendEquation && (r.blendEquation = e.blendEquation), void 0 !== e.blendSrcAlpha && (r.blendSrcAlpha = e.blendSrcAlpha), void 0 !== e.blendDstAlpha && (r.blendDstAlpha = e.blendDstAlpha), void 0 !== e.blendEquationAlpha && (r.blendEquationAlpha = e.blendEquationAlpha), void 0 !== e.blendColor && void 0 !== r.blendColor && r.blendColor.setHex(e.blendColor), void 0 !== e.blendAlpha && (r.blendAlpha = e.blendAlpha), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), void 0 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.forceSinglePass && (r.forceSinglePass = e.forceSinglePass), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (const t in e.uniforms) { const i = e.uniforms[t]; switch (r.uniforms[t] = {}, i.type) { case "t": r.uniforms[t].value = n(i.value); break; case "c": r.uniforms[t].value = (new df).setHex(i.value); break; case "v2": r.uniforms[t].value = (new uh).fromArray(i.value); break; case "v3": r.uniforms[t].value = (new Gh).fromArray(i.value); break; case "v4": r.uniforms[t].value = (new Dh).fromArray(i.value); break; case "m3": r.uniforms[t].value = (new dh).fromArray(i.value); break; case "m4": r.uniforms[t].value = (new yp).fromArray(i.value); break; default: r.uniforms[t].value = i.value } } if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.glslVersion && (r.glslVersion = e.glslVersion), void 0 !== e.extensions) for (const t in e.extensions) r.extensions[t] = e.extensions[t]; if (void 0 !== e.lights && (r.lights = e.lights), void 0 !== e.clipping && (r.clipping = e.clipping), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) { let t = e.normalScale; !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = (new uh).fromArray(t) } return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapRotation && r.envMapRotation.fromArray(e.envMapRotation), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new uh).fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.anisotropyMap && (r.anisotropyMap = n(e.anisotropyMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r } setTextures(e) { return this.textures = e, this } createMaterialFromType(e) { return TS.createMaterialFromType(e) } static createMaterialFromType(e) { return new { ShadowMaterial: xA, SpriteMaterial: vy, RawShaderMaterial: AA, ShaderMaterial: am, PointsMaterial: Ub, MeshPhysicalMaterial: MA, MeshStandardMaterial: SA, MeshPhongMaterial: wA, MeshToonMaterial: _A, MeshNormalMaterial: EA, MeshLambertMaterial: CA, MeshDepthMaterial: Wv, MeshDistanceMaterial: Xv, MeshBasicMaterial: mf, MeshMatcapMaterial: TA, LineDashedMaterial: RA, LineBasicMaterial: _b, Material: ff }[e] } } class RS { static decodeText(e) { if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), "undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let n = 0, r = e.length; n < r; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class BS extends zf { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class IS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = new nS(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, (function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }), n, r) } parse(e) { const t = {}, n = {}; function r(e, r) { if (void 0 !== t[r]) return t[r]; const i = e.interleavedBuffers[r], a = function (e, t) { if (void 0 !== n[t]) return n[t]; const r = e.arrayBuffers[t], i = new Uint32Array(r).buffer; return n[t] = i, i }(e, i.buffer), o = mh(i.type, a), s = new fy(o, i.stride); return s.uuid = i.uuid, t[r] = s, s } const i = e.isInstancedBufferGeometry ? new BS : new zf, a = e.data.index; if (void 0 !== a) { const e = mh(a.type, a.array); i.setIndex(new Mf(e, 1)) } const o = e.data.attributes; for (const t in o) { const n = o[t]; let a; if (n.isInterleavedBufferAttribute) { const t = r(e.data, n.data); a = new gy(t, n.itemSize, n.offset, n.normalized) } else { const e = mh(n.type, n.array); a = new (n.isInstancedBufferAttribute ? qy : Mf)(e, n.itemSize, n.normalized) } void 0 !== n.name && (a.name = n.name), void 0 !== n.usage && a.setUsage(n.usage), i.setAttribute(t, a) } const s = e.data.morphAttributes; if (s) for (const t in s) { const n = s[t], a = []; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; let o; if (i.isInterleavedBufferAttribute) { const t = r(e.data, i.data); o = new gy(t, i.itemSize, i.offset, i.normalized) } else { const e = mh(i.type, i.array); o = new Mf(e, i.itemSize, i.normalized) } void 0 !== i.name && (o.name = i.name), a.push(o) } i.morphAttributes[t] = a } e.data.morphTargetsRelative && (i.morphTargetsRelative = !0); const l = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) { const t = l[e]; i.addGroup(t.start, t.count, t.materialIndex) } const c = e.data.boundingSphere; if (void 0 !== c) { const e = new Gh; void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new cp(e, c.radius) } return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i } } class PS extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = "" === this.path ? RS.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || a; const o = new nS(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (n) { let a = null; try { a = JSON.parse(n) } catch (t) { return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message) } const o = a.metadata; if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) return void 0 !== r && r(new Error("THREE.ObjectLoader: Can't load " + e)), void console.error("THREE.ObjectLoader: Can't load " + e); i.parse(a, t) }), n, r) } async loadAsync(e, t) { const n = "" === this.path ? RS.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || n; const r = new nS(this.manager); r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials); const i = await r.loadAsync(e, t), a = JSON.parse(i), o = a.metadata; if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e); return await this.parseAsync(a) } parse(e, t) { const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), a = this.parseImages(e.images, (function () { void 0 !== t && t(l) })), o = this.parseTextures(e.textures, a), s = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, i, s, o, n), c = this.parseSkeletons(e.skeletons, l); if (this.bindSkeletons(l, c), this.bindLightTargets(l), void 0 !== t) { let e = !1; for (const t in a) if (a[t].data instanceof HTMLImageElement) { e = !0; break } !1 === e && t(l) } return l } async parseAsync(e) { const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), i = await this.parseImagesAsync(e.images), a = this.parseTextures(e.textures, i), o = this.parseMaterials(e.materials, a), s = this.parseObject(e.object, r, o, a, t), l = this.parseSkeletons(e.skeletons, s); return this.bindSkeletons(s, l), this.bindLightTargets(s), s } parseShapes(e) { const t = {}; if (void 0 !== e) for (let n = 0, r = e.length; n < r; n++) { const r = (new Px).fromJSON(e[n]); t[r.uuid] = r } return t } parseSkeletons(e, t) { const n = {}, r = {}; if (t.traverse((function (e) { e.isBone && (r[e.uuid] = e) })), void 0 !== e) for (let t = 0, i = e.length; t < i; t++) { const i = (new Ky).fromJSON(e[t], r); n[i.uuid] = i } return n } parseGeometries(e, t) { const n = {}; if (void 0 !== e) { const r = new IS; for (let i = 0, a = e.length; i < a; i++) { let a; const o = e[i]; switch (o.type) { case "BufferGeometry": case "InstancedBufferGeometry": a = r.parse(o); break; default: o.type in bA ? a = bA[o.type].fromJSON(o, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`) }a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), void 0 !== o.userData && (a.userData = o.userData), n[o.uuid] = a } } return n } parseMaterials(e, t) { const n = {}, r = {}; if (void 0 !== e) { const i = new TS; i.setTextures(t); for (let t = 0, a = e.length; t < a; t++) { const a = e[t]; void 0 === n[a.uuid] && (n[a.uuid] = i.parse(a)), r[a.uuid] = n[a.uuid] } } return r } parseAnimations(e) { const t = {}; if (void 0 !== e) for (let n = 0; n < e.length; n++) { const r = e[n], i = YA.parse(r); t[i.uuid] = i } return t } parseImages(e, t) { const n = this, r = {}; let i; function a(e) { if ("string" == typeof e) { const t = e; return function (e) { return n.manager.itemStart(e), i.load(e, (function () { n.manager.itemEnd(e) }), void 0, (function () { n.manager.itemError(e), n.manager.itemEnd(e) })) }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t) } return e.data ? { data: mh(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { const n = new qA(t); i = new aS(n), i.setCrossOrigin(this.crossOrigin); for (let t = 0, n = e.length; t < n; t++) { const n = e[t], i = n.url; if (Array.isArray(i)) { const e = []; for (let t = 0, n = i.length; t < n; t++) { const n = a(i[t]); null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new Jy(n.data, n.width, n.height))) } r[n.uuid] = new Bh(e) } else { const e = a(n.url); r[n.uuid] = new Bh(e) } } } return r } async parseImagesAsync(e) { const t = this, n = {}; let r; async function i(e) { if ("string" == typeof e) { const n = e, i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n; return await r.loadAsync(i) } return e.data ? { data: mh(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { r = new aS(this.manager), r.setCrossOrigin(this.crossOrigin); for (let t = 0, r = e.length; t < r; t++) { const r = e[t], a = r.url; if (Array.isArray(a)) { const e = []; for (let t = 0, n = a.length; t < n; t++) { const n = a[t], r = await i(n); null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new Jy(r.data, r.width, r.height))) } n[r.uuid] = new Bh(e) } else { const e = await i(r.url); n[r.uuid] = new Bh(e) } } } return n } parseTextures(e, t) { function n(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } const r = {}; if (void 0 !== e) for (let i = 0, a = e.length; i < a; i++) { const a = e[i]; void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image); const o = t[a.image], s = o.data; let l; Array.isArray(s) ? (l = new pm, 6 === s.length && (l.needsUpdate = !0)) : (l = s && s.data ? new Jy : new Lh, s && (l.needsUpdate = !0)), l.source = o, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = n(a.mapping, LS)), void 0 !== a.channel && (l.channel = a.channel), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = n(a.wrap[0], DS), l.wrapT = n(a.wrap[1], DS)), void 0 !== a.format && (l.format = a.format), void 0 !== a.internalFormat && (l.internalFormat = a.internalFormat), void 0 !== a.type && (l.type = a.type), void 0 !== a.colorSpace && (l.colorSpace = a.colorSpace), void 0 !== a.minFilter && (l.minFilter = n(a.minFilter, kS)), void 0 !== a.magFilter && (l.magFilter = n(a.magFilter, kS)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), void 0 !== a.generateMipmaps && (l.generateMipmaps = a.generateMipmaps), void 0 !== a.premultiplyAlpha && (l.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (l.unpackAlignment = a.unpackAlignment), void 0 !== a.compareFunction && (l.compareFunction = a.compareFunction), void 0 !== a.userData && (l.userData = a.userData), r[a.uuid] = l } return r } parseObject(e, t, n, r, i) { let a, o, s; function l(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function c(e) { if (void 0 !== e) { if (Array.isArray(e)) { const t = []; for (let r = 0, i = e.length; r < i; r++) { const i = e[r]; void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i]) } return t } return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e] } } function u(e) { return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e] } switch (e.type) { case "Scene": a = new py, void 0 !== e.background && (Number.isInteger(e.background) ? a.background = new df(e.background) : a.background = u(e.background)), void 0 !== e.environment && (a.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new hy(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new dy(e.fog.color, e.fog.density)), "" !== e.fog.name && (a.fog.name = e.fog.name)), void 0 !== e.backgroundBlurriness && (a.backgroundBlurriness = e.backgroundBlurriness), void 0 !== e.backgroundIntensity && (a.backgroundIntensity = e.backgroundIntensity), void 0 !== e.backgroundRotation && a.backgroundRotation.fromArray(e.backgroundRotation), void 0 !== e.environmentIntensity && (a.environmentIntensity = e.environmentIntensity), void 0 !== e.environmentRotation && a.environmentRotation.fromArray(e.environmentRotation); break; case "PerspectiveCamera": a = new um(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view)); break; case "OrthographicCamera": a = new Fm(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.view && (a.view = Object.assign({}, e.view)); break; case "AmbientLight": a = new wS(e.color, e.intensity); break; case "DirectionalLight": a = new MS(e.color, e.intensity), a.target = e.target || ""; break; case "PointLight": a = new AS(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": a = new _S(e.color, e.intensity, e.width, e.height); break; case "SpotLight": a = new gS(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), a.target = e.target || ""; break; case "HemisphereLight": a = new uS(e.color, e.groundColor, e.intensity); break; case "LightProbe": a = (new CS).fromJSON(e); break; case "SkinnedMesh": o = l(e.geometry), s = c(e.material), a = new Wy(o, s), void 0 !== e.bindMode && (a.bindMode = e.bindMode), void 0 !== e.bindMatrix && a.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (a.skeleton = e.skeleton); break; case "Mesh": o = l(e.geometry), s = c(e.material), a = new Zf(o, s); break; case "InstancedMesh": o = l(e.geometry), s = c(e.material); const t = e.count, n = e.instanceMatrix, r = e.instanceColor; a = new ab(o, s, t), a.instanceMatrix = new qy(new Float32Array(n.array), 16), void 0 !== r && (a.instanceColor = new qy(new Float32Array(r.array), r.itemSize)); break; case "BatchedMesh": o = l(e.geometry), s = c(e.material), a = new wb(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, s), a.geometry = o, a.perObjectFrustumCulled = e.perObjectFrustumCulled, a.sortObjects = e.sortObjects, a._drawRanges = e.drawRanges, a._reservedRanges = e.reservedRanges, a._visibility = e.visibility, a._active = e.active, a._bounds = e.bounds.map((e => { const t = new Wh; t.min.fromArray(e.boxMin), t.max.fromArray(e.boxMax); const n = new cp; return n.radius = e.sphereRadius, n.center.fromArray(e.sphereCenter), { boxInitialized: e.boxInitialized, box: t, sphereInitialized: e.sphereInitialized, sphere: n } })), a._maxInstanceCount = e.maxInstanceCount, a._maxVertexCount = e.maxVertexCount, a._maxIndexCount = e.maxIndexCount, a._geometryInitialized = e.geometryInitialized, a._geometryCount = e.geometryCount, a._matricesTexture = u(e.matricesTexture.uuid), void 0 !== e.colorsTexture && (a._colorsTexture = u(e.colorsTexture.uuid)); break; case "LOD": a = new ky; break; case "Line": a = new Lb(l(e.geometry), c(e.material)); break; case "LineLoop": a = new Ob(l(e.geometry), c(e.material)); break; case "LineSegments": a = new Fb(l(e.geometry), c(e.material)); break; case "PointCloud": case "Points": a = new Vb(l(e.geometry), c(e.material)); break; case "Sprite": a = new Iy(c(e.material)); break; case "Group": a = new ty; break; case "Bone": a = new Xy; break; default: a = new Wp }if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.up && a.up.fromArray(e.up), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.intensity && (a.shadow.intensity = e.shadow.intensity), void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (a.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children) { const o = e.children; for (let e = 0; e < o.length; e++)a.add(this.parseObject(o[e], t, n, r, i)) } if (void 0 !== e.animations) { const t = e.animations; for (let e = 0; e < t.length; e++) { const n = t[e]; a.animations.push(i[n]) } } if ("LOD" === e.type) { void 0 !== e.autoUpdate && (a.autoUpdate = e.autoUpdate); const t = e.levels; for (let e = 0; e < t.length; e++) { const n = t[e], r = a.getObjectByProperty("uuid", n.object); void 0 !== r && a.addLevel(r, n.distance, n.hysteresis) } } return a } bindSkeletons(e, t) { 0 !== Object.keys(t).length && e.traverse((function (e) { if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) { const n = t[e.skeleton]; void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix) } })) } bindLightTargets(e) { e.traverse((function (t) { if (t.isDirectionalLight || t.isSpotLight) { const n = t.target, r = e.getObjectByProperty("uuid", n); t.target = void 0 !== r ? r : new Wp } })) } } const LS = { UVMapping: yc, CubeReflectionMapping: bc, CubeRefractionMapping: xc, EquirectangularReflectionMapping: Ac, EquirectangularRefractionMapping: Sc, CubeUVReflectionMapping: Mc }, DS = { RepeatWrapping: wc, ClampToEdgeWrapping: _c, MirroredRepeatWrapping: Ec }, kS = { NearestFilter: Cc, NearestMipmapNearestFilter: Tc, NearestMipmapLinearFilter: Bc, LinearFilter: Pc, LinearMipmapNearestFilter: Lc, LinearMipmapLinearFilter: kc }; class NS extends $A { constructor(e) { super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, n, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const i = this, a = KA.get(e); if (void 0 !== a) return i.manager.itemStart(e), a.then ? void a.then((n => { t && t(n), i.manager.itemEnd(e) })).catch((e => { r && r(e) })) : (setTimeout((function () { t && t(a), i.manager.itemEnd(e) }), 0), a); const o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader; const s = fetch(e, o).then((function (e) { return e.blob() })).then((function (e) { return createImageBitmap(e, Object.assign(i.options, { colorSpaceConversion: "none" })) })).then((function (n) { return KA.add(e, n), t && t(n), i.manager.itemEnd(e), n })).catch((function (t) { r && r(t), KA.remove(e), i.manager.itemError(e), i.manager.itemEnd(e) })); KA.add(e, s), i.manager.itemStart(e) } } let FS; class OS { static getContext() { return void 0 === FS && (FS = new (window.AudioContext || window.webkitAudioContext)), FS } static setContext(e) { FS = e } } class US extends $A { constructor(e) { super(e) } load(e, t, n, r) { const i = this, a = new nS(this.manager); function o(t) { r ? r(t) : console.error(t), i.manager.itemError(e) } a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (e) { try { const n = e.slice(0); OS.getContext().decodeAudioData(n, (function (e) { t(e) })).catch(o) } catch (e) { o(e) } }), n, r) } } const zS = new yp, HS = new yp, GS = new yp; class jS { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new um, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new um, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, GS.copy(e.projectionMatrix); const n = t.eyeSep / 2, r = n * t.near / t.focus, i = t.near * Math.tan(th * t.fov * .5) / t.zoom; let a, o; HS.elements[12] = -n, zS.elements[12] = n, a = -i * t.aspect + r, o = i * t.aspect + r, GS.elements[0] = 2 * t.near / (o - a), GS.elements[8] = (o + a) / (o - a), this.cameraL.projectionMatrix.copy(GS), a = -i * t.aspect - r, o = i * t.aspect - r, GS.elements[0] = 2 * t.near / (o - a), GS.elements[8] = (o + a) / (o - a), this.cameraR.projectionMatrix.copy(GS) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(HS), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(zS) } } class VS { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = WS(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = WS(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function WS() { return performance.now() } const XS = new Gh, JS = new Hh, YS = new Gh, QS = new Gh; class KS extends Wp { constructor() { super(), this.type = "AudioListener", this.context = OS.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new VS } getInput() { return this.gain } removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, n = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(XS, JS, YS), QS.set(0, 0, -1).applyQuaternion(JS), t.positionX) { const e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(XS.x, e), t.positionY.linearRampToValueAtTime(XS.y, e), t.positionZ.linearRampToValueAtTime(XS.z, e), t.forwardX.linearRampToValueAtTime(QS.x, e), t.forwardY.linearRampToValueAtTime(QS.y, e), t.forwardZ.linearRampToValueAtTime(QS.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e) } else t.setPosition(XS.x, XS.y, XS.z), t.setOrientation(QS.x, QS.y, QS.z, n.x, n.y, n.z) } } class qS extends Wp { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop(e = 0) { if (!1 !== this.hasPlaybackControl) return this._progress = 0, null !== this.source && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (!1 !== this._connected) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { return this.detune = e, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const ZS = new Gh, $S = new Hh, eM = new Gh, tM = new Gh; class nM extends qS { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { super.connect(), this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, n) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return; this.matrixWorld.decompose(ZS, $S, eM), tM.set(0, 0, 1).applyQuaternion($S); const t = this.panner; if (t.positionX) { const e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(ZS.x, e), t.positionY.linearRampToValueAtTime(ZS.y, e), t.positionZ.linearRampToValueAtTime(ZS.z, e), t.orientationX.linearRampToValueAtTime(tM.x, e), t.orientationY.linearRampToValueAtTime(tM.y, e), t.orientationZ.linearRampToValueAtTime(tM.z, e) } else t.setPosition(ZS.x, ZS.y, ZS.z), t.setOrientation(tM.x, tM.y, tM.z) } } class rM { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let n = 0; n < t.length; n++)e += t[n]; return e / t.length } } class iM { constructor(e, t, n) { let r, i, a; switch (this.binding = e, this.valueSize = n, t) { case "quaternion": r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const n = this.buffer, r = this.valueSize, i = e * r + r; let a = this.cumulativeWeight; if (0 === a) { for (let e = 0; e !== r; ++e)n[i + e] = n[e]; a = t } else { a += t; const e = t / a; this._mixBufferRegion(n, i, 0, e, r) } this.cumulativeWeight = a } accumulateAdditive(e) { const t = this.buffer, n = this.valueSize, r = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, n = this.buffer, r = e * t + t, i = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) { const e = t * this._origIndex; this._mixBufferRegion(n, r, e, 1 - i, t) } a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t); for (let e = t, i = t + t; e !== i; ++e)if (n[e] !== n[e + t]) { o.setValue(n, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex; e.getValue(t, r); for (let e = n, i = r; e !== i; ++e)t[e] = t[r + e % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let n = e; n < t; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n] } _select(e, t, n, r, i) { if (r >= .5) for (let r = 0; r !== i; ++r)e[t + r] = e[n + r] } _slerp(e, t, n, r) { Hh.slerpFlat(e, t, e, t, e, n, r) } _slerpAdditive(e, t, n, r, i) { const a = this._workIndex * i; Hh.multiplyQuaternionsFlat(e, a, e, t, e, n), Hh.slerpFlat(e, t, e, t, e, a, r) } _lerp(e, t, n, r, i) { const a = 1 - r; for (let o = 0; o !== i; ++o) { const i = t + o; e[i] = e[i] * a + e[n + o] * r } } _lerpAdditive(e, t, n, r, i) { for (let a = 0; a !== i; ++a) { const i = t + a; e[i] = e[i] + e[n + a] * r } } } const aM = "\\[\\]\\.:\\/", oM = new RegExp("[" + aM + "]", "g"), sM = "[^" + aM + "]", lM = "[^" + aM.replace("\\.", "") + "]", cM = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", sM) + /(WCOD+)?/.source.replace("WCOD", lM) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", sM) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", sM) + "$"), uM = ["material", "materials", "bones", "map"]; class dM { constructor(e, t, n) { this.path = t, this.parsedPath = n || dM.parseTrackName(t), this.node = dM.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return e && e.isAnimationObjectGroup ? new dM.Composite(e, t, n) : new dM(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(oM, "") } static parseTrackName(e) { const t = cM.exec(e); if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const e = n.nodeName.substring(r + 1); -1 !== uM.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, t) { if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { const n = function (e) { for (let r = 0; r < e.length; r++) { const i = e[r]; if (i.name === t || i.uuid === t) return i; const a = n(i.children); if (a) return a } return null }, r = n(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)e[t++] = n[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, n = t.objectName, r = t.propertyName; let i = t.propertyIndex; if (e || (e = dM.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); if (n) { let r = t.objectIndex; switch (n) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === r) { r = t; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); e = e.material.map; break; default: if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[n] }if (void 0 !== r) { if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[r] } } const a = e[r]; if (void 0 === a) { const n = t.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e) } let o = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate); let s = this.BindingType.Direct; if (void 0 !== i) { if ("morphTargetInfluences" === r) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i]) } s = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = i } else void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r; this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][o] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } dM.Composite = class { constructor(e, t, n) { const r = n || dM.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; void 0 !== r && r.getValue(e, t) } setValue(e, t) { const n = this._bindings; for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)n[r].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } }, dM.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, dM.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, dM.prototype.GetterByBindingType = [dM.prototype._getValue_direct, dM.prototype._getValue_array, dM.prototype._getValue_arrayElement, dM.prototype._getValue_toArray], dM.prototype.SetterByBindingTypeAndVersioning = [[dM.prototype._setValue_direct, dM.prototype._setValue_direct_setNeedsUpdate, dM.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [dM.prototype._setValue_array, dM.prototype._setValue_array_setNeedsUpdate, dM.prototype._setValue_array_setMatrixWorldNeedsUpdate], [dM.prototype._setValue_arrayElement, dM.prototype._setValue_arrayElement_setNeedsUpdate, dM.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [dM.prototype._setValue_fromArray, dM.prototype._setValue_fromArray_setNeedsUpdate, dM.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class hM { constructor() { this.isAnimationObjectGroup = !0, this.uuid = rh(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let t = 0, n = arguments.length; t !== n; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, a = i.length; let o, s = e.length, l = this.nCachedObjects_; for (let c = 0, u = arguments.length; c !== u; ++c) { const u = arguments[c], d = u.uuid; let h = t[d]; if (void 0 === h) { h = s++, t[d] = h, e.push(u); for (let e = 0, t = a; e !== t; ++e)i[e].push(new dM(u, n[e], r[e])) } else if (h < l) { o = e[h]; const s = --l, c = e[s]; t[c.uuid] = h, e[h] = c, t[d] = s, e[s] = u; for (let e = 0, t = a; e !== t; ++e) { const t = i[e], a = t[s]; let o = t[h]; t[h] = a, void 0 === o && (o = new dM(u, n[e], r[e])), t[s] = o } } else e[h] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = l } remove() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let i = this.nCachedObjects_; for (let a = 0, o = arguments.length; a !== o; ++a) { const o = arguments[a], s = o.uuid, l = t[s]; if (void 0 !== l && l >= i) { const a = i++, c = e[a]; t[c.uuid] = l, e[l] = c, t[s] = a, e[a] = o; for (let e = 0, t = r; e !== t; ++e) { const t = n[e], r = t[a], i = t[l]; t[l] = r, t[a] = i } } } this.nCachedObjects_ = i } uncache() { const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length; let i = this.nCachedObjects_, a = e.length; for (let o = 0, s = arguments.length; o !== s; ++o) { const s = arguments[o].uuid, l = t[s]; if (void 0 !== l) if (delete t[s], l < i) { const o = --i, s = e[o], c = --a, u = e[c]; t[s.uuid] = l, e[l] = s, t[u.uuid] = o, e[o] = u, e.pop(); for (let e = 0, t = r; e !== t; ++e) { const t = n[e], r = t[o], i = t[c]; t[l] = r, t[o] = i, t.pop() } } else { const i = --a, o = e[i]; i > 0 && (t[o.uuid] = l), e[l] = o, e.pop(); for (let e = 0, t = r; e !== t; ++e) { const t = n[e]; t[l] = t[i], t.pop() } } } this.nCachedObjects_ = i } subscribe_(e, t) { const n = this._bindingsIndicesByPath; let r = n[e]; const i = this._bindings; if (void 0 !== r) return i[r]; const a = this._paths, o = this._parsedPaths, s = this._objects, l = s.length, c = this.nCachedObjects_, u = new Array(l); r = i.length, n[e] = r, a.push(e), o.push(t), i.push(u); for (let n = c, r = s.length; n !== r; ++n) { const r = s[n]; u[n] = new dM(r, e, t) } return u } unsubscribe_(e) { const t = this._bindingsIndicesByPath, n = t[e]; if (void 0 !== n) { const r = this._paths, i = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o]; t[e[o]] = n, a[n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop() } } } class pM { constructor(e, t, n = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r; const i = t.tracks, a = i.length, o = new Array(a), s = { endingStart: Xu, endingEnd: Xu }; for (let e = 0; e !== a; ++e) { const t = i[e].createInterpolant(null); o[e] = t, t.settings = s } this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Hu, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { const n = this._clip.duration, r = e._clip.duration, i = r / n, a = n / r; e.warp(1, i, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, n) { return e.crossFadeFrom(this, t, n) } stopFading() { const e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, n) { const r = this._mixer, i = r.time, a = this.timeScale; let o = this._timeScaleInterpolant; null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o); const s = o.parameterPositions, l = o.sampleValues; return s[0] = i, s[1] = i + n, l[0] = e / a, l[1] = t / a, this } stopWarping() { const e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, n, r) { if (!this.enabled) return void this._updateWeight(e); const i = this._startTime; if (null !== i) { const r = (e - i) * n; r < 0 || 0 === n ? t = 0 : (this._startTime = null, t = n * r) } t *= this._updateTimeScale(e); const a = this._updateTime(t), o = this._updateWeight(e); if (o > 0) { const e = this._interpolants, t = this._propertyBindings; if (this.blendMode === Ku) for (let n = 0, r = e.length; n !== r; ++n)e[n].evaluate(a), t[n].accumulateAdditive(o); else for (let n = 0, i = e.length; n !== i; ++n)e[n].evaluate(a), t[n].accumulate(r, o) } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const n = this._weightInterpolant; if (null !== n) { const r = n.evaluate(e)[0]; t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const n = this._timeScaleInterpolant; null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)) } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, n = this.loop; let r = this.time + e, i = this._loopCount; const a = n === Gu; if (0 === e) return -1 === i || !a || 1 & ~i ? r : t - r; if (n === zu) { -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else { if (!(r < 0)) { this.time = r; break e } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) { const n = Math.floor(r / t); r -= t * n, i += Math.abs(n); const o = this.repetitions - i; if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === o) { const t = e < 0; this._setEndings(t, !t, a) } else this._setEndings(!1, !1, a); this._loopCount = i, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = r; if (a && !(1 & ~i)) return t - r } return r } _setEndings(e, t, n) { const r = this._interpolantSettings; n ? (r.endingStart = Ju, r.endingEnd = Ju) : (r.endingStart = e ? this.zeroSlopeAtStart ? Ju : Xu : Yu, r.endingEnd = t ? this.zeroSlopeAtEnd ? Ju : Xu : Yu) } _scheduleFading(e, t, n) { const r = this._mixer, i = r.time; let a = this._weightInterpolant; null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a); const o = a.parameterPositions, s = a.sampleValues; return o[0] = i, s[0] = t, o[1] = i + e, s[1] = n, this } } const fM = new Float32Array(1); class mM extends Zd { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const n = e._localRoot || this._root, r = e._clip.tracks, i = r.length, a = e._propertyBindings, o = e._interpolants, s = n.uuid, l = this._bindingsByRootAndName; let c = l[s]; void 0 === c && (c = {}, l[s] = c); for (let e = 0; e !== i; ++e) { const i = r[e], l = i.name; let u = c[l]; if (void 0 !== u) ++u.referenceCount, a[e] = u; else { if (u = a[e], void 0 !== u) { null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, s, l)); continue } const r = t && t._propertyBindings[e].binding.parsedPath; u = new iM(dM.create(n, l, r), i.ValueTypeName, i.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, s, l), a[e] = u } o[e].resultBuffer = u.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { const t = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n]; this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t) } const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, n) { const r = this._actions, i = this._actionsByClip; let a = i[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, i[t] = a; else { const t = a.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e } _removeInactiveAction(e) { const t = this._actions, n = t[t.length - 1], r = e._cacheIndex; n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null; const i = e._clip.uuid, a = this._actionsByClip, o = a[i], s = o.knownActions, l = s[s.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } } _lendAction(e) { const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _takeBackAction(e) { const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _addInactiveBinding(e, t, n) { const r = this._bindingsByRootAndName, i = this._bindings; let a = r[t]; void 0 === a && (a = {}, r[t] = a), a[n] = e, e._cacheIndex = i.length, i.push(e) } _removeInactiveBinding(e) { const t = this._bindings, n = e.binding, r = n.rootNode.uuid, i = n.path, a = this._bindingsByRootAndName, o = a[r], s = t[t.length - 1], l = e._cacheIndex; s._cacheIndex = l, t[l] = s, t.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r] } _lendBinding(e) { const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _takeBackBinding(e) { const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let n = e[t]; return void 0 === n && (n = new OA(new Float32Array(2), new Float32Array(2), 1, fM), n.__cacheIndex = t, e[t] = n), n } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, i = t[r]; e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i } clipAction(e, t, n) { const r = t || this._root, i = r.uuid; let a = "string" == typeof e ? YA.findByName(r, e) : e; const o = null !== a ? a.uuid : e, s = this._actionsByClip[o]; let l = null; if (void 0 === n && (n = null !== a ? a.blendMode : Qu), void 0 !== s) { const e = s.actionByRoot[i]; if (void 0 !== e && e.blendMode === n) return e; l = s.knownActions[0], null === a && (a = l._clip) } if (null === a) return null; const c = new pM(this, a, t, n); return this._bindAction(c, l), this._addInactiveAction(c, o, i), c } existingAction(e, t) { const n = t || this._root, r = n.uuid, i = "string" == typeof e ? YA.findByName(n, e) : e, a = i ? i.uuid : e, o = this._actionsByClip[a]; return void 0 !== o && o.actionByRoot[r] || null } stopAllAction() { const e = this._actions; for (let t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1; for (let o = 0; o !== n; ++o)t[o]._update(r, e, i, a); const o = this._bindings, s = this._nActiveBindings; for (let e = 0; e !== s; ++e)o[e].apply(a); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, n = e.uuid, r = this._actionsByClip, i = r[n]; if (void 0 !== i) { const e = i.knownActions; for (let n = 0, r = e.length; n !== r; ++n) { const r = e[n]; this._deactivateAction(r); const i = r._cacheIndex, a = t[t.length - 1]; r._cacheIndex = null, r._byClipCacheIndex = null, a._cacheIndex = i, t[i] = a, t.pop(), this._removeInactiveBindingsForAction(r) } delete r[n] } } uncacheRoot(e) { const t = e.uuid, n = this._actionsByClip; for (const e in n) { const r = n[e].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } const r = this._bindingsByRootAndName[t]; if (void 0 !== r) for (const e in r) { const t = r[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { const n = this.existingAction(e, t); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } } class gM { constructor(e) { this.value = e } clone() { return new gM(void 0 === this.value.clone ? this.value : this.value.clone()) } } let vM = 0; class yM extends Zd { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: vM++ }), this.name = "", this.usage = Ud, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return -1 !== t && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let e = 0, n = t.length; e < n; e++) { const n = Array.isArray(t[e]) ? t[e] : [t[e]]; for (let e = 0; e < n.length; e++)this.uniforms.push(n[e].clone()) } return this } clone() { return (new this.constructor).copy(this) } } class bM extends fy { constructor(e, t, n = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class xM { constructor(e, t, n, r, i) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } const AM = new yp; class SM { constructor(e, t, n = 0, r = 1 / 0) { this.ray = new vp(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Rp, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } setFromXRController(e) { return AM.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(AM), this } intersectObject(e, t = !0, n = []) { return wM(e, this, n, t), n.sort(MM), n } intersectObjects(e, t = !0, n = []) { for (let r = 0, i = e.length; r < i; r++)wM(e[r], this, n, t); return n.sort(MM), n } } function MM(e, t) { return e.distance - t.distance } function wM(e, t, n, r) { let i = !0; if (e.layers.test(t.layers) && !1 === e.raycast(t, n) && (i = !1), !0 === i && !0 === r) { const r = e.children; for (let e = 0, i = r.length; e < i; e++)wM(r[e], t, n, !0) } } class _M { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.phi = t, this.theta = n, this } set(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { const e = 1e-6; return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(ih(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } class EM { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.theta = t, this.y = n, this } set(e, t, n) { return this.radius = e, this.theta = t, this.y = n, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this } clone() { return (new this.constructor).copy(this) } } class CM { constructor(e, t, n, r) { CM.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], void 0 !== e && this.set(e, t, n, r) } identity() { return this.set(1, 0, 0, 1), this } fromArray(e, t = 0) { for (let n = 0; n < 4; n++)this.elements[n] = e[n + t]; return this } set(e, t, n, r) { const i = this.elements; return i[0] = e, i[2] = t, i[1] = n, i[3] = r, this } } const TM = new uh; class RM { constructor(e = new uh(1 / 0, 1 / 0), t = new uh(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = TM.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, TM).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const BM = new Gh, IM = new Gh; class PM { constructor(e = new Gh, t = new Gh) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { BM.subVectors(e, this.start), IM.subVectors(this.end, this.start); const n = IM.dot(IM); let r = IM.dot(BM) / n; return t && (r = ih(r, 0, 1)), r } closestPointToPoint(e, t, n) { const r = this.closestPointToPointParameter(e, t); return this.delta(n).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } } const LM = new Gh; class DM extends Wp { constructor(e, t) { super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const n = new zf, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let e = 0, t = 1, n = 32; e < n; e++, t++) { const i = e / n * Math.PI * 2, a = t / n * Math.PI * 2; r.push(Math.cos(i), Math.sin(i), 1, Math.cos(a), Math.sin(a), 1) } n.setAttribute("position", new Pf(r, 3)); const i = new _b({ fog: !1, toneMapped: !1 }); this.cone = new Fb(n, i), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), LM.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(LM), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const kM = new Gh, NM = new yp, FM = new yp; class OM extends Fb { constructor(e) { const t = UM(e), n = new zf, r = [], i = [], a = new df(0, 0, 1), o = new df(0, 1, 0); for (let e = 0; e < t.length; e++) { const n = t[e]; n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(o.r, o.g, o.b)) } n.setAttribute("position", new Pf(r, 3)), n.setAttribute("color", new Pf(i, 3)), super(n, new _b({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, n = this.geometry, r = n.getAttribute("position"); FM.copy(this.root.matrixWorld).invert(); for (let e = 0, n = 0; e < t.length; e++) { const i = t[e]; i.parent && i.parent.isBone && (NM.multiplyMatrices(FM, i.matrixWorld), kM.setFromMatrixPosition(NM), r.setXYZ(n, kM.x, kM.y, kM.z), NM.multiplyMatrices(FM, i.parent.matrixWorld), kM.setFromMatrixPosition(NM), r.setXYZ(n + 1, kM.x, kM.y, kM.z), n += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function UM(e) { const t = []; !0 === e.isBone && t.push(e); for (let n = 0; n < e.children.length; n++)t.push.apply(t, UM(e.children[n])); return t } class zM extends Zf { constructor(e, t, n) { super(new hA(t, 4, 2), new mf({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const HM = new Gh, GM = new df, jM = new df; class VM extends Wp { constructor(e, t, n) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper"; const r = new cA(t); r.rotateY(.5 * Math.PI), this.material = new mf({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); const i = r.getAttribute("position"), a = new Float32Array(3 * i.count); r.setAttribute("color", new Mf(a, 3)), this.add(new Zf(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); GM.copy(this.light.color), jM.copy(this.light.groundColor); for (let e = 0, n = t.count; e < n; e++) { const r = e < n / 2 ? GM : jM; t.setXYZ(e, r.r, r.g, r.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(HM.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class WM extends Fb { constructor(e = 10, t = 10, n = 4473924, r = 8947848) { n = new df(n), r = new df(r); const i = t / 2, a = e / t, o = e / 2, s = [], l = []; for (let e = 0, c = 0, u = -o; e <= t; e++, u += a) { s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o); const t = e === i ? n : r; t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3 } const c = new zf; c.setAttribute("position", new Pf(s, 3)), c.setAttribute("color", new Pf(l, 3)), super(c, new _b({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class XM extends Fb { constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, a = 8947848) { i = new df(i), a = new df(a); const o = [], s = []; if (t > 1) for (let n = 0; n < t; n++) { const r = n / t * (2 * Math.PI), l = Math.sin(r) * e, c = Math.cos(r) * e; o.push(0, 0, 0), o.push(l, 0, c); const u = 1 & n ? i : a; s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b) } for (let t = 0; t < n; t++) { const l = 1 & t ? i : a, c = e - e / n * t; for (let e = 0; e < r; e++) { let t = e / r * (2 * Math.PI), n = Math.sin(t) * c, i = Math.cos(t) * c; o.push(n, 0, i), s.push(l.r, l.g, l.b), t = (e + 1) / r * (2 * Math.PI), n = Math.sin(t) * c, i = Math.cos(t) * c, o.push(n, 0, i), s.push(l.r, l.g, l.b) } } const l = new zf; l.setAttribute("position", new Pf(o, 3)), l.setAttribute("color", new Pf(s, 3)), super(l, new _b({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const JM = new Gh, YM = new Gh, QM = new Gh; class KM extends Wp { constructor(e, t, n) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", void 0 === t && (t = 1); let r = new zf; r.setAttribute("position", new Pf([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const i = new _b({ fog: !1, toneMapped: !1 }); this.lightPlane = new Lb(r, i), this.add(this.lightPlane), r = new zf, r.setAttribute("position", new Pf([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Lb(r, i), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), JM.setFromMatrixPosition(this.light.matrixWorld), YM.setFromMatrixPosition(this.light.target.matrixWorld), QM.subVectors(YM, JM), this.lightPlane.lookAt(YM), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(YM), this.targetLine.scale.z = QM.length() } } const qM = new Gh, ZM = new om; class $M extends Fb { constructor(e) { const t = new zf, n = new _b({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], i = [], a = {}; function o(e, t) { s(e), s(t) } function s(e) { r.push(0, 0, 0), i.push(0, 0, 0), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1) } o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), t.setAttribute("position", new Pf(r, 3)), t.setAttribute("color", new Pf(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update(); const l = new df(16755200), c = new df(16711680), u = new df(43775), d = new df(16777215), h = new df(3355443); this.setColors(l, c, u, d, h) } setColors(e, t, n, r, i) { const a = this.geometry.getAttribute("color"); a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, i.r, i.g, i.b), a.setXYZ(41, i.r, i.g, i.b), a.setXYZ(42, i.r, i.g, i.b), a.setXYZ(43, i.r, i.g, i.b), a.setXYZ(44, i.r, i.g, i.b), a.setXYZ(45, i.r, i.g, i.b), a.setXYZ(46, i.r, i.g, i.b), a.setXYZ(47, i.r, i.g, i.b), a.setXYZ(48, i.r, i.g, i.b), a.setXYZ(49, i.r, i.g, i.b), a.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap; ZM.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), ew("c", t, e, ZM, 0, 0, -1), ew("t", t, e, ZM, 0, 0, 1), ew("n1", t, e, ZM, -1, -1, -1), ew("n2", t, e, ZM, 1, -1, -1), ew("n3", t, e, ZM, -1, 1, -1), ew("n4", t, e, ZM, 1, 1, -1), ew("f1", t, e, ZM, -1, -1, 1), ew("f2", t, e, ZM, 1, -1, 1), ew("f3", t, e, ZM, -1, 1, 1), ew("f4", t, e, ZM, 1, 1, 1), ew("u1", t, e, ZM, .7, 1.1, -1), ew("u2", t, e, ZM, -.7, 1.1, -1), ew("u3", t, e, ZM, 0, 2, -1), ew("cf1", t, e, ZM, -1, 0, 1), ew("cf2", t, e, ZM, 1, 0, 1), ew("cf3", t, e, ZM, 0, -1, 1), ew("cf4", t, e, ZM, 0, 1, 1), ew("cn1", t, e, ZM, -1, 0, -1), ew("cn2", t, e, ZM, 1, 0, -1), ew("cn3", t, e, ZM, 0, -1, -1), ew("cn4", t, e, ZM, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function ew(e, t, n, r, i, a, o) { qM.set(i, a, o).unproject(r); const s = t[e]; if (void 0 !== s) { const e = n.getAttribute("position"); for (let t = 0, n = s.length; t < n; t++)e.setXYZ(s[t], qM.x, qM.y, qM.z) } } const tw = new Wh; class nw extends Fb { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), i = new zf; i.setIndex(new Mf(n, 1)), i.setAttribute("position", new Mf(r, 3)), super(i, new _b({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && tw.setFromObject(this.object), tw.isEmpty()) return; const t = tw.min, n = tw.max, r = this.geometry.attributes.position, i = r.array; i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class rw extends Fb { constructor(e, t = 16776960) { const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new zf; r.setIndex(new Mf(n, 1)), r.setAttribute("position", new Pf([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new _b({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class iw extends Lb { constructor(e, t = 1, n = 16776960) { const r = n, i = new zf; i.setAttribute("position", new Pf([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere(), super(i, new _b({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = new zf; a.setAttribute("position", new Pf([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), a.computeBoundingSphere(), this.add(new Zf(a, new mf({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const aw = new Gh; let ow, sw; class lw extends Wp { constructor(e = new Gh(0, 0, 1), t = new Gh(0, 0, 0), n = 1, r = 16776960, i = .2 * n, a = .2 * i) { super(), this.type = "ArrowHelper", void 0 === ow && (ow = new zf, ow.setAttribute("position", new Pf([0, 0, 0, 0, 1, 0], 3)), sw = new Mx(0, .5, 1, 5, 1), sw.translate(0, -.5, 0)), this.position.copy(t), this.line = new Lb(ow, new _b({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Zf(sw, new mf({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, a) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { aw.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(aw, t) } } setLength(e, t = .2 * e, n = .2 * t) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class cw extends Fb { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], n = new zf; n.setAttribute("position", new Pf(t, 3)), n.setAttribute("color", new Pf([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new _b({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } setColors(e, t, n) { const r = new df, i = this.geometry.attributes.color.array; return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class uw { constructor() { this.type = "ShapePath", this.color = new df, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new bx, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, n, r) { return this.currentPath.quadraticCurveTo(e, t, n, r), this } bezierCurveTo(e, t, n, r, i, a) { return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(e, t) { const n = t.length; let r = !1; for (let i = n - 1, a = 0; a < n; i = a++) { let n = t[i], o = t[a], s = o.x - n.x, l = o.y - n.y; if (Math.abs(l) > Number.EPSILON) { if (l < 0 && (n = t[a], s = -s, o = t[i], l = -l), e.y < n.y || e.y > o.y) continue; if (e.y === n.y) { if (e.x === n.x) return !0 } else { const t = l * (e.x - n.x) - s * (e.y - n.y); if (0 === t) return !0; if (t < 0) continue; r = !r } } else { if (e.y !== n.y) continue; if (o.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= o.x) return !0 } } return r } const n = rA.isClockWise, r = this.subPaths; if (0 === r.length) return []; let i, a, o; const s = []; if (1 === r.length) return a = r[0], o = new Px, o.curves = a.curves, s.push(o), s; let l = !n(r[0].getPoints()); l = e ? !l : l; const c = [], u = []; let d, h, p = [], f = 0; u[f] = void 0, p[f] = []; for (let t = 0, o = r.length; t < o; t++)a = r[t], d = a.getPoints(), i = n(d), i = e ? !i : i, i ? (!l && u[f] && f++, u[f] = { s: new Px, p: d }, u[f].s.curves = a.curves, l && f++, p[f] = []) : p[f].push({ h: a, p: d[0] }); if (!u[0]) return function (e) { const t = []; for (let n = 0, r = e.length; n < r; n++) { const r = e[n], i = new Px; i.curves = r.curves, t.push(i) } return t }(r); if (u.length > 1) { let e = !1, n = 0; for (let e = 0, t = u.length; e < t; e++)c[e] = []; for (let r = 0, i = u.length; r < i; r++) { const i = p[r]; for (let a = 0; a < i.length; a++) { const o = i[a]; let s = !0; for (let i = 0; i < u.length; i++)t(o.p, u[i].p) && (r !== i && n++, s ? (s = !1, c[i].push(o)) : e = !0); s && c[r].push(o) } } n > 0 && !1 === e && (p = c) } for (let e = 0, t = u.length; e < t; e++) { o = u[e].s, s.push(o), h = p[e]; for (let e = 0, t = h.length; e < t; e++)o.holes.push(h[e].h) } return s } } class dw extends Zd { constructor(e, t = null) { super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null } } connect() { } disconnect() { } dispose() { } update() { } } class hw extends Nh { constructor(e = 1, t = 1, n = 1, r = {}) { console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...r, count: n }), this.isWebGLMultipleRenderTargets = !0 } get texture() { return this.textures } } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: dl } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = dl); var pw = i(772); const fw = "undefined" == typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent) ? n.useEffect : n.useLayoutEffect; function mw(e) { const t = "function" == typeof e ? function (e) { let t; const n = new Set, r = (e, r) => { const i = "function" == typeof e ? e(t) : e; if (i !== t) { const e = t; t = r ? i : Object.assign({}, t, i), n.forEach((n => n(t, e))) } }, i = () => t, a = { setState: r, getState: i, subscribe: (e, r, a) => r || a ? ((e, r = i, a = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let o = r(t); function s() { const n = r(t); if (!a(o, n)) { const t = o; e(o = n, t) } } return n.add(s), () => n.delete(s) })(e, r, a) : (n.add(e), () => n.delete(e)), destroy: () => n.clear() }; return t = e(r, i, a), a }(e) : e, r = (e = t.getState, r = Object.is) => { const [, i] = (0, n.useReducer)((e => e + 1), 0), a = t.getState(), o = (0, n.useRef)(a), s = (0, n.useRef)(e), l = (0, n.useRef)(r), c = (0, n.useRef)(!1), u = (0, n.useRef)(); let d; void 0 === u.current && (u.current = e(a)); let h = !1; (o.current !== a || s.current !== e || l.current !== r || c.current) && (d = e(a), h = !r(u.current, d)), fw((() => { h && (u.current = d), o.current = a, s.current = e, l.current = r, c.current = !1 })); const p = (0, n.useRef)(a); fw((() => { const e = () => { try { const e = t.getState(), n = s.current(e); l.current(u.current, n) || (o.current = e, u.current = n, i()) } catch (e) { c.current = !0, i() } }, n = t.subscribe(e); return t.getState() !== p.current && e(), n }), []); const f = h ? d : u.current; return (0, n.useDebugValue)(f), f }; return Object.assign(r, t), r[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const e = [r, t]; return { next() { const t = e.length <= 0; return { value: e.shift(), done: t } } } }, r } const gw = []; function vw(e, t, n = (e, t) => e === t) { if (e === t) return !0; if (!e || !t) return !1; const r = e.length; if (t.length !== r) return !1; for (let i = 0; i < r; i++)if (!n(e[i], t[i])) return !1; return !0 } function yw(e, t = null, n = !1, r = {}) { null === t && (t = [e]); for (const e of gw) if (vw(t, e.keys, e.equal)) { if (n) return; if (Object.prototype.hasOwnProperty.call(e, "error")) throw e.error; if (Object.prototype.hasOwnProperty.call(e, "response")) return r.lifespan && r.lifespan > 0 && (e.timeout && clearTimeout(e.timeout), e.timeout = setTimeout(e.remove, r.lifespan)), e.response; if (!n) throw e.promise } const i = { keys: t, equal: r.equal, remove: () => { const e = gw.indexOf(i); -1 !== e && gw.splice(e, 1) }, promise: (a = e, "object" == typeof a && "function" == typeof a.then ? e : e(...t)).then((e => { i.response = e, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan)) })).catch((e => i.error = e)) }; var a; if (gw.push(i), !n) throw i.promise } var bw = i(845), xw = i.n(bw), Aw = i(982); const Sw = {}, Mw = e => { Object.assign(Sw, e) }; var ww, _w; const Ew = e => "colorSpace" in e || "outputColorSpace" in e, Cw = () => { var e; return null != (e = Sw.ColorManagement) ? e : null }, Tw = e => e && e.isOrthographicCamera, Rw = "undefined" != typeof window && (null != (ww = window.document) && ww.createElement || "ReactNative" === (null == (_w = window.navigator) ? void 0 : _w.product)) ? n.useLayoutEffect : n.useEffect; function Bw(e) { const t = n.useRef(e); return Rw((() => { t.current = e }), [e]), t } function Iw({ set: e }) { return Rw((() => (e(new Promise((() => null))), () => e(!1))), [e]), null } class Pw extends n.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } Pw.getDerivedStateFromError = () => ({ error: !0 }); const Lw = "__default", Dw = new Map; function kw(e) { var t; const n = "undefined" != typeof window ? null != (t = window.devicePixelRatio) ? t : 2 : 1; return Array.isArray(e) ? Math.min(Math.max(e[0], n), e[1]) : e } const Nw = e => { var t; return null == (t = e.__r3f) ? void 0 : t.root.getState() }; function Fw(e) { let t = e.__r3f.root; for (; t.getState().previousRoot;)t = t.getState().previousRoot; return t } const Ow = { obj: e => e === Object(e) && !Ow.arr(e) && "function" != typeof e, fun: e => "function" == typeof e, str: e => "string" == typeof e, num: e => "number" == typeof e, boo: e => "boolean" == typeof e, und: e => void 0 === e, arr: e => Array.isArray(e), equ(e, t, { arrays: n = "shallow", objects: r = "reference", strict: i = !0 } = {}) { if (typeof e != typeof t || !!e != !!t) return !1; if (Ow.str(e) || Ow.num(e) || Ow.boo(e)) return e === t; const a = Ow.obj(e); if (a && "reference" === r) return e === t; const o = Ow.arr(e); if (o && "reference" === n) return e === t; if ((o || a) && e === t) return !0; let s; for (s in e) if (!(s in t)) return !1; if (a && "shallow" === n && "shallow" === r) { for (s in i ? t : e) if (!Ow.equ(e[s], t[s], { strict: i, objects: "reference" })) return !1 } else for (s in i ? t : e) if (e[s] !== t[s]) return !1; if (Ow.und(s)) { if (o && 0 === e.length && 0 === t.length) return !0; if (a && 0 === Object.keys(e).length && 0 === Object.keys(t).length) return !0; if (e !== t) return !1 } return !0 } }; function Uw(e, t) { return e.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...t }, e } function zw(e, t) { let n = e; if (t.includes("-")) { const r = t.split("-"), i = r.pop(); return n = r.reduce(((e, t) => e[t]), e), { target: n, key: i } } return { target: n, key: t } } const Hw = /-\d+$/; function Gw(e, t, n) { if (Ow.str(n)) { if (Hw.test(n)) { const t = n.replace(Hw, ""), { target: r, key: i } = zw(e, t); Array.isArray(r[i]) || (r[i] = []) } const { target: r, key: i } = zw(e, n); t.__r3f.previousAttach = r[i], r[i] = t } else t.__r3f.previousAttach = n(e, t) } function jw(e, t, n) { var r, i; if (Ow.str(n)) { const { target: r, key: i } = zw(e, n), a = t.__r3f.previousAttach; void 0 === a ? delete r[i] : r[i] = a } else null == (r = t.__r3f) || null == r.previousAttach || r.previousAttach(e, t); null == (i = t.__r3f) || delete i.previousAttach } function Vw(e, { children: t, key: n, ref: r, ...i }, { children: a, key: o, ref: s, ...l } = {}, c = !1) { const u = e.__r3f, d = Object.entries(i), h = []; if (c) { const e = Object.keys(l); for (let t = 0; t < e.length; t++)i.hasOwnProperty(e[t]) || d.unshift([e[t], Lw + "remove"]) } d.forEach((([t, n]) => { var r; if (null != (r = e.__r3f) && r.primitive && "object" === t) return; if (Ow.equ(n, l[t])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(t)) return h.push([t, n, !0, []]); let a = []; t.includes("-") && (a = t.split("-")), h.push([t, n, !1, a]); for (const e in i) { const n = i[e]; e.startsWith(`${t}-`) && h.push([e, n, !1, e.split("-")]) } })); const p = { ...i }; return null != u && u.memoizedProps && null != u && u.memoizedProps.args && (p.args = u.memoizedProps.args), null != u && u.memoizedProps && null != u && u.memoizedProps.attach && (p.attach = u.memoizedProps.attach), { memoized: p, changes: h } } const Ww = "undefined" != typeof process && !1; function Xw(e, t) { var n; const r = e.__r3f, i = null == r ? void 0 : r.root, a = null == i || null == i.getState ? void 0 : i.getState(), { memoized: o, changes: s } = (c = t) && c.memoized && c.changes ? t : Vw(e, t), l = null == r ? void 0 : r.eventCount; var c; e.__r3f && (e.__r3f.memoizedProps = o); for (let t = 0; t < s.length; t++) { let [n, i, o, l] = s[t]; if (Ew(e)) { const e = 3001, t = "srgb", r = "srgb-linear"; "encoding" === n ? (n = "colorSpace", i = i === e ? t : r) : "outputEncoding" === n && (n = "outputColorSpace", i = i === e ? t : r) } let c = e, u = c[n]; if (l.length && (u = l.reduce(((e, t) => e[t]), e), !u || !u.set)) { const [t, ...r] = l.reverse(); c = r.reverse().reduce(((e, t) => e[t]), e), n = t } if (i === Lw + "remove") if (c.constructor) { let e = Dw.get(c.constructor); e || (e = new c.constructor, Dw.set(c.constructor, e)), i = e[n] } else i = 0; if (o && r) i ? r.handlers[n] = i : delete r.handlers[n], r.eventCount = Object.keys(r.handlers).length; else if (u && u.set && (u.copy || u instanceof Rp)) { if (Array.isArray(i)) u.fromArray ? u.fromArray(i) : u.set(...i); else if (u.copy && i && i.constructor && (Ww ? u.constructor.name === i.constructor.name : u.constructor === i.constructor)) u.copy(i); else if (void 0 !== i) { const e = u instanceof df; !e && u.setScalar ? u.setScalar(i) : u instanceof Rp && i instanceof Rp ? u.mask = i.mask : u.set(i), !Cw() && a && !a.linear && e && u.convertSRGBToLinear() } } else if (c[n] = i, c[n] instanceof Lh && c[n].format === qc && c[n].type === Fc && a) { const e = c[n]; Ew(e) && Ew(a.gl) ? e.colorSpace = a.gl.outputColorSpace : e.encoding = a.gl.outputEncoding } Jw(e) } if (r && r.parent && e.raycast && l !== r.eventCount) { const t = Fw(e).getState().internal, n = t.interaction.indexOf(e); n > -1 && t.interaction.splice(n, 1), r.eventCount && t.interaction.push(e) } return !(1 === s.length && "onUpdate" === s[0][0]) && s.length && null != (n = e.__r3f) && n.parent && Yw(e), e } function Jw(e) { var t, n; const r = null == (t = e.__r3f) || null == (n = t.root) || null == n.getState ? void 0 : n.getState(); r && 0 === r.internal.frames && r.invalidate() } function Yw(e) { null == e.onUpdate || e.onUpdate(e) } function Qw(e, t) { e.manual || (Tw(e) ? (e.left = t.width / -2, e.right = t.width / 2, e.top = t.height / 2, e.bottom = t.height / -2) : e.aspect = t.width / t.height, e.updateProjectionMatrix(), e.updateMatrixWorld()) } function Kw(e) { return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId } function qw(e, t, n, r) { const i = n.get(t); i && (n.delete(t), 0 === n.size && (e.delete(r), i.target.releasePointerCapture(r))) } const Zw = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"], $w = e => !(null == e || !e.render), e_ = n.createContext(null); let t_, n_, r_, i_ = new Set, a_ = new Set, o_ = new Set; function s_(e, t) { if (e.size) for (const { callback: n } of e.values()) n(t) } function l_(e, t) { switch (e) { case "before": return s_(i_, t); case "after": return s_(a_, t); case "tail": return s_(o_, t) } } function c_(e, t, n) { let r = t.clock.getDelta(); for ("never" === t.frameloop && "number" == typeof e && (r = e - t.clock.elapsedTime, t.clock.oldTime = t.clock.elapsedTime, t.clock.elapsedTime = e), n_ = t.internal.subscribers, t_ = 0; t_ < n_.length; t_++)r_ = n_[t_], r_.ref.current(r_.store.getState(), r, n); return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera), t.internal.frames = Math.max(0, t.internal.frames - 1), "always" === t.frameloop ? 1 : t.internal.frames } function u_() { const e = n.useContext(e_); if (!e) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return e } function d_(e = e => e, t) { return u_()(e, t) } function h_(e, t = 0) { const n = u_(), r = n.getState().internal.subscribe, i = Bw(e); return Rw((() => r(i, t, n)), [t, r, n]), null } const p_ = new WeakMap; function f_(e, t) { return function (n, ...r) { let i = p_.get(n); return i || (i = new n, p_.set(n, i)), e && e(i), Promise.all(r.map((e => new Promise(((n, r) => i.load(e, (e => { e.scene && Object.assign(e, function (e) { const t = { nodes: {}, materials: {} }; return e && e.traverse((e => { e.name && (t.nodes[e.name] = e), e.material && !t.materials[e.material.name] && (t.materials[e.material.name] = e.material) })), t }(e.scene)), n(e) }), t, (t => r(new Error(`Could not load ${e}: ${null == t ? void 0 : t.message}`))))))))) } } function m_(e, t, n, r) { const i = Array.isArray(t) ? t : [t], a = ((e, t, n) => yw(e, t, !1, n))(f_(n, r), [e, ...i], { equal: Ow.equ }); return Array.isArray(t) ? a : a[0] } m_.preload = function (e, t, n) { const r = Array.isArray(t) ? t : [t]; return ((e, t) => { yw(e, t, !0, void 0) })(f_(n), [e, ...r]) }, m_.clear = function (e, t) { return (e => { if (void 0 === e || 0 === e.length) gw.splice(0, gw.length); else { const t = gw.find((t => vw(e, t.keys, t.equal))); t && t.remove() } })([e, ...Array.isArray(t) ? t : [t]]) }; const g_ = new Map, { invalidate: v_, advance: y_ } = function (e) { let t, n, r, i = !1, a = !1; function o(s) { n = requestAnimationFrame(o), i = !0, t = 0, l_("before", s), a = !0; for (const n of e.values()) { var l; r = n.store.getState(), !r.internal.active || !("always" === r.frameloop || r.internal.frames > 0) || null != (l = r.gl.xr) && l.isPresenting || (t += c_(s, r)) } if (a = !1, l_("after", s), 0 === t) return l_("tail", s), i = !1, cancelAnimationFrame(n) } return { loop: o, invalidate: function t(n, r = 1) { var s; if (!n) return e.forEach((e => t(e.store.getState(), r))); null != (s = n.gl.xr) && s.isPresenting || !n.internal.active || "never" === n.frameloop || (n.internal.frames = r > 1 ? Math.min(60, n.internal.frames + r) : a ? 2 : 1, i || (i = !0, requestAnimationFrame(o))) }, advance: function (t, n = !0, r, i) { if (n && l_("before", t), r) c_(t, r, i); else for (const n of e.values()) c_(t, n.store.getState()); n && l_("after", t) } } }(g_), { reconciler: b_, applyProps: x_ } = function (e, t) { function n(e, { args: t = [], attach: n, ...r }, i) { let a, o = `${e[0].toUpperCase()}${e.slice(1)}`; if ("primitive" === e) { if (void 0 === r.object) throw new Error("R3F: Primitives without 'object' are invalid!"); a = Uw(r.object, { type: e, root: i, attach: n, primitive: !0 }) } else { const r = Sw[o]; if (!r) throw new Error(`R3F: ${o} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(t)) throw new Error("R3F: The args prop must be an array!"); a = Uw(new r(...t), { type: e, root: i, attach: n, memoizedProps: { args: t } }) } return void 0 === a.__r3f.attach && (a instanceof zf ? a.__r3f.attach = "geometry" : a instanceof ff && (a.__r3f.attach = "material")), "inject" !== o && Xw(a, r), a } function r(e, t) { let n = !1; var r, i; t && (null != (r = t.__r3f) && r.attach ? Gw(e, t, t.__r3f.attach) : t.isObject3D && e.isObject3D && (e.add(t), n = !0), n || null == (i = e.__r3f) || i.objects.push(t), t.__r3f || Uw(t, {}), t.__r3f.parent = e, Yw(t), Jw(t)) } function i(e, t, n) { let r = !1; if (t) { var i, a; if (null != (i = t.__r3f) && i.attach) Gw(e, t, t.__r3f.attach); else if (t.isObject3D && e.isObject3D) { t.parent = e, t.dispatchEvent({ type: "added" }), e.dispatchEvent({ type: "childadded", child: t }); const i = e.children.filter((e => e !== t)), a = i.indexOf(n); e.children = [...i.slice(0, a), t, ...i.slice(a)], r = !0 } r || null == (a = e.__r3f) || a.objects.push(t), t.__r3f || Uw(t, {}), t.__r3f.parent = e, Yw(t), Jw(t) } } function a(e, t, n = !1) { e && [...e].forEach((e => o(t, e, n))) } function o(e, t, n) { if (t) { var r, i, o; if (t.__r3f && (t.__r3f.parent = null), null != (r = e.__r3f) && r.objects && (e.__r3f.objects = e.__r3f.objects.filter((e => e !== t))), null != (i = t.__r3f) && i.attach) jw(e, t, t.__r3f.attach); else if (t.isObject3D && e.isObject3D) { var s; e.remove(t), null != (s = t.__r3f) && s.root && function (e, t) { const { internal: n } = e.getState(); n.interaction = n.interaction.filter((e => e !== t)), n.initialHits = n.initialHits.filter((e => e !== t)), n.hovered.forEach(((e, r) => { e.eventObject !== t && e.object !== t || n.hovered.delete(r) })), n.capturedMap.forEach(((e, r) => { qw(n.capturedMap, t, e, r) })) }(Fw(t), t) } const c = null == (o = t.__r3f) ? void 0 : o.primitive, u = !c && (void 0 === n ? null !== t.dispose : n); var l; if (c || (a(null == (l = t.__r3f) ? void 0 : l.objects, t, u), a(t.children, t, u)), delete t.__r3f, u && t.dispose && "Scene" !== t.type) { const e = () => { try { t.dispose() } catch (e) { } }; "undefined" == typeof IS_REACT_ACT_ENVIRONMENT ? (0, Aw.unstable_scheduleCallback)(Aw.unstable_IdlePriority, e) : e() } Jw(e) } } const s = () => { }; return { reconciler: xw()({ createInstance: n, removeChild: o, appendChild: r, appendInitialChild: r, insertBefore: i, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (e, t) => { if (!t) return; const n = e.getState().scene; n.__r3f && (n.__r3f.root = e, r(n, t)) }, removeChildFromContainer: (e, t) => { t && o(e.getState().scene, t) }, insertInContainerBefore: (e, t, n) => { if (!t || !n) return; const r = e.getState().scene; r.__r3f && i(r, t, n) }, getRootHostContext: () => null, getChildHostContext: e => e, finalizeInitialChildren(e) { var t; const n = null != (t = null == e ? void 0 : e.__r3f) ? t : {}; return Boolean(n.handlers) }, prepareUpdate(e, t, n, r) { var i; if ((null != (i = null == e ? void 0 : e.__r3f) ? i : {}).primitive && r.object && r.object !== e) return [!0]; { const { args: t = [], children: i, ...a } = r, { args: o = [], children: s, ...l } = n; if (!Array.isArray(t)) throw new Error("R3F: the args prop must be an array!"); if (t.some(((e, t) => e !== o[t]))) return [!0]; const c = Vw(e, a, l, !0); return c.changes.length ? [!1, c] : null } }, commitUpdate(e, [t, i], a, s, l, c) { t ? function (e, t, i, a) { var s; const l = null == (s = e.__r3f) ? void 0 : s.parent; if (!l) return; const c = n(t, i, e.__r3f.root); if (e.children) { for (const t of e.children) t.__r3f && r(c, t); e.children = e.children.filter((e => !e.__r3f)) } e.__r3f.objects.forEach((e => r(c, e))), e.__r3f.objects = [], e.__r3f.autoRemovedBeforeAppend || o(l, e), c.parent && (c.__r3f.autoRemovedBeforeAppend = !0), r(l, c), c.raycast && c.__r3f.eventCount && Fw(c).getState().internal.interaction.push(c), [a, a.alternate].forEach((e => { null !== e && (e.stateNode = c, e.ref && ("function" == typeof e.ref ? e.ref(c) : e.ref.current = c)) })) }(e, a, l, c) : Xw(e, i) }, commitMount(e, t, n, r) { var i; const a = null != (i = e.__r3f) ? i : {}; e.raycast && a.handlers && a.eventCount && Fw(e).getState().internal.interaction.push(e) }, getPublicInstance: e => e, prepareForCommit: () => null, preparePortalMount: e => Uw(e.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(e) { var t; const { attach: n, parent: r } = null != (t = e.__r3f) ? t : {}; n && r && jw(r, e, n), e.isObject3D && (e.visible = !1), Jw(e) }, unhideInstance(e, t) { var n; const { attach: r, parent: i } = null != (n = e.__r3f) ? n : {}; r && i && Gw(i, e, r), (e.isObject3D && null == t.visible || t.visible) && (e.visible = !0), Jw(e) }, createTextInstance: s, hideTextInstance: s, unhideTextInstance: s, getCurrentEventPriority: () => t ? t() : pw.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: "undefined" != typeof performance && Ow.fun(performance.now) ? performance.now : Ow.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: Ow.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: Ow.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: Xw } }(0, (function () { var e; const t = "undefined" != typeof self && self || "undefined" != typeof window && window; if (!t) return pw.DefaultEventPriority; switch (null == (e = t.event) ? void 0 : e.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return pw.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return pw.ContinuousEventPriority; default: return pw.DefaultEventPriority } })), A_ = { objects: "shallow", strict: !1 }, S_ = (e, t) => { const n = "function" == typeof e ? e(t) : e; return $w(n) ? n : new uy({ powerPreference: "high-performance", canvas: t, antialias: !0, alpha: !0, ...e }) }; function M_({ store: e, children: t, onCreated: n, rootElement: r }) { return Rw((() => { const t = e.getState(); t.set((e => ({ internal: { ...e.internal, active: !0 } }))), n && n(t), e.getState().events.connected || null == t.events.connect || t.events.connect(r) }), []), (0, ii.jsx)(e_.Provider, { value: e, children: t }) } function w_(e, t) { const n = g_.get(e), r = null == n ? void 0 : n.fiber; if (r) { const i = null == n ? void 0 : n.store.getState(); i && (i.internal.active = !1), b_.updateContainer(null, r, null, (() => { i && setTimeout((() => { try { var n, r, a, o; null == i.events.disconnect || i.events.disconnect(), null == (n = i.gl) || null == (r = n.renderLists) || null == r.dispose || r.dispose(), null == (a = i.gl) || null == a.forceContextLoss || a.forceContextLoss(), null != (o = i.gl) && o.xr && i.xr.disconnect(), function (e) { e.dispose && "Scene" !== e.type && e.dispose(); for (const t in e) null == t.dispose || t.dispose(), delete e[t] }(i), g_.delete(e), t && t(e) } catch (e) { } }), 500) })) } } function __({ state: e = {}, children: t, container: r }) { const { events: i, size: a, ...o } = e, s = u_(), [l] = n.useState((() => new SM)), [c] = n.useState((() => new uh)), u = n.useCallback(((e, t) => { const n = { ...e }; let u; if (Object.keys(e).forEach((r => { (Zw.includes(r) || e[r] !== t[r] && t[r]) && delete n[r] })), t && a) { const n = t.camera; u = e.viewport.getCurrentViewport(n, new Gh, a), n !== e.camera && Qw(n, a) } return { ...n, scene: r, raycaster: l, pointer: c, mouse: c, previousRoot: s, events: { ...e.events, ...null == t ? void 0 : t.events, ...i }, size: { ...e.size, ...a }, viewport: { ...e.viewport, ...u }, ...o } }), [e]), [d] = n.useState((() => { const e = s.getState(), t = mw(((t, n) => ({ ...e, scene: r, raycaster: l, pointer: c, mouse: c, previousRoot: s, events: { ...e.events, ...i }, size: { ...e.size, ...a }, ...o, set: t, get: n, setEvents: e => t((t => ({ ...t, events: { ...t.events, ...e } }))) }))); return t })); return n.useEffect((() => { const e = s.subscribe((e => d.setState((t => u(e, t))))); return () => { e() } }), [u]), n.useEffect((() => { d.setState((e => u(s.getState(), e))) }), [u]), n.useEffect((() => () => { d.destroy() }), []), (0, ii.jsx)(ii.Fragment, { children: b_.createPortal((0, ii.jsx)(e_.Provider, { value: d, children: t }), d, null) }) } b_.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: n.version }), n.unstable_act; const E_ = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function C_(e) { const { handlePointer: t } = function (e) { function t(e) { return e.filter((e => ["Move", "Over", "Enter", "Out", "Leave"].some((t => { var n; return null == (n = e.__r3f) ? void 0 : n.handlers["onPointer" + t] })))) } function n(t) { const { internal: n } = e.getState(); for (const e of n.hovered.values()) if (!t.length || !t.find((t => t.object === e.object && t.index === e.index && t.instanceId === e.instanceId))) { const r = e.eventObject.__r3f, i = null == r ? void 0 : r.handlers; if (n.hovered.delete(Kw(e)), null != r && r.eventCount) { const n = { ...e, intersections: t }; null == i.onPointerOut || i.onPointerOut(n), null == i.onPointerLeave || i.onPointerLeave(n) } } } function r(e, t) { for (let n = 0; n < t.length; n++) { const r = t[n].__r3f; null == r || null == r.handlers.onPointerMissed || r.handlers.onPointerMissed(e) } } return { handlePointer: function (i) { switch (i) { case "onPointerLeave": case "onPointerCancel": return () => n([]); case "onLostPointerCapture": return t => { const { internal: r } = e.getState(); "pointerId" in t && r.capturedMap.has(t.pointerId) && requestAnimationFrame((() => { r.capturedMap.has(t.pointerId) && (r.capturedMap.delete(t.pointerId), n([])) })) } }return function (a) { const { onPointerMissed: o, internal: s } = e.getState(); s.lastEvent.current = a; const l = "onPointerMove" === i, c = "onClick" === i || "onContextMenu" === i || "onDoubleClick" === i, u = function (t, n) { const r = e.getState(), i = new Set, a = [], o = n ? n(r.internal.interaction) : r.internal.interaction; for (let e = 0; e < o.length; e++) { const t = Nw(o[e]); t && (t.raycaster.camera = void 0) } r.previousRoot || null == r.events.compute || r.events.compute(t, r); let s = o.flatMap((function (e) { const n = Nw(e); return n && n.events.enabled && null !== n.raycaster.camera ? (void 0 === n.raycaster.camera && (null == n.events.compute || n.events.compute(t, n, null == (r = n.previousRoot) ? void 0 : r.getState()), void 0 === n.raycaster.camera && (n.raycaster.camera = null)), n.raycaster.camera ? n.raycaster.intersectObject(e, !0) : []) : []; var r })).sort(((e, t) => { const n = Nw(e.object), r = Nw(t.object); return n && r && r.events.priority - n.events.priority || e.distance - t.distance })).filter((e => { const t = Kw(e); return !i.has(t) && (i.add(t), !0) })); r.events.filter && (s = r.events.filter(s, r)); for (const e of s) { let t = e.object; for (; t;) { var l; null != (l = t.__r3f) && l.eventCount && a.push({ ...e, eventObject: t }), t = t.parent } } if ("pointerId" in t && r.internal.capturedMap.has(t.pointerId)) for (let e of r.internal.capturedMap.get(t.pointerId).values()) i.has(Kw(e.intersection)) || a.push(e.intersection); return a }(a, l ? t : void 0), d = c ? function (t) { const { internal: n } = e.getState(), r = t.offsetX - n.initialClick[0], i = t.offsetY - n.initialClick[1]; return Math.round(Math.sqrt(r * r + i * i)) }(a) : 0; "onPointerDown" === i && (s.initialClick = [a.offsetX, a.offsetY], s.initialHits = u.map((e => e.eventObject))), c && !u.length && d <= 2 && (r(a, s.interaction), o && o(a)), l && n(u), function (t, r, i, a) { const o = e.getState(); if (t.length) { const e = { stopped: !1 }; for (const s of t) { const l = Nw(s.object) || o, { raycaster: c, pointer: u, camera: d, internal: h } = l, p = new Gh(u.x, u.y, 0).unproject(d), f = e => { var t, n; return null != (t = null == (n = h.capturedMap.get(e)) ? void 0 : n.has(s.eventObject)) && t }, m = e => { const t = { intersection: s, target: r.target }; h.capturedMap.has(e) ? h.capturedMap.get(e).set(s.eventObject, t) : h.capturedMap.set(e, new Map([[s.eventObject, t]])), r.target.setPointerCapture(e) }, g = e => { const t = h.capturedMap.get(e); t && qw(h.capturedMap, s.eventObject, t, e) }; let v = {}; for (let e in r) { let t = r[e]; "function" != typeof t && (v[e] = t) } let y = { ...s, ...v, pointer: u, intersections: t, stopped: e.stopped, delta: i, unprojectedPoint: p, ray: c.ray, camera: d, stopPropagation() { const i = "pointerId" in r && h.capturedMap.get(r.pointerId); (!i || i.has(s.eventObject)) && (y.stopped = e.stopped = !0, h.hovered.size && Array.from(h.hovered.values()).find((e => e.eventObject === s.eventObject))) && n([...t.slice(0, t.indexOf(s)), s]) }, target: { hasPointerCapture: f, setPointerCapture: m, releasePointerCapture: g }, currentTarget: { hasPointerCapture: f, setPointerCapture: m, releasePointerCapture: g }, nativeEvent: r }; if (a(y), !0 === e.stopped) break } } }(u, a, d, (function (e) { const t = e.eventObject, n = t.__r3f, o = null == n ? void 0 : n.handlers; if (null != n && n.eventCount) if (l) { if (o.onPointerOver || o.onPointerEnter || o.onPointerOut || o.onPointerLeave) { const t = Kw(e), n = s.hovered.get(t); n ? n.stopped && e.stopPropagation() : (s.hovered.set(t, e), null == o.onPointerOver || o.onPointerOver(e), null == o.onPointerEnter || o.onPointerEnter(e)) } null == o.onPointerMove || o.onPointerMove(e) } else { const n = o[i]; n ? c && !s.initialHits.includes(t) || (r(a, s.interaction.filter((e => !s.initialHits.includes(e)))), n(e)) : c && s.initialHits.includes(t) && r(a, s.interaction.filter((e => !s.initialHits.includes(e)))) } })) } } } }(e); return { priority: 1, enabled: !0, compute(e, t, n) { t.pointer.set(e.offsetX / t.size.width * 2 - 1, -e.offsetY / t.size.height * 2 + 1), t.raycaster.setFromCamera(t.pointer, t.camera) }, connected: void 0, handlers: Object.keys(E_).reduce(((e, n) => ({ ...e, [n]: t(n) })), {}), update: () => { var t; const { events: n, internal: r } = e.getState(); null != (t = r.lastEvent) && t.current && n.handlers && n.handlers.onPointerMove(r.lastEvent.current) }, connect: t => { var n; const { set: r, events: i } = e.getState(); null == i.disconnect || i.disconnect(), r((e => ({ events: { ...e.events, connected: t } }))), Object.entries(null != (n = i.handlers) ? n : []).forEach((([e, n]) => { const [r, i] = E_[e]; t.addEventListener(r, n, { passive: i }) })) }, disconnect: () => { const { set: t, events: n } = e.getState(); var r; n.connected && (Object.entries(null != (r = n.handlers) ? r : []).forEach((([e, t]) => { if (n && n.connected instanceof HTMLElement) { const [r] = E_[e]; n.connected.removeEventListener(r, t) } })), t((e => ({ events: { ...e.events, connected: void 0 } })))) } } } var T_ = i(334), R_ = i.n(T_), B_ = Object.defineProperty, I_ = Object.defineProperties, P_ = Object.getOwnPropertyDescriptors, L_ = Object.getOwnPropertySymbols, D_ = Object.prototype.hasOwnProperty, k_ = Object.prototype.propertyIsEnumerable, N_ = (e, t, n) => t in e ? B_(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, F_ = (e, t) => { for (var n in t || (t = {})) D_.call(t, n) && N_(e, n, t[n]); if (L_) for (var n of L_(t)) k_.call(t, n) && N_(e, n, t[n]); return e }; function O_(e, t, n) { if (!e) return; if (!0 === n(e)) return e; let r = t ? e.return : e.child; for (; r;) { const e = O_(r, t, n); if (e) return e; r = t ? null : r.sibling } } function U_(e) { try { return Object.defineProperties(e, { _currentRenderer: { get: () => null, set() { } }, _currentRenderer2: { get: () => null, set() { } } }) } catch (t) { return e } } const z_ = U_(n.createContext(null)); class H_ extends n.Component { render() { return n.createElement(z_.Provider, { value: this._reactInternals }, this.props.children) } } const { ReactCurrentOwner: G_, ReactCurrentDispatcher: j_ } = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; function V_() { const e = function () { var e, t; const r = function () { const e = n.useContext(z_); if (null === e) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const t = n.useId(), r = n.useMemo((() => { for (const n of [null == G_ ? void 0 : G_.current, e, null == e ? void 0 : e.alternate]) { if (!n) continue; const e = O_(n, !1, (e => { let n = e.memoizedState; for (; n;) { if (n.memoizedState === t) return !0; n = n.next } })); if (e) return e } }), [e, t]); return r }(), [i] = n.useState((() => new Map)); i.clear(); let a = r; for (; a;) { const n = null == (e = a.type) ? void 0 : e._context; n && n !== z_ && !i.has(n) && i.set(n, null == (t = null == j_ ? void 0 : j_.current) ? void 0 : t.readContext(U_(n))), a = a.return } return i }(); return n.useMemo((() => Array.from(e.keys()).reduce(((t, r) => i => { return n.createElement(t, null, n.createElement(r.Provider, (a = F_({}, i), o = { value: e.get(r) }, I_(a, P_(o))))); var a, o }), (e => n.createElement(H_, F_({}, e))))), [e]) } function W_({ debounce: e, scroll: t, polyfill: r, offsetSize: i } = { debounce: 0, scroll: !1, offsetSize: !1 }) { const a = r || "undefined" != typeof window && window.ResizeObserver, [o, s] = (0, n.useState)({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }); if (!a) return o.width = 1280, o.height = 800, [() => { }, o, () => { }]; const l = (0, n.useRef)({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: o, orientationHandler: null }), c = e ? "number" == typeof e ? e : e.scroll : null, u = e ? "number" == typeof e ? e : e.resize : null, d = (0, n.useRef)(!1); (0, n.useEffect)((() => (d.current = !0, () => { d.current = !1 }))); const [h, p, f] = (0, n.useMemo)((() => { const e = () => { if (!l.current.element) return; const { left: e, top: t, width: n, height: r, bottom: a, right: o, x: c, y: u } = l.current.element.getBoundingClientRect(), h = { left: e, top: t, width: n, height: r, bottom: a, right: o, x: c, y: u }; l.current.element instanceof HTMLElement && i && (h.height = l.current.element.offsetHeight, h.width = l.current.element.offsetWidth), Object.freeze(h), d.current && !Y_(l.current.lastBounds, h) && s(l.current.lastBounds = h) }; return [e, u ? R_()(e, u) : e, c ? R_()(e, c) : e] }), [s, i, c, u]); function m() { l.current.scrollContainers && (l.current.scrollContainers.forEach((e => e.removeEventListener("scroll", f, !0))), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null), l.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", l.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", l.current.orientationHandler)) } function g() { var e; l.current.element && (l.current.resizeObserver = new a(p), null == (e = l.current.resizeObserver) || e.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach((e => e.addEventListener("scroll", f, { capture: !0, passive: !0 }))), l.current.orientationHandler = () => { f() }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", l.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", l.current.orientationHandler)) } var v, y, b; return y = f, b = Boolean(t), (0, n.useEffect)((() => { if (b) { const e = y; return window.addEventListener("scroll", e, { capture: !0, passive: !0 }), () => { window.removeEventListener("scroll", e, !0) } } }), [y, b]), v = p, (0, n.useEffect)((() => { const e = v; return window.addEventListener("resize", e), () => { window.removeEventListener("resize", e) } }), [v]), (0, n.useEffect)((() => { m(), g() }), [t, f, p]), (0, n.useEffect)((() => m), []), [e => { e && e !== l.current.element && (m(), l.current.element = e, l.current.scrollContainers = X_(e), g()) }, o, h] } function X_(e) { const t = []; if (!e || e === document.body) return t; const { overflow: n, overflowX: r, overflowY: i } = window.getComputedStyle(e); return [n, r, i].some((e => "auto" === e || "scroll" === e)) && t.push(e), [...t, ...X_(e.parentElement)] } const J_ = ["x", "y", "top", "bottom", "left", "right", "width", "height"], Y_ = (e, t) => J_.every((n => e[n] === t[n])), Q_ = n.forwardRef((function ({ children: t, fallback: r, resize: i, style: a, gl: o, events: s = C_, eventSource: l, eventPrefix: c, shadows: u, linear: d, flat: h, legacy: p, orthographic: f, frameloop: m, dpr: g, performance: v, raycaster: y, camera: b, scene: x, onPointerMissed: A, onCreated: S, ...M }, w) { n.useMemo((() => Mw(e)), []); const _ = V_(), [E, C] = W_({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }), T = n.useRef(null), R = n.useRef(null); n.useImperativeHandle(w, (() => T.current)); const B = Bw(A), [I, P] = n.useState(!1), [L, D] = n.useState(!1); if (I) throw I; if (L) throw L; const k = n.useRef(null); Rw((() => { const e = T.current; C.width > 0 && C.height > 0 && e && (k.current || (k.current = function (e) { const t = g_.get(e), r = null == t ? void 0 : t.fiber, i = null == t ? void 0 : t.store; t && console.warn("R3F.createRoot should only be called once!"); const a = "function" == typeof reportError ? reportError : console.error, o = i || ((e, t) => { const r = mw(((r, i) => { const a = new Gh, o = new Gh, s = new Gh; function l(e = i().camera, t = o, n = i().size) { const { width: r, height: l, top: c, left: u } = n, d = r / l; t instanceof Gh ? s.copy(t) : s.set(...t); const h = e.getWorldPosition(a).distanceTo(s); if (Tw(e)) return { width: r / e.zoom, height: l / e.zoom, top: c, left: u, factor: 1, distance: h, aspect: d }; { const t = e.fov * Math.PI / 180, n = 2 * Math.tan(t / 2) * h, i = n * (r / l); return { width: i, height: n, top: c, left: u, factor: r / i, distance: h, aspect: d } } } let c; const u = e => r((t => ({ performance: { ...t.performance, current: e } }))), d = new uh, h = { set: r, get: i, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, scene: null, invalidate: (t = 1) => e(i(), t), advance: (e, n) => t(e, n, i()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new VS, pointer: d, mouse: d, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const e = i(); c && clearTimeout(c), e.performance.current !== e.performance.min && u(e.performance.min), c = setTimeout((() => u(i().performance.max)), e.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: l }, setEvents: e => r((t => ({ ...t, events: { ...t.events, ...e } }))), setSize: (e, t, n, a, s) => { const c = i().camera, u = { width: e, height: t, top: a || 0, left: s || 0, updateStyle: n }; r((e => ({ size: u, viewport: { ...e.viewport, ...l(c, o, u) } }))) }, setDpr: e => r((t => { const n = kw(e); return { viewport: { ...t.viewport, dpr: n, initialDpr: t.viewport.initialDpr || n } } })), setFrameloop: (e = "always") => { const t = i().clock; t.stop(), t.elapsedTime = 0, "never" !== e && (t.start(), t.elapsedTime = 0), r((() => ({ frameloop: e }))) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: n.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (e, t, n) => { const r = i().internal; return r.priority = r.priority + (t > 0 ? 1 : 0), r.subscribers.push({ ref: e, priority: t, store: n }), r.subscribers = r.subscribers.sort(((e, t) => e.priority - t.priority)), () => { const n = i().internal; null != n && n.subscribers && (n.priority = n.priority - (t > 0 ? 1 : 0), n.subscribers = n.subscribers.filter((t => t.ref !== e))) } } } }; return h })), i = r.getState(); let a = i.size, o = i.viewport.dpr, s = i.camera; return r.subscribe((() => { const { camera: e, size: t, viewport: n, gl: i, set: l } = r.getState(); if (t.width !== a.width || t.height !== a.height || n.dpr !== o) { var c; a = t, o = n.dpr, Qw(e, t), i.setPixelRatio(n.dpr); const r = null != (c = t.updateStyle) ? c : "undefined" != typeof HTMLCanvasElement && i.domElement instanceof HTMLCanvasElement; i.setSize(t.width, t.height, r) } e !== s && (s = e, l((t => ({ viewport: { ...t.viewport, ...t.viewport.getCurrentViewport(e) } })))) })), r.subscribe((t => e(t))), r })(v_, y_), s = r || b_.createContainer(o, pw.ConcurrentRoot, null, !1, null, "", a, null); let l; t || g_.set(e, { fiber: s, store: o }); let c, u = !1; return { configure(t = {}) { let { gl: n, size: r, scene: i, events: a, onCreated: s, shadows: d = !1, linear: h = !1, flat: p = !1, legacy: f = !1, orthographic: m = !1, frameloop: g = "always", dpr: v = [1, 2], performance: y, raycaster: b, camera: x, onPointerMissed: A } = t, S = o.getState(), M = S.gl; S.gl || S.set({ gl: M = S_(n, e) }); let w = S.raycaster; w || S.set({ raycaster: w = new SM }); const { params: _, ...E } = b || {}; if (Ow.equ(E, w, A_) || x_(w, { ...E }), Ow.equ(_, w.params, A_) || x_(w, { params: { ...w.params, ..._ } }), !S.camera || S.camera === c && !Ow.equ(c, x, A_)) { c = x; const e = x instanceof om, t = e ? x : m ? new Fm(0, 0, 0, 0, .1, 1e3) : new um(75, 0, .1, 1e3); e || (t.position.z = 5, x && (x_(t, x), ("aspect" in x || "left" in x || "right" in x || "bottom" in x || "top" in x) && (t.manual = !0, t.updateProjectionMatrix())), S.camera || null != x && x.rotation || t.lookAt(0, 0, 0)), S.set({ camera: t }), w.camera = t } if (!S.scene) { let e; i instanceof py ? e = i : (e = new py, i && x_(e, i)), S.set({ scene: Uw(e) }) } if (!S.xr) { var C; const e = (e, t) => { const n = o.getState(); "never" !== n.frameloop && y_(e, !0, n, t) }, t = () => { const t = o.getState(); t.gl.xr.enabled = t.gl.xr.isPresenting, t.gl.xr.setAnimationLoop(t.gl.xr.isPresenting ? e : null), t.gl.xr.isPresenting || v_(t) }, n = { connect() { const e = o.getState().gl; e.xr.addEventListener("sessionstart", t), e.xr.addEventListener("sessionend", t) }, disconnect() { const e = o.getState().gl; e.xr.removeEventListener("sessionstart", t), e.xr.removeEventListener("sessionend", t) } }; "function" == typeof (null == (C = M.xr) ? void 0 : C.addEventListener) && n.connect(), S.set({ xr: n }) } if (M.shadowMap) { const e = M.shadowMap.enabled, t = M.shadowMap.type; if (M.shadowMap.enabled = !!d, Ow.boo(d)) M.shadowMap.type = xl; else if (Ow.str(d)) { var T; const e = { basic: yl, percentage: bl, soft: xl, variance: Al }; M.shadowMap.type = null != (T = e[d]) ? T : xl } else Ow.obj(d) && Object.assign(M.shadowMap, d); e === M.shadowMap.enabled && t === M.shadowMap.type || (M.shadowMap.needsUpdate = !0) } const R = Cw(); R && ("enabled" in R ? R.enabled = !f : "legacyMode" in R && (R.legacyMode = f)), u || x_(M, { outputEncoding: h ? 3e3 : 3001, toneMapping: p ? lc : hc }), S.legacy !== f && S.set((() => ({ legacy: f }))), S.linear !== h && S.set((() => ({ linear: h }))), S.flat !== p && S.set((() => ({ flat: p }))), !n || Ow.fun(n) || $w(n) || Ow.equ(n, M, A_) || x_(M, n), a && !S.events.handlers && S.set({ events: a(o) }); const B = function (e, t) { const n = "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement; if (t) { const { width: e, height: r, top: i, left: a, updateStyle: o = n } = t; return { width: e, height: r, top: i, left: a, updateStyle: o } } if ("undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement && e.parentElement) { const { width: t, height: r, top: i, left: a } = e.parentElement.getBoundingClientRect(); return { width: t, height: r, top: i, left: a, updateStyle: n } } return "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas ? { width: e.width, height: e.height, top: 0, left: 0, updateStyle: n } : { width: 0, height: 0, top: 0, left: 0 } }(e, r); return Ow.equ(B, S.size, A_) || S.setSize(B.width, B.height, B.updateStyle, B.top, B.left), v && S.viewport.dpr !== kw(v) && S.setDpr(v), S.frameloop !== g && S.setFrameloop(g), S.onPointerMissed || S.set({ onPointerMissed: A }), y && !Ow.equ(y, S.performance, A_) && S.set((e => ({ performance: { ...e.performance, ...y } }))), l = s, u = !0, this }, render(t) { return u || this.configure(), b_.updateContainer((0, ii.jsx)(M_, { store: o, children: t, onCreated: l, rootElement: e }), s, null, (() => { })), o }, unmount() { w_(e) } } }(e)), k.current.configure({ gl: o, events: s, shadows: u, linear: d, flat: h, legacy: p, orthographic: f, frameloop: m, dpr: g, performance: v, raycaster: y, camera: b, scene: x, size: C, onPointerMissed: (...e) => null == B.current ? void 0 : B.current(...e), onCreated: e => { var t; null == e.events.connect || e.events.connect(l ? (t = l) && t.hasOwnProperty("current") ? l.current : l : R.current), c && e.setEvents({ compute: (e, t) => { const n = e[c + "X"], r = e[c + "Y"]; t.pointer.set(n / t.size.width * 2 - 1, -r / t.size.height * 2 + 1), t.raycaster.setFromCamera(t.pointer, t.camera) } }), null == S || S(e) } }), k.current.render((0, ii.jsx)(_, { children: (0, ii.jsx)(Pw, { set: D, children: (0, ii.jsx)(n.Suspense, { fallback: (0, ii.jsx)(Iw, { set: P }), children: t }) }) }))) })), n.useEffect((() => { const e = T.current; if (e) return () => w_(e) }), []); const N = l ? "none" : "auto"; return (0, ii.jsx)("div", { ref: R, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: N, ...a }, ...M, children: (0, ii.jsx)("div", { ref: E, style: { width: "100%", height: "100%" }, children: (0, ii.jsx)("canvas", { ref: T, style: { display: "block" }, children: r }) }) }) })), K_ = n.forwardRef((function (e, t) { return (0, ii.jsx)(H_, { children: (0, ii.jsx)(Q_, { ...e, ref: t }) }) })); const q_ = n.forwardRef((({ envMap: e, resolution: t = 256, frames: r = 1 / 0, children: i, makeDefault: a, ...o }, s) => { const l = d_((({ set: e }) => e)), c = d_((({ camera: e }) => e)), u = d_((({ size: e }) => e)), d = n.useRef(null); n.useImperativeHandle(s, (() => d.current), []); const h = n.useRef(null), p = function (e, t, r) { const i = d_((e => e.size)), a = d_((e => e.viewport)), o = "number" == typeof e ? e : i.width * a.dpr, s = "number" == typeof t ? t : i.height * a.dpr, l = ("number" == typeof e ? r : e) || {}, { samples: c = 0, depth: u, ...d } = l, h = n.useMemo((() => { const e = new Nh(o, s, { minFilter: Pc, magFilter: Pc, type: Vc, ...d }); return u && (e.depthTexture = new og(o, s, jc)), e.samples = c, e }), []); return n.useLayoutEffect((() => { h.setSize(o, s), c && (h.samples = c) }), [c, h, o, s]), n.useEffect((() => () => h.dispose()), []), h }(t); n.useLayoutEffect((() => { o.manual || d.current.updateProjectionMatrix() }), [u, o]), n.useLayoutEffect((() => { d.current.updateProjectionMatrix() })), n.useLayoutEffect((() => { if (a) { const e = c; return l((() => ({ camera: d.current }))), () => l((() => ({ camera: e }))) } }), [d, a, l]); let f = 0, m = null; const g = (e => "function" == typeof e)(i); return h_((t => { g && (r === 1 / 0 || f < r) && (h.current.visible = !1, t.gl.setRenderTarget(p), m = t.scene.background, e && (t.scene.background = e), t.gl.render(t.scene, d.current), t.scene.background = m, t.gl.setRenderTarget(null), h.current.visible = !0, f++) })), n.createElement(n.Fragment, null, n.createElement("orthographicCamera", _({ left: u.width / -2, right: u.width / 2, top: u.height / 2, bottom: u.height / -2, ref: d }, o), !g && i), n.createElement("group", { ref: h }, g && i(p.texture))) })); var Z_ = Object.defineProperty, $_ = (e, t, n) => (((e, t, n) => { t in e ? Z_(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n })(e, "symbol" != typeof t ? t + "" : t, n), n); const eE = new vp, tE = new ym, nE = Math.cos(Math.PI / 180 * 70), rE = (e, t) => (e % t + t) % t; class iE extends Zd { constructor(e, t) { super(), $_(this, "object"), $_(this, "domElement"), $_(this, "enabled", !0), $_(this, "target", new Gh), $_(this, "minDistance", 0), $_(this, "maxDistance", 1 / 0), $_(this, "minZoom", 0), $_(this, "maxZoom", 1 / 0), $_(this, "minPolarAngle", 0), $_(this, "maxPolarAngle", Math.PI), $_(this, "minAzimuthAngle", -1 / 0), $_(this, "maxAzimuthAngle", 1 / 0), $_(this, "enableDamping", !1), $_(this, "dampingFactor", .05), $_(this, "enableZoom", !0), $_(this, "zoomSpeed", 1), $_(this, "enableRotate", !0), $_(this, "rotateSpeed", 1), $_(this, "enablePan", !0), $_(this, "panSpeed", 1), $_(this, "screenSpacePanning", !0), $_(this, "keyPanSpeed", 7), $_(this, "zoomToCursor", !1), $_(this, "autoRotate", !1), $_(this, "autoRotateSpeed", 2), $_(this, "reverseOrbit", !1), $_(this, "reverseHorizontalOrbit", !1), $_(this, "reverseVerticalOrbit", !1), $_(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), $_(this, "mouseButtons", { LEFT: hl.ROTATE, MIDDLE: hl.DOLLY, RIGHT: hl.PAN }), $_(this, "touches", { ONE: pl.ROTATE, TWO: pl.DOLLY_PAN }), $_(this, "target0"), $_(this, "position0"), $_(this, "zoom0"), $_(this, "_domElementKeyEvents", null), $_(this, "getPolarAngle"), $_(this, "getAzimuthalAngle"), $_(this, "setPolarAngle"), $_(this, "setAzimuthalAngle"), $_(this, "getDistance"), $_(this, "listenToKeyEvents"), $_(this, "stopListenToKeyEvents"), $_(this, "saveState"), $_(this, "reset"), $_(this, "update"), $_(this, "connect"), $_(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => c.phi, this.getAzimuthalAngle = () => c.theta, this.setPolarAngle = e => { let t = rE(e, 2 * Math.PI), r = c.phi; r < 0 && (r += 2 * Math.PI), t < 0 && (t += 2 * Math.PI); let i = Math.abs(t - r); 2 * Math.PI - i < i && (t < r ? t += 2 * Math.PI : r += 2 * Math.PI), u.phi = t - r, n.update() }, this.setAzimuthalAngle = e => { let t = rE(e, 2 * Math.PI), r = c.theta; r < 0 && (r += 2 * Math.PI), t < 0 && (t += 2 * Math.PI); let i = Math.abs(t - r); 2 * Math.PI - i < i && (t < r ? t += 2 * Math.PI : r += 2 * Math.PI), u.theta = t - r, n.update() }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = e => { e.addEventListener("keydown", Q), this._domElementKeyEvents = e }, this.stopListenToKeyEvents = () => { this._domElementKeyEvents.removeEventListener("keydown", Q), this._domElementKeyEvents = null }, this.saveState = () => { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = () => { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), s = o.NONE }, this.update = (() => { const t = new Gh, i = new Gh(0, 1, 0), a = (new Hh).setFromUnitVectors(e.up, i), p = a.clone().invert(), f = new Gh, m = new Hh, g = 2 * Math.PI; return function () { const v = n.object.position; a.setFromUnitVectors(e.up, i), p.copy(a).invert(), t.copy(v).sub(n.target), t.applyQuaternion(a), c.setFromVector3(t), n.autoRotate && s === o.NONE && T(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (c.theta += u.theta * n.dampingFactor, c.phi += u.phi * n.dampingFactor) : (c.theta += u.theta, c.phi += u.phi); let y = n.minAzimuthAngle, b = n.maxAzimuthAngle; isFinite(y) && isFinite(b) && (y < -Math.PI ? y += g : y > Math.PI && (y -= g), b < -Math.PI ? b += g : b > Math.PI && (b -= g), c.theta = y <= b ? Math.max(y, Math.min(b, c.theta)) : c.theta > (y + b) / 2 ? Math.max(y, c.theta) : Math.min(b, c.theta)), c.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, c.phi)), c.makeSafe(), !0 === n.enableDamping ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.zoomToCursor && w || n.object.isOrthographicCamera ? c.radius = N(c.radius) : c.radius = N(c.radius * d), t.setFromSpherical(c), t.applyQuaternion(p), v.copy(n.target).add(t), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), !0 === n.enableDamping ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), h.set(0, 0, 0)); let x = !1; if (n.zoomToCursor && w) { let r = null; if (n.object instanceof um && n.object.isPerspectiveCamera) { const e = t.length(); r = N(e * d); const i = e - r; n.object.position.addScaledVector(S, i), n.object.updateMatrixWorld() } else if (n.object.isOrthographicCamera) { const e = new Gh(M.x, M.y, 0); e.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix(), x = !0; const i = new Gh(M.x, M.y, 0); i.unproject(n.object), n.object.position.sub(i).add(e), n.object.updateMatrixWorld(), r = t.length() } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1; null !== r && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position) : (eE.origin.copy(n.object.position), eE.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(eE.direction)) < nE ? e.lookAt(n.target) : (tE.setFromNormalAndCoplanarPoint(n.object.up, n.target), eE.intersectPlane(tE, n.target)))) } else n.object instanceof Fm && n.object.isOrthographicCamera && (x = 1 !== d, x && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix())); return d = 1, w = !1, !!(x || f.distanceToSquared(n.object.position) > l || 8 * (1 - m.dot(n.object.quaternion)) > l) && (n.dispatchEvent(r), f.copy(n.object.position), m.copy(n.object.quaternion), x = !1, !0) } })(), this.connect = e => { n.domElement = e, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", K), n.domElement.addEventListener("pointerdown", W), n.domElement.addEventListener("pointercancel", J), n.domElement.addEventListener("wheel", Y) }, this.dispose = () => { var e, t, r, i, a, o; n.domElement && (n.domElement.style.touchAction = "auto"), null == (e = n.domElement) || e.removeEventListener("contextmenu", K), null == (t = n.domElement) || t.removeEventListener("pointerdown", W), null == (r = n.domElement) || r.removeEventListener("pointercancel", J), null == (i = n.domElement) || i.removeEventListener("wheel", Y), null == (a = n.domElement) || a.ownerDocument.removeEventListener("pointermove", X), null == (o = n.domElement) || o.ownerDocument.removeEventListener("pointerup", J), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", Q) }; const n = this, r = { type: "change" }, i = { type: "start" }, a = { type: "end" }, o = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let s = o.NONE; const l = 1e-6, c = new _M, u = new _M; let d = 1; const h = new Gh, p = new uh, f = new uh, m = new uh, g = new uh, v = new uh, y = new uh, b = new uh, x = new uh, A = new uh, S = new Gh, M = new uh; let w = !1; const _ = [], E = {}; function C() { return Math.pow(.95, n.zoomSpeed) } function T(e) { n.reverseOrbit || n.reverseHorizontalOrbit ? u.theta += e : u.theta -= e } function R(e) { n.reverseOrbit || n.reverseVerticalOrbit ? u.phi += e : u.phi -= e } const B = (() => { const e = new Gh; return function (t, n) { e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), h.add(e) } })(), I = (() => { const e = new Gh; return function (t, r) { !0 === n.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), h.add(e) } })(), P = (() => { const e = new Gh; return function (t, r) { const i = n.domElement; if (i && n.object instanceof um && n.object.isPerspectiveCamera) { const a = n.object.position; e.copy(a).sub(n.target); let o = e.length(); o *= Math.tan(n.object.fov / 2 * Math.PI / 180), B(2 * t * o / i.clientHeight, n.object.matrix), I(2 * r * o / i.clientHeight, n.object.matrix) } else i && n.object instanceof Fm && n.object.isOrthographicCamera ? (B(t * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), I(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1) } })(); function L(e) { n.object instanceof um && n.object.isPerspectiveCamera || n.object instanceof Fm && n.object.isOrthographicCamera ? d /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function D(e) { n.object instanceof um && n.object.isPerspectiveCamera || n.object instanceof Fm && n.object.isOrthographicCamera ? d *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function k(e) { if (!n.zoomToCursor || !n.domElement) return; w = !0; const t = n.domElement.getBoundingClientRect(), r = e.clientX - t.left, i = e.clientY - t.top, a = t.width, o = t.height; M.x = r / a * 2 - 1, M.y = -i / o * 2 + 1, S.set(M.x, M.y, 1).unproject(n.object).sub(n.object.position).normalize() } function N(e) { return Math.max(n.minDistance, Math.min(n.maxDistance, e)) } function F(e) { p.set(e.clientX, e.clientY) } function O(e) { g.set(e.clientX, e.clientY) } function U() { if (1 == _.length) p.set(_[0].pageX, _[0].pageY); else { const e = .5 * (_[0].pageX + _[1].pageX), t = .5 * (_[0].pageY + _[1].pageY); p.set(e, t) } } function z() { if (1 == _.length) g.set(_[0].pageX, _[0].pageY); else { const e = .5 * (_[0].pageX + _[1].pageX), t = .5 * (_[0].pageY + _[1].pageY); g.set(e, t) } } function H() { const e = _[0].pageX - _[1].pageX, t = _[0].pageY - _[1].pageY, n = Math.sqrt(e * e + t * t); b.set(0, n) } function G(e) { if (1 == _.length) f.set(e.pageX, e.pageY); else { const t = Z(e), n = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); f.set(n, r) } m.subVectors(f, p).multiplyScalar(n.rotateSpeed); const t = n.domElement; t && (T(2 * Math.PI * m.x / t.clientHeight), R(2 * Math.PI * m.y / t.clientHeight)), p.copy(f) } function j(e) { if (1 == _.length) v.set(e.pageX, e.pageY); else { const t = Z(e), n = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); v.set(n, r) } y.subVectors(v, g).multiplyScalar(n.panSpeed), P(y.x, y.y), g.copy(v) } function V(e) { const t = Z(e), r = e.pageX - t.x, i = e.pageY - t.y, a = Math.sqrt(r * r + i * i); x.set(0, a), A.set(0, Math.pow(x.y / b.y, n.zoomSpeed)), L(A.y), b.copy(x) } function W(e) { var t, r; !1 !== n.enabled && (0 === _.length && (null == (t = n.domElement) || t.ownerDocument.addEventListener("pointermove", X), null == (r = n.domElement) || r.ownerDocument.addEventListener("pointerup", J)), function (e) { _.push(e) }(e), "touch" === e.pointerType ? function (e) { switch (q(e), _.length) { case 1: switch (n.touches.ONE) { case pl.ROTATE: if (!1 === n.enableRotate) return; U(), s = o.TOUCH_ROTATE; break; case pl.PAN: if (!1 === n.enablePan) return; z(), s = o.TOUCH_PAN; break; default: s = o.NONE }break; case 2: switch (n.touches.TWO) { case pl.DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; n.enableZoom && H(), n.enablePan && z(), s = o.TOUCH_DOLLY_PAN; break; case pl.DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; n.enableZoom && H(), n.enableRotate && U(), s = o.TOUCH_DOLLY_ROTATE; break; default: s = o.NONE }break; default: s = o.NONE }s !== o.NONE && n.dispatchEvent(i) }(e) : function (e) { let t; switch (e.button) { case 0: t = n.mouseButtons.LEFT; break; case 1: t = n.mouseButtons.MIDDLE; break; case 2: t = n.mouseButtons.RIGHT; break; default: t = -1 }switch (t) { case hl.DOLLY: if (!1 === n.enableZoom) return; !function (e) { k(e), b.set(e.clientX, e.clientY) }(e), s = o.DOLLY; break; case hl.ROTATE: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === n.enablePan) return; O(e), s = o.PAN } else { if (!1 === n.enableRotate) return; F(e), s = o.ROTATE } break; case hl.PAN: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === n.enableRotate) return; F(e), s = o.ROTATE } else { if (!1 === n.enablePan) return; O(e), s = o.PAN } break; default: s = o.NONE }s !== o.NONE && n.dispatchEvent(i) }(e)) } function X(e) { !1 !== n.enabled && ("touch" === e.pointerType ? function (e) { switch (q(e), s) { case o.TOUCH_ROTATE: if (!1 === n.enableRotate) return; G(e), n.update(); break; case o.TOUCH_PAN: if (!1 === n.enablePan) return; j(e), n.update(); break; case o.TOUCH_DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; !function (e) { n.enableZoom && V(e), n.enablePan && j(e) }(e), n.update(); break; case o.TOUCH_DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; !function (e) { n.enableZoom && V(e), n.enableRotate && G(e) }(e), n.update(); break; default: s = o.NONE } }(e) : function (e) { if (!1 !== n.enabled) switch (s) { case o.ROTATE: if (!1 === n.enableRotate) return; !function (e) { f.set(e.clientX, e.clientY), m.subVectors(f, p).multiplyScalar(n.rotateSpeed); const t = n.domElement; t && (T(2 * Math.PI * m.x / t.clientHeight), R(2 * Math.PI * m.y / t.clientHeight)), p.copy(f), n.update() }(e); break; case o.DOLLY: if (!1 === n.enableZoom) return; !function (e) { x.set(e.clientX, e.clientY), A.subVectors(x, b), A.y > 0 ? L(C()) : A.y < 0 && D(C()), b.copy(x), n.update() }(e); break; case o.PAN: if (!1 === n.enablePan) return; !function (e) { v.set(e.clientX, e.clientY), y.subVectors(v, g).multiplyScalar(n.panSpeed), P(y.x, y.y), g.copy(v), n.update() }(e) } }(e)) } function J(e) { var t, r, i; !function (e) { delete E[e.pointerId]; for (let t = 0; t < _.length; t++)if (_[t].pointerId == e.pointerId) return void _.splice(t, 1) }(e), 0 === _.length && (null == (t = n.domElement) || t.releasePointerCapture(e.pointerId), null == (r = n.domElement) || r.ownerDocument.removeEventListener("pointermove", X), null == (i = n.domElement) || i.ownerDocument.removeEventListener("pointerup", J)), n.dispatchEvent(a), s = o.NONE } function Y(e) { !1 === n.enabled || !1 === n.enableZoom || s !== o.NONE && s !== o.ROTATE || (e.preventDefault(), n.dispatchEvent(i), function (e) { k(e), e.deltaY < 0 ? D(C()) : e.deltaY > 0 && L(C()), n.update() }(e), n.dispatchEvent(a)) } function Q(e) { !1 !== n.enabled && !1 !== n.enablePan && function (e) { let t = !1; switch (e.code) { case n.keys.UP: P(0, n.keyPanSpeed), t = !0; break; case n.keys.BOTTOM: P(0, -n.keyPanSpeed), t = !0; break; case n.keys.LEFT: P(n.keyPanSpeed, 0), t = !0; break; case n.keys.RIGHT: P(-n.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), n.update()) }(e) } function K(e) { !1 !== n.enabled && e.preventDefault() } function q(e) { let t = E[e.pointerId]; void 0 === t && (t = new uh, E[e.pointerId] = t), t.set(e.pageX, e.pageY) } function Z(e) { const t = e.pointerId === _[0].pointerId ? _[1] : _[0]; return E[t.pointerId] } void 0 !== t && this.connect(t), this.update() } } const aE = n.forwardRef((({ makeDefault: e, camera: t, regress: r, domElement: i, enableDamping: a = !0, keyEvents: o = !1, onChange: s, onStart: l, onEnd: c, ...u }, d) => { const h = d_((e => e.invalidate)), p = d_((e => e.camera)), f = d_((e => e.gl)), m = d_((e => e.events)), g = d_((e => e.setEvents)), v = d_((e => e.set)), y = d_((e => e.get)), b = d_((e => e.performance)), x = t || p, A = i || m.connected || f.domElement, S = n.useMemo((() => new iE(x)), [x]); return h_((() => { S.enabled && S.update() }), -1), n.useEffect((() => (o && S.connect(!0 === o ? A : o), S.connect(A), () => { S.dispose() })), [o, A, r, S, h]), n.useEffect((() => { const e = e => { h(), r && b.regress(), s && s(e) }, t = e => { l && l(e) }, n = e => { c && c(e) }; return S.addEventListener("change", e), S.addEventListener("start", t), S.addEventListener("end", n), () => { S.removeEventListener("start", t), S.removeEventListener("end", n), S.removeEventListener("change", e) } }), [s, l, c, S, h, g]), n.useEffect((() => { if (e) { const e = y().controls; return v({ controls: S }), () => v({ controls: e }) } }), [e, S]), n.createElement("primitive", _({ ref: d, object: S, enableDamping: a }, u)) })), oE = Math.PI / 2 * .9; function sE() { return (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)(q_, { makeDefault: !0, position: [-3, 6, 10], zoom: 60 }), (0, ii.jsx)(aE, { makeDefault: !0, panSpeed: 1, maxAzimuthAngle: Number.POSITIVE_INFINITY, minAzimuthAngle: Number.NEGATIVE_INFINITY, maxPolarAngle: oE, enablePan: !1, minDistance: 6, minZoom: 35, maxZoom: 80 })] }) } const lE = n.memo((() => (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)("ambientLight", { intensity: .5 }), (0, ii.jsx)("spotLight", { position: [20, 20, 20], angle: .15, penumbra: 1, intensity: 5e3 }), (0, ii.jsx)("pointLight", { position: [-10, -10, -10], intensity: 1e3 })] })), ((e, t) => !0)); function cE(e, t, n, r) { const i = class extends am { constructor(i = {}) { const a = Object.entries(e); super({ uniforms: a.reduce(((e, [t, n]) => ({ ...e, ...im.clone({ [t]: { value: n } }) })), {}), vertexShader: t, fragmentShader: n }), this.key = "", a.forEach((([e]) => Object.defineProperty(this, e, { get: () => this.uniforms[e].value, set: t => this.uniforms[e].value = t }))), Object.assign(this, i), r && r(this) } }; return i.key = ch.generateUUID(), i } const uE = { uniforms: { strokeOpacity: 1, fillOpacity: .25, fillMix: 0, thickness: .05, colorBackfaces: !1, dashInvert: !0, dash: !1, dashRepeats: 4, dashLength: .5, squeeze: !1, squeezeMin: .2, squeezeMax: 1, stroke: new df("#ff0000"), backfaceStroke: new df("#0000ff"), fill: new df("#00ff00") }, vertex: "\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  ", fragment: "\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  " }, dE = cE(uE.uniforms, uE.vertex + "\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  ", uE.fragment + "\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  "); function hE(e) { return void 0 !== (null == e ? void 0 : e.current) } function pE(e) { return "WireframeGeometry" === e.type } function fE(e) { const t = null != (n = e) && n.current ? e.current : e; var n; if (function (e) { return !(null == e || !e.isBufferGeometry) }(t)) return t; { if (pE(t)) throw new Error("Wireframe: WireframeGeometry is not supported."); const e = t.parent; if (function (e) { return !(null == e || !e.geometry) }(e)) { if (pE(e.geometry)) throw new Error("Wireframe: WireframeGeometry is not supported."); return e.geometry } } } function mE(e, t) { if (e.index) { console.warn("Wireframe: Requires non-indexed geometry, converting to non-indexed geometry."); const t = e.toNonIndexed(); e.copy(t), e.setIndex(null) } const n = function (e, t) { const n = e.getAttribute("position").count, r = []; for (let e = 0; e < n; e++) { const n = t ? 1 : 0; e % 2 == 0 ? r.push(0, 0, 1, 0, 1, 0, 1, 0, n) : r.push(0, 1, 0, 0, 0, 1, 1, 0, n) } return new Mf(Float32Array.from(r), 3) }(e, t); e.setAttribute("barycentric", n) } function gE({ geometry: e, simplify: t = !1, ...r }) { Mw({ MeshWireframeMaterial: dE }); const [i, a] = n.useState(null); n.useLayoutEffect((() => { const n = fE(e); if (!n) throw new Error("Wireframe: geometry prop must be a BufferGeometry or a ref to a BufferGeometry."); mE(n, t), hE(e) && a(n) }), [t, e]); const o = hE(e) ? i : e; return n.createElement(n.Fragment, null, o && n.createElement("mesh", { geometry: o }, n.createElement("meshWireframeMaterial", _({ attach: "material", transparent: !0, side: wl, polygonOffset: !0, polygonOffsetFactor: -4 }, r, { extensions: { derivatives: !0, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 } })))) } function vE({ simplify: e = !1, ...t }) { const r = n.useRef(null), i = n.useMemo((() => function () { const e = {}; for (const t in uE.uniforms) e[t] = { value: uE.uniforms[t] }; return e }()), [uE.uniforms]); return function (e, t) { n.useEffect((() => { var n; e.fillOpacity.value = null !== (n = t.fillOpacity) && void 0 !== n ? n : e.fillOpacity.value }), [t.fillOpacity]), n.useEffect((() => { var n; e.fillMix.value = null !== (n = t.fillMix) && void 0 !== n ? n : e.fillMix.value }), [t.fillMix]), n.useEffect((() => { var n; e.strokeOpacity.value = null !== (n = t.strokeOpacity) && void 0 !== n ? n : e.strokeOpacity.value }), [t.strokeOpacity]), n.useEffect((() => { var n; e.thickness.value = null !== (n = t.thickness) && void 0 !== n ? n : e.thickness.value }), [t.thickness]), n.useEffect((() => { e.colorBackfaces.value = !!t.colorBackfaces }), [t.colorBackfaces]), n.useEffect((() => { e.dash.value = !!t.dash }), [t.dash]), n.useEffect((() => { e.dashInvert.value = !!t.dashInvert }), [t.dashInvert]), n.useEffect((() => { var n; e.dashRepeats.value = null !== (n = t.dashRepeats) && void 0 !== n ? n : e.dashRepeats.value }), [t.dashRepeats]), n.useEffect((() => { var n; e.dashLength.value = null !== (n = t.dashLength) && void 0 !== n ? n : e.dashLength.value }), [t.dashLength]), n.useEffect((() => { e.squeeze.value = !!t.squeeze }), [t.squeeze]), n.useEffect((() => { var n; e.squeezeMin.value = null !== (n = t.squeezeMin) && void 0 !== n ? n : e.squeezeMin.value }), [t.squeezeMin]), n.useEffect((() => { var n; e.squeezeMax.value = null !== (n = t.squeezeMax) && void 0 !== n ? n : e.squeezeMax.value }), [t.squeezeMax]), n.useEffect((() => { e.stroke.value = t.stroke ? new df(t.stroke) : e.stroke.value }), [t.stroke]), n.useEffect((() => { e.fill.value = t.fill ? new df(t.fill) : e.fill.value }), [t.fill]), n.useEffect((() => { e.backfaceStroke.value = t.backfaceStroke ? new df(t.backfaceStroke) : e.backfaceStroke.value }), [t.backfaceStroke]) }(i, t), n.useLayoutEffect((() => { const t = fE(r); if (!t) throw new Error("Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop."); const n = t.clone(); return mE(t, e), () => { t.copy(n), n.dispose() } }), [e]), n.useLayoutEffect((() => { const e = r.current.parent, t = e.material.clone(); return function (e, t) { e.onBeforeCompile = e => { e.uniforms = { ...e.uniforms, ...t }, e.vertexShader = e.vertexShader.replace("void main() {", `\n\t\t  ${uE.vertex}\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t`), e.fragmentShader = e.fragmentShader.replace("void main() {", `\n\t\t  ${uE.fragment}\n\t\t  void main() {\n\t\t`), e.fragmentShader = e.fragmentShader.replace("#include <color_fragment>", "\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t") }, e.side = wl, e.transparent = !0 }(e.material, i), () => { e.material.dispose(), e.material = t } }), []), n.createElement("object3D", { ref: r }) } function yE({ geometry: e, ...t }) { return e ? n.createElement(gE, _({ geometry: e }, t)) : n.createElement(vE, t) } const bE = { uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } }, vertexShader: "\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  ", fragmentShader: "\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  " }, xE = { uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } }, vertexShader: "\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  ", fragmentShader: "\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  " }, AE = n.forwardRef((({ scale: e = 10, frames: t = 1 / 0, opacity: r = 1, width: i = 1, height: a = 1, blur: o = 1, near: s = 0, far: l = 10, resolution: c = 512, smooth: u = !0, color: d = "#000000", depthWrite: h = !1, renderOrder: p, ...f }, m) => { const g = n.useRef(null), v = d_((e => e.scene)), y = d_((e => e.gl)), b = n.useRef(null); i *= Array.isArray(e) ? e[0] : e || 1, a *= Array.isArray(e) ? e[1] : e || 1; const [x, A, S, M, w, E, C] = n.useMemo((() => { const e = new Nh(c, c), t = new Nh(c, c); t.texture.generateMipmaps = e.texture.generateMipmaps = !1; const n = new wm(i, a).rotateX(Math.PI / 2), r = new Zf(n), o = new Wv; o.depthTest = o.depthWrite = !1, o.onBeforeCompile = e => { e.uniforms = { ...e.uniforms, ucolor: { value: new df(d) } }, e.fragmentShader = e.fragmentShader.replace("void main() {", "uniform vec3 ucolor;\n           void main() {\n          "), e.fragmentShader = e.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );") }; const s = new am(bE), l = new am(xE); return l.depthTest = s.depthTest = !1, [e, n, o, r, s, l, t] }), [c, i, a, e, d]), T = e => { M.visible = !0, M.material = w, w.uniforms.tDiffuse.value = x.texture, w.uniforms.h.value = 1 * e / 256, y.setRenderTarget(C), y.render(M, b.current), M.material = E, E.uniforms.tDiffuse.value = C.texture, E.uniforms.v.value = 1 * e / 256, y.setRenderTarget(x), y.render(M, b.current), M.visible = !1 }; let R, B, I = 0; return h_((() => { b.current && (t === 1 / 0 || I < t) && (I++, R = v.background, B = v.overrideMaterial, g.current.visible = !1, v.background = null, v.overrideMaterial = S, y.setRenderTarget(x), y.render(v, b.current), T(o), u && T(.4 * o), y.setRenderTarget(null), g.current.visible = !0, v.overrideMaterial = B, v.background = R) })), n.useImperativeHandle(m, (() => g.current), []), n.createElement("group", _({ "rotation-x": Math.PI / 2 }, f, { ref: g }), n.createElement("mesh", { renderOrder: p, geometry: A, scale: [1, -1, 1], rotation: [-Math.PI / 2, 0, 0] }, n.createElement("meshBasicMaterial", { transparent: !0, map: x.texture, opacity: r, depthWrite: h })), n.createElement("orthographicCamera", { ref: b, args: [-i / 2, i / 2, a / 2, -a / 2, s, l] })) })), SE = n.memo((e => (0, ii.jsx)(ii.Fragment, { children: e.position && e.scale && (0, ii.jsx)(AE, { position: e.position, opacity: .75, scale: e.scale, blur: 2.5, far: 4, frames: 1 }) })), ((e, t) => !0)), ME = e => { const t = new df(16761713), n = new df(16736109); return t.lerp(n, e / 4) }, wE = e => { const t = e.boardState.board.height_limits.flatMap(((e, t) => e.map(((e, n) => ({ position: [t, n], height: e }))))).filter((e => e.height > 0)), { groupRef: r, CalculatedShadows: i } = (() => { const e = (0, n.useRef)(null), [t, r] = (0, n.useState)({ position: void 0, scale: void 0 }); (0, n.useLayoutEffect)((() => { if (e.current) { const t = (new Wh).setFromObject(e.current); let n = t.min.distanceTo(t.max), i = new Gh; t.getCenter(i), i.sub(new Gh(0, .5, 0)), r({ position: i, scale: n }) } }), [.5]); const i = (0, n.useCallback)((() => (0, ii.jsx)(SE, { ...t })), [t]); return { groupRef: e, CalculatedShadows: i } })(); return (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)("group", { ref: r, children: t.map((t => { let { position: n, height: r } = t; return (0, ii.jsx)(_E, { position: n, height: r, update: e.update }, n.toString()) })) }), (0, ii.jsx)(i, {})] }) }, _E = e => (0, ii.jsxs)("mesh", { receiveShadow: !1, castShadow: !0, position: [e.position[0], -.6, e.position[1]], onClick: t => { t.stopPropagation(), e.update({ type: "PreviewPiece", data: [e.position[0], 0, e.position[1]] }) }, children: [(0, ii.jsx)("boxGeometry", { args: [1, .2, 1] }), (0, ii.jsx)("meshPhongMaterial", { color: ME(e.height) }), (0, ii.jsx)(yE, { simplify: !0, stroke: "#000000", thickness: .001 })] }); function EE(e, t) { if (t === qu) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e; if (t === $u || t === Zu) { let n = e.getIndex(); if (null === n) { const t = [], r = e.getAttribute("position"); if (void 0 === r) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < r.count; e++)t.push(e); e.setIndex(t), n = e.getIndex() } const r = n.count - 2, i = []; if (n) if (t === $u) for (let e = 1; e <= r; e++)i.push(n.getX(0)), i.push(n.getX(e)), i.push(n.getX(e + 1)); else for (let e = 0; e < r; e++)e % 2 == 0 ? (i.push(n.getX(e)), i.push(n.getX(e + 1)), i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)), i.push(n.getX(e + 1)), i.push(n.getX(e))); i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const a = e.clone(); return a.setIndex(i), a.clearGroups(), a } return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e } const CE = 1e-5, TE = n.forwardRef((function ({ args: [e = 1, t = 1, r = 1] = [], radius: i = .05, steps: a = 1, smoothness: o = 4, bevelSegments: s = 4, creaseAngle: l = .4, children: c, ...u }, d) { const h = n.useMemo((() => function (e, t, n) { const r = new Px, i = n - CE; return r.absarc(CE, CE, CE, -Math.PI / 2, -Math.PI, !0), r.absarc(CE, t - 2 * i, CE, Math.PI, Math.PI / 2, !0), r.absarc(e - 2 * i, t - 2 * i, CE, Math.PI / 2, 0, !0), r.absarc(e - 2 * i, CE, CE, 0, -Math.PI / 2, !0), r }(e, t, i)), [e, t, i]), p = n.useMemo((() => ({ depth: r - 2 * i, bevelEnabled: !0, bevelSegments: 2 * s, steps: a, bevelSize: i - CE, bevelThickness: i, curveSegments: o })), [r, i, o]), f = n.useRef(null); return n.useLayoutEffect((() => { f.current && (f.current.center(), function (e, t = Math.PI / 3) { const n = Math.cos(t), r = 100 * (1 + 1e-10), i = [new Gh, new Gh, new Gh], a = new Gh, o = new Gh, s = new Gh, l = new Gh; function c(e) { return `${~~(e.x * r)},${~~(e.y * r)},${~~(e.z * r)}` } const u = e.index ? e.toNonIndexed() : e, d = u.attributes.position, h = {}; for (let e = 0, t = d.count / 3; e < t; e++) { const t = 3 * e, n = i[0].fromBufferAttribute(d, t + 0), r = i[1].fromBufferAttribute(d, t + 1), s = i[2].fromBufferAttribute(d, t + 2); a.subVectors(s, r), o.subVectors(n, r); const l = (new Gh).crossVectors(a, o).normalize(); for (let e = 0; e < 3; e++) { const t = c(i[e]); t in h || (h[t] = []), h[t].push(l) } } const p = new Float32Array(3 * d.count), f = new Mf(p, 3, !1); for (let e = 0, t = d.count / 3; e < t; e++) { const t = 3 * e, r = i[0].fromBufferAttribute(d, t + 0), u = i[1].fromBufferAttribute(d, t + 1), p = i[2].fromBufferAttribute(d, t + 2); a.subVectors(p, u), o.subVectors(r, u), s.crossVectors(a, o).normalize(); for (let e = 0; e < 3; e++) { const r = h[c(i[e])]; l.set(0, 0, 0); for (let e = 0, t = r.length; e < t; e++) { const t = r[e]; s.dot(t) > n && l.add(t) } l.normalize(), f.setXYZ(t + e, l.x, l.y, l.z) } } u.setAttribute("normal", f) }(f.current, l)) }), [h, p]), n.createElement("mesh", _({ ref: d }, u), n.createElement("extrudeGeometry", { ref: f, args: [h, p] }), c) })); var RE = WE(), BE = e => HE(e, RE), IE = WE(); BE.write = e => HE(e, IE); var PE = WE(); BE.onStart = e => HE(e, PE); var LE = WE(); BE.onFrame = e => HE(e, LE); var DE = WE(); BE.onFinish = e => HE(e, DE); var kE = []; BE.setTimeout = (e, t) => { const n = BE.now() + t, r = () => { const e = kE.findIndex((e => e.cancel == r)); ~e && kE.splice(e, 1), UE -= ~e ? 1 : 0 }, i = { time: n, handler: e, cancel: r }; return kE.splice(NE(n), 0, i), UE += 1, GE(), i }; var NE = e => ~(~kE.findIndex((t => t.time > e)) || ~kE.length); BE.cancel = e => { PE.delete(e), LE.delete(e), DE.delete(e), RE.delete(e), IE.delete(e) }, BE.sync = e => { zE = !0, BE.batchedUpdates(e), zE = !1 }, BE.throttle = e => { let t; function n() { try { e(...t) } finally { t = null } } function r(...e) { t = e, BE.onStart(n) } return r.handler = e, r.cancel = () => { PE.delete(n), t = null }, r }; var FE = "undefined" != typeof window ? window.requestAnimationFrame : () => { }; BE.use = e => FE = e, BE.now = "undefined" != typeof performance ? () => performance.now() : Date.now, BE.batchedUpdates = e => e(), BE.catch = console.error, BE.frameLoop = "always", BE.advance = () => { "demand" !== BE.frameLoop ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : VE() }; var OE = -1, UE = 0, zE = !1; function HE(e, t) { zE ? (t.delete(e), e(0)) : (t.add(e), GE()) } function GE() { OE < 0 && (OE = 0, "demand" !== BE.frameLoop && FE(jE)) } function jE() { ~OE && (FE(jE), BE.batchedUpdates(VE)) } function VE() { const e = OE; OE = BE.now(); const t = NE(OE); t && (XE(kE.splice(0, t), (e => e.handler())), UE -= t), UE ? (PE.flush(), RE.flush(e ? Math.min(64, OE - e) : 16.667), LE.flush(), IE.flush(), DE.flush()) : OE = -1 } function WE() { let e = new Set, t = e; return { add(n) { UE += t != e || e.has(n) ? 0 : 1, e.add(n) }, delete: n => (UE -= t == e && e.has(n) ? 1 : 0, e.delete(n)), flush(n) { t.size && (e = new Set, UE -= t.size, XE(t, (t => t(n) && e.add(t))), UE += e.size, t = e) } } } function XE(e, t) { e.forEach((e => { try { t(e) } catch (e) { BE.catch(e) } })) } var JE = Object.defineProperty, YE = {}; function QE() { } ((e, t) => { for (var n in t) JE(e, n, { get: t[n], enumerable: !0 }) })(YE, { assign: () => cC, colors: () => oC, createStringInterpolator: () => nC, skipAnimation: () => sC, to: () => rC, willAdvance: () => lC }); var KE = { arr: Array.isArray, obj: e => !!e && "Object" === e.constructor.name, fun: e => "function" == typeof e, str: e => "string" == typeof e, num: e => "number" == typeof e, und: e => void 0 === e }; function qE(e, t) { if (KE.arr(e)) { if (!KE.arr(t) || e.length !== t.length) return !1; for (let n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1; return !0 } return e === t } var ZE = (e, t) => e.forEach(t); function $E(e, t, n) { if (KE.arr(e)) for (let r = 0; r < e.length; r++)t.call(n, e[r], `${r}`); else for (const r in e) e.hasOwnProperty(r) && t.call(n, e[r], r) } var eC = e => KE.und(e) ? [] : KE.arr(e) ? e : [e]; function tC(e, t) { if (e.size) { const n = Array.from(e); e.clear(), ZE(n, t) } } var nC, rC, iC = (e, ...t) => tC(e, (e => e(...t))), aC = () => "undefined" == typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), oC = null, sC = !1, lC = QE, cC = e => { e.to && (rC = e.to), e.now && (BE.now = e.now), void 0 !== e.colors && (oC = e.colors), null != e.skipAnimation && (sC = e.skipAnimation), e.createStringInterpolator && (nC = e.createStringInterpolator), e.requestAnimationFrame && BE.use(e.requestAnimationFrame), e.batchedUpdates && (BE.batchedUpdates = e.batchedUpdates), e.willAdvance && (lC = e.willAdvance), e.frameLoop && (BE.frameLoop = e.frameLoop) }, uC = new Set, dC = [], hC = [], pC = 0, fC = { get idle() { return !uC.size && !dC.length }, start(e) { pC > e.priority ? (uC.add(e), BE.onStart(mC)) : (gC(e), BE(yC)) }, advance: yC, sort(e) { if (pC) BE.onFrame((() => fC.sort(e))); else { const t = dC.indexOf(e); ~t && (dC.splice(t, 1), vC(e)) } }, clear() { dC = [], uC.clear() } }; function mC() { uC.forEach(gC), uC.clear(), BE(yC) } function gC(e) { dC.includes(e) || vC(e) } function vC(e) { dC.splice(function (t) { const n = t.findIndex((t => t.priority > e.priority)); return n < 0 ? t.length : n }(dC), 0, e) } function yC(e) { const t = hC; for (let n = 0; n < dC.length; n++) { const r = dC[n]; pC = r.priority, r.idle || (lC(r), r.advance(e), r.idle || t.push(r)) } return pC = 0, (hC = dC).length = 0, (dC = t).length > 0 } var bC = "[-+]?\\d*\\.?\\d+", xC = bC + "%"; function AC(...e) { return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)" } var SC = new RegExp("rgb" + AC(bC, bC, bC)), MC = new RegExp("rgba" + AC(bC, bC, bC, bC)), wC = new RegExp("hsl" + AC(bC, xC, xC)), _C = new RegExp("hsla" + AC(bC, xC, xC, bC)), EC = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, CC = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, TC = /^#([0-9a-fA-F]{6})$/, RC = /^#([0-9a-fA-F]{8})$/; function BC(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function IC(e, t, n) { const r = n < .5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r, a = BC(i, r, e + 1 / 3), o = BC(i, r, e), s = BC(i, r, e - 1 / 3); return Math.round(255 * a) << 24 | Math.round(255 * o) << 16 | Math.round(255 * s) << 8 } function PC(e) { const t = parseInt(e, 10); return t < 0 ? 0 : t > 255 ? 255 : t } function LC(e) { return (parseFloat(e) % 360 + 360) % 360 / 360 } function DC(e) { const t = parseFloat(e); return t < 0 ? 0 : t > 1 ? 255 : Math.round(255 * t) } function kC(e) { const t = parseFloat(e); return t < 0 ? 0 : t > 100 ? 1 : t / 100 } function NC(e) { let t = function (e) { let t; return "number" == typeof e ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = TC.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : oC && void 0 !== oC[e] ? oC[e] : (t = SC.exec(e)) ? (PC(t[1]) << 24 | PC(t[2]) << 16 | PC(t[3]) << 8 | 255) >>> 0 : (t = MC.exec(e)) ? (PC(t[1]) << 24 | PC(t[2]) << 16 | PC(t[3]) << 8 | DC(t[4])) >>> 0 : (t = EC.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + "ff", 16) >>> 0 : (t = RC.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = CC.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = wC.exec(e)) ? (255 | IC(LC(t[1]), kC(t[2]), kC(t[3]))) >>> 0 : (t = _C.exec(e)) ? (IC(LC(t[1]), kC(t[2]), kC(t[3])) | DC(t[4])) >>> 0 : null }(e); return null === t ? e : (t = t || 0, `rgba(${(4278190080 & t) >>> 24}, ${(16711680 & t) >>> 16}, ${(65280 & t) >>> 8}, ${(255 & t) / 255})`) } var FC = (e, t, n) => { if (KE.fun(e)) return e; if (KE.arr(e)) return FC({ range: e, output: t, extrapolate: n }); if (KE.str(e.output[0])) return nC(e); const r = e, i = r.output, a = r.range || [0, 1], o = r.extrapolateLeft || r.extrapolate || "extend", s = r.extrapolateRight || r.extrapolate || "extend", l = r.easing || (e => e); return e => { const t = function (e, t) { for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n); return n - 1 }(e, a); return function (e, t, n, r, i, a, o, s, l) { let c = l ? l(e) : e; if (c < t) { if ("identity" === o) return c; "clamp" === o && (c = t) } if (c > n) { if ("identity" === s) return c; "clamp" === s && (c = n) } return r === i ? r : t === n ? e <= t ? r : i : (t === -1 / 0 ? c = -c : n === 1 / 0 ? c -= t : c = (c - t) / (n - t), c = a(c), r === -1 / 0 ? c = -c : i === 1 / 0 ? c += r : c = c * (i - r) + r, c) }(e, a[t], a[t + 1], i[t], i[t + 1], l, o, s, r.map) } }, OC = 1.70158, UC = 1.525 * OC, zC = OC + 1, HC = 2 * Math.PI / 3, GC = 2 * Math.PI / 4.5, jC = e => { const t = 7.5625, n = 2.75; return e < 1 / n ? t * e * e : e < 2 / n ? t * (e -= 1.5 / n) * e + .75 : e < 2.5 / n ? t * (e -= 2.25 / n) * e + .9375 : t * (e -= 2.625 / n) * e + .984375 }, VC = { linear: e => e, easeInQuad: e => e * e, easeOutQuad: e => 1 - (1 - e) * (1 - e), easeInOutQuad: e => e < .5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2, easeInCubic: e => e * e * e, easeOutCubic: e => 1 - Math.pow(1 - e, 3), easeInOutCubic: e => e < .5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2, easeInQuart: e => e * e * e * e, easeOutQuart: e => 1 - Math.pow(1 - e, 4), easeInOutQuart: e => e < .5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2, easeInQuint: e => e * e * e * e * e, easeOutQuint: e => 1 - Math.pow(1 - e, 5), easeInOutQuint: e => e < .5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2, easeInSine: e => 1 - Math.cos(e * Math.PI / 2), easeOutSine: e => Math.sin(e * Math.PI / 2), easeInOutSine: e => -(Math.cos(Math.PI * e) - 1) / 2, easeInExpo: e => 0 === e ? 0 : Math.pow(2, 10 * e - 10), easeOutExpo: e => 1 === e ? 1 : 1 - Math.pow(2, -10 * e), easeInOutExpo: e => 0 === e ? 0 : 1 === e ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2, easeInCirc: e => 1 - Math.sqrt(1 - Math.pow(e, 2)), easeOutCirc: e => Math.sqrt(1 - Math.pow(e - 1, 2)), easeInOutCirc: e => e < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2, easeInBack: e => zC * e * e * e - OC * e * e, easeOutBack: e => 1 + zC * Math.pow(e - 1, 3) + OC * Math.pow(e - 1, 2), easeInOutBack: e => e < .5 ? Math.pow(2 * e, 2) * (7.189819 * e - UC) / 2 : (Math.pow(2 * e - 2, 2) * ((UC + 1) * (2 * e - 2) + UC) + 2) / 2, easeInElastic: e => 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((10 * e - 10.75) * HC), easeOutElastic: e => 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin((10 * e - .75) * HC) + 1, easeInOutElastic: e => 0 === e ? 0 : 1 === e ? 1 : e < .5 ? -Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * GC) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * GC) / 2 + 1, easeInBounce: e => 1 - jC(1 - e), easeOutBounce: jC, easeInOutBounce: e => e < .5 ? (1 - jC(1 - 2 * e)) / 2 : (1 + jC(2 * e - 1)) / 2, steps: (e, t = "end") => n => { const r = (n = "end" === t ? Math.min(n, .999) : Math.max(n, .001)) * e; return i = ("end" === t ? Math.floor(r) : Math.ceil(r)) / e, Math.min(Math.max(i, 0), 1); var i } }, WC = Symbol.for("FluidValue.get"), XC = Symbol.for("FluidValue.observers"), JC = e => Boolean(e && e[WC]), YC = e => e && e[WC] ? e[WC]() : e, QC = e => e[XC] || null; function KC(e, t) { const n = e[XC]; n && n.forEach((e => { !function (e, t) { e.eventObserved ? e.eventObserved(t) : e(t) }(e, t) })) } var qC = class { constructor(e) { if (!e && !(e = this.get)) throw Error("Unknown getter"); ZC(this, e) } }, ZC = (e, t) => nT(e, WC, t); function $C(e, t) { if (e[WC]) { let n = e[XC]; n || nT(e, XC, n = new Set), n.has(t) || (n.add(t), e.observerAdded && e.observerAdded(n.size, t)) } return t } function eT(e, t) { const n = e[XC]; if (n && n.has(t)) { const r = n.size - 1; r ? n.delete(t) : e[XC] = null, e.observerRemoved && e.observerRemoved(r, t) } } var tT, nT = (e, t, n) => Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 }), rT = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, iT = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, aT = new RegExp(`(${rT.source})(%|[a-z]+)`, "i"), oT = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, sT = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, lT = e => { const [t, n] = cT(e); if (!t || aC()) return e; const r = window.getComputedStyle(document.documentElement).getPropertyValue(t); if (r) return r.trim(); if (n && n.startsWith("--")) { return window.getComputedStyle(document.documentElement).getPropertyValue(n) || e } return n && sT.test(n) ? lT(n) : n || e }, cT = e => { const t = sT.exec(e); if (!t) return [,]; const [, n, r] = t; return [n, r] }, uT = (e, t, n, r, i) => `rgba(${Math.round(t)}, ${Math.round(n)}, ${Math.round(r)}, ${i})`, dT = e => { tT || (tT = oC ? new RegExp(`(${Object.keys(oC).join("|")})(?!\\w)`, "g") : /^\b$/); const t = e.output.map((e => YC(e).replace(sT, lT).replace(iT, NC).replace(tT, NC))), n = t.map((e => e.match(rT).map(Number))), r = n[0].map(((e, t) => n.map((e => { if (!(t in e)) throw Error('The arity of each "output" value must be equal'); return e[t] })))), i = r.map((t => FC({ ...e, output: t }))); return e => { const n = !aT.test(t[0]) && t.find((e => aT.test(e)))?.replace(rT, ""); let r = 0; return t[0].replace(rT, (() => `${i[r++](e)}${n || ""}`)).replace(oT, uT) } }, hT = "react-spring: ", pT = e => { const t = e; let n = !1; if ("function" != typeof t) throw new TypeError(`${hT}once requires a function parameter`); return (...e) => { n || (t(...e), n = !0) } }, fT = pT(console.warn), mT = pT(console.warn); function gT(e) { return KE.str(e) && ("#" == e[0] || /\d/.test(e) || !aC() && sT.test(e) || e in (oC || {})) } var vT = aC() ? n.useEffect : n.useLayoutEffect; function yT() { const e = (0, n.useState)()[1], t = (() => { const e = (0, n.useRef)(!1); return vT((() => (e.current = !0, () => { e.current = !1 })), []), e })(); return () => { t.current && e(Math.random()) } } var bT = e => (0, n.useEffect)(e, xT), xT = []; function AT(e) { const t = (0, n.useRef)(); return (0, n.useEffect)((() => { t.current = e })), t.current } var ST = Symbol.for("Animated:node"), MT = e => e && e[ST], wT = (e, t) => { return n = e, r = ST, i = t, Object.defineProperty(n, r, { value: i, writable: !0, configurable: !0 }); var n, r, i }, _T = e => e && e[ST] && e[ST].getPayload(), ET = class { constructor() { wT(this, this) } getPayload() { return this.payload || [] } }, CT = class extends ET { constructor(e) { super(), this._value = e, this.done = !0, this.durationProgress = 0, KE.num(this._value) && (this.lastPosition = this._value) } static create(e) { return new CT(e) } getPayload() { return [this] } getValue() { return this._value } setValue(e, t) { return KE.num(e) && (this.lastPosition = e, t && (e = Math.round(e / t) * t, this.done && (this.lastPosition = e))), this._value !== e && (this._value = e, !0) } reset() { const { done: e } = this; this.done = !1, KE.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null) } }, TT = class extends CT { constructor(e) { super(0), this._string = null, this._toString = FC({ output: [e, e] }) } static create(e) { return new TT(e) } getValue() { const e = this._string; return null == e ? this._string = this._toString(this._value) : e } setValue(e) { if (KE.str(e)) { if (e == this._string) return !1; this._string = e, this._value = 1 } else { if (!super.setValue(e)) return !1; this._string = null } return !0 } reset(e) { e && (this._toString = FC({ output: [this.getValue(), e] })), this._value = 0, super.reset() } }, RT = { dependencies: null }, BT = class extends ET { constructor(e) { super(), this.source = e, this.setValue(e) } getValue(e) { const t = {}; return $E(this.source, ((n, r) => { var i; (i = n) && i[ST] === i ? t[r] = n.getValue(e) : JC(n) ? t[r] = YC(n) : e || (t[r] = n) })), t } setValue(e) { this.source = e, this.payload = this._makePayload(e) } reset() { this.payload && ZE(this.payload, (e => e.reset())) } _makePayload(e) { if (e) { const t = new Set; return $E(e, this._addToPayload, t), Array.from(t) } } _addToPayload(e) { RT.dependencies && JC(e) && RT.dependencies.add(e); const t = _T(e); t && ZE(t, (e => this.add(e))) } }, IT = class extends BT { constructor(e) { super(e) } static create(e) { return new IT(e) } getValue() { return this.source.map((e => e.getValue())) } setValue(e) { const t = this.getPayload(); return e.length == t.length ? t.map(((t, n) => t.setValue(e[n]))).some(Boolean) : (super.setValue(e.map(PT)), !0) } }; function PT(e) { return (gT(e) ? TT : CT).create(e) } function LT(e) { const t = MT(e); return t ? t.constructor : KE.arr(e) ? IT : gT(e) ? TT : CT } var DT = (e, t) => { const r = !KE.fun(e) || e.prototype && e.prototype.isReactComponent; return (0, n.forwardRef)(((i, a) => { const o = (0, n.useRef)(null), s = r && (0, n.useCallback)((e => { o.current = function (e, t) { return e && (KE.fun(e) ? e(t) : e.current = t), t }(a, e) }), [a]), [l, c] = function (e, t) { const n = new Set; return RT.dependencies = n, e.style && (e = { ...e, style: t.createAnimatedStyle(e.style) }), e = new BT(e), RT.dependencies = null, [e, n] }(i, t), u = yT(), d = () => { const e = o.current; r && !e || !1 === (!!e && t.applyAnimatedValues(e, l.getValue(!0))) && u() }, h = new kT(d, c), p = (0, n.useRef)(); vT((() => (p.current = h, ZE(c, (e => $C(e, h))), () => { p.current && (ZE(p.current.deps, (e => eT(e, p.current))), BE.cancel(p.current.update)) }))), (0, n.useEffect)(d, []), bT((() => () => { const e = p.current; ZE(e.deps, (t => eT(t, e))) })); const f = t.getComponentProps(l.getValue()); return n.createElement(e, { ...f, ref: s }) })) }, kT = class { constructor(e, t) { this.update = e, this.deps = t } eventObserved(e) { "change" == e.type && BE.write(this.update) } }, NT = Symbol.for("AnimatedComponent"), FT = e => KE.str(e) ? e : e && KE.str(e.displayName) ? e.displayName : KE.fun(e) && e.name || null; function OT(e, ...t) { return KE.fun(e) ? e(...t) : e } var UT = (e, t) => !0 === e || !!(t && e && (KE.fun(e) ? e(t) : eC(e).includes(t))), zT = (e, t) => KE.obj(e) ? t && e[t] : e, HT = (e, t) => !0 === e.default ? e[t] : e.default ? e.default[t] : void 0, GT = e => e, jT = (e, t = GT) => { let n = VT; e.default && !0 !== e.default && (e = e.default, n = Object.keys(e)); const r = {}; for (const i of n) { const n = t(e[i], i); KE.und(n) || (r[i] = n) } return r }, VT = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"], WT = { config: 1, from: 1, to: 1, ref: 1, loop: 1, reset: 1, pause: 1, cancel: 1, reverse: 1, immediate: 1, default: 1, delay: 1, onProps: 1, onStart: 1, onChange: 1, onPause: 1, onResume: 1, onRest: 1, onResolve: 1, items: 1, trail: 1, sort: 1, expires: 1, initial: 1, enter: 1, update: 1, leave: 1, children: 1, onDestroyed: 1, keys: 1, callId: 1, parentId: 1 }; function XT(e) { const t = function (e) { const t = {}; let n = 0; if ($E(e, ((e, r) => { WT[r] || (t[r] = e, n++) })), n) return t }(e); if (t) { const n = { to: t }; return $E(e, ((e, r) => r in t || (n[r] = e))), n } return { ...e } } function JT(e) { return e = YC(e), KE.arr(e) ? e.map(JT) : gT(e) ? YE.createStringInterpolator({ range: [0, 1], output: [e, e] })(1) : e } function YT(e) { return KE.fun(e) || KE.arr(e) && KE.obj(e[0]) } var QT = { tension: 170, friction: 26, mass: 1, damping: 1, easing: VC.linear, clamp: !1 }, KT = class { constructor() { this.velocity = 0, Object.assign(this, QT) } }; function qT(e, t) { if (KE.und(t.decay)) { const n = !KE.und(t.tension) || !KE.und(t.friction); !n && KE.und(t.frequency) && KE.und(t.damping) && KE.und(t.mass) || (e.duration = void 0, e.decay = void 0), n && (e.frequency = void 0) } else e.duration = void 0 } var ZT = [], $T = class { constructor() { this.changed = !1, this.values = ZT, this.toValues = null, this.fromValues = ZT, this.config = new KT, this.immediate = !1 } }; function eR(e, { key: t, props: n, defaultProps: r, state: i, actions: a }) { return new Promise(((o, s) => { let l, c, u = UT(n.cancel ?? r?.cancel, t); if (u) p(); else { KE.und(n.pause) || (i.paused = UT(n.pause, t)); let e = r?.pause; !0 !== e && (e = i.paused || UT(e, t)), l = OT(n.delay || 0, t), e ? (i.resumeQueue.add(h), a.pause()) : (a.resume(), h()) } function d() { i.resumeQueue.add(h), i.timeouts.delete(c), c.cancel(), l = c.time - BE.now() } function h() { l > 0 && !YE.skipAnimation ? (i.delayed = !0, c = BE.setTimeout(p, l), i.pauseQueue.add(d), i.timeouts.add(c)) : p() } function p() { i.delayed && (i.delayed = !1), i.pauseQueue.delete(d), i.timeouts.delete(c), e <= (i.cancelId || 0) && (u = !0); try { a.start({ ...n, callId: e, cancel: u }, o) } catch (e) { s(e) } } })) } var tR = (e, t) => 1 == t.length ? t[0] : t.some((e => e.cancelled)) ? iR(e.get()) : t.every((e => e.noop)) ? nR(e.get()) : rR(e.get(), t.every((e => e.finished))), nR = e => ({ value: e, noop: !0, finished: !0, cancelled: !1 }), rR = (e, t, n = !1) => ({ value: e, finished: t, cancelled: n }), iR = e => ({ value: e, cancelled: !0, finished: !1 }); function aR(e, t, n, r) { const { callId: i, parentId: a, onRest: o } = t, { asyncTo: s, promise: l } = n; return a || e !== s || t.reset ? n.promise = (async () => { n.asyncId = i, n.asyncTo = e; const c = jT(t, ((e, t) => "onRest" === t ? void 0 : e)); let u, d; const h = new Promise(((e, t) => (u = e, d = t))), p = e => { const t = i <= (n.cancelId || 0) && iR(r) || i !== n.asyncId && rR(r, !1); if (t) throw e.result = t, d(e), e }, f = (e, t) => { const a = new sR, o = new lR; return (async () => { if (YE.skipAnimation) throw oR(n), o.result = rR(r, !1), d(o), o; p(a); const s = KE.obj(e) ? { ...e } : { ...t, to: e }; s.parentId = i, $E(c, ((e, t) => { KE.und(s[t]) && (s[t] = e) })); const l = await r.start(s); return p(a), n.paused && await new Promise((e => { n.resumeQueue.add(e) })), l })() }; let m; if (YE.skipAnimation) return oR(n), rR(r, !1); try { let t; t = KE.arr(e) ? (async e => { for (const t of e) await f(t) })(e) : Promise.resolve(e(f, r.stop.bind(r))), await Promise.all([t.then(u), h]), m = rR(r.get(), !0, !1) } catch (e) { if (e instanceof sR) m = e.result; else { if (!(e instanceof lR)) throw e; m = e.result } } finally { i == n.asyncId && (n.asyncId = a, n.asyncTo = a ? s : void 0, n.promise = a ? l : void 0) } return KE.fun(o) && BE.batchedUpdates((() => { o(m, r, r.item) })), m })() : l } function oR(e, t) { tC(e.timeouts, (e => e.cancel())), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t) } var sR = class extends Error { constructor() { super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.") } }, lR = class extends Error { constructor() { super("SkipAnimationSignal") } }, cR = e => e instanceof dR, uR = 1, dR = class extends qC { constructor() { super(...arguments), this.id = uR++, this._priority = 0 } get priority() { return this._priority } set priority(e) { this._priority != e && (this._priority = e, this._onPriorityChange(e)) } get() { const e = MT(this); return e && e.getValue() } to(...e) { return YE.to(this, e) } interpolate(...e) { return fT(`${hT}The "interpolate" function is deprecated in v9 (use "to" instead)`), YE.to(this, e) } toJSON() { return this.get() } observerAdded(e) { 1 == e && this._attach() } observerRemoved(e) { 0 == e && this._detach() } _attach() { } _detach() { } _onChange(e, t = !1) { KC(this, { type: "change", parent: this, value: e, idle: t }) } _onPriorityChange(e) { this.idle || fC.sort(this), KC(this, { type: "priority", parent: this, priority: e }) } }, hR = Symbol.for("SpringPhase"), pR = e => (1 & e[hR]) > 0, fR = e => (2 & e[hR]) > 0, mR = e => (4 & e[hR]) > 0, gR = (e, t) => t ? e[hR] |= 3 : e[hR] &= -3, vR = (e, t) => t ? e[hR] |= 4 : e[hR] &= -5, yR = class extends dR { constructor(e, t) { if (super(), this.animation = new $T, this.defaultProps = {}, this._state = { paused: !1, delayed: !1, pauseQueue: new Set, resumeQueue: new Set, timeouts: new Set }, this._pendingCalls = new Set, this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !KE.und(e) || !KE.und(t)) { const n = KE.obj(e) ? { ...e } : { ...t, from: e }; KE.und(n.default) && (n.default = !0), this.start(n) } } get idle() { return !(fR(this) || this._state.asyncTo) || mR(this) } get goal() { return YC(this.animation.to) } get velocity() { const e = MT(this); return e instanceof CT ? e.lastVelocity || 0 : e.getPayload().map((e => e.lastVelocity || 0)) } get hasAnimated() { return pR(this) } get isAnimating() { return fR(this) } get isPaused() { return mR(this) } get isDelayed() { return this._state.delayed } advance(e) { let t = !0, n = !1; const r = this.animation; let { toValues: i } = r; const { config: a } = r, o = _T(r.to); !o && JC(r.to) && (i = eC(YC(r.to))), r.values.forEach(((s, l) => { if (s.done) return; const c = s.constructor == TT ? 1 : o ? o[l].lastPosition : i[l]; let u = r.immediate, d = c; if (!u) { if (d = s.lastPosition, a.tension <= 0) return void (s.done = !0); let t = s.elapsedTime += e; const n = r.fromValues[l], i = null != s.v0 ? s.v0 : s.v0 = KE.arr(a.velocity) ? a.velocity[l] : a.velocity; let o; const h = a.precision || (n == c ? .005 : Math.min(1, .001 * Math.abs(c - n))); if (KE.und(a.duration)) if (a.decay) { const e = !0 === a.decay ? .998 : a.decay, r = Math.exp(-(1 - e) * t); d = n + i / (1 - e) * (1 - r), u = Math.abs(s.lastPosition - d) <= h, o = i * r } else { o = null == s.lastVelocity ? i : s.lastVelocity; const t = a.restVelocity || h / 10, r = a.clamp ? 0 : a.bounce, l = !KE.und(r), p = n == c ? s.v0 > 0 : n < c; let f, m = !1; const g = 1, v = Math.ceil(e / g); for (let e = 0; e < v && (f = Math.abs(o) > t, f || (u = Math.abs(c - d) <= h, !u)); ++e)l && (m = d == c || d > c == p, m && (o = -o * r, d = c)), o += (1e-6 * -a.tension * (d - c) + .001 * -a.friction * o) / a.mass * g, d += o * g } else { let r = 1; a.duration > 0 && (this._memoizedDuration !== a.duration && (this._memoizedDuration = a.duration, s.durationProgress > 0 && (s.elapsedTime = a.duration * s.durationProgress, t = s.elapsedTime += e)), r = (a.progress || 0) + t / this._memoizedDuration, r = r > 1 ? 1 : r < 0 ? 0 : r, s.durationProgress = r), d = n + a.easing(r) * (c - n), o = (d - s.lastPosition) / e, u = 1 == r } s.lastVelocity = o, Number.isNaN(d) && (console.warn("Got NaN while animating:", this), u = !0) } o && !o[l].done && (u = !1), u ? s.done = !0 : t = !1, s.setValue(d, a.round) && (n = !0) })); const s = MT(this), l = s.getValue(); if (t) { const e = YC(r.to); l === e && !n || a.decay ? n && a.decay && this._onChange(l) : (s.setValue(e), this._onChange(e)), this._stop() } else n && this._onChange(l) } set(e) { return BE.batchedUpdates((() => { this._stop(), this._focus(e), this._set(e) })), this } pause() { this._update({ pause: !0 }) } resume() { this._update({ pause: !1 }) } finish() { if (fR(this)) { const { to: e, config: t } = this.animation; BE.batchedUpdates((() => { this._onStart(), t.decay || this._set(e, !1), this._stop() })) } return this } update(e) { return (this.queue || (this.queue = [])).push(e), this } start(e, t) { let n; return KE.und(e) ? (n = this.queue || [], this.queue = []) : n = [KE.obj(e) ? e : { ...t, to: e }], Promise.all(n.map((e => this._update(e)))).then((e => tR(this, e))) } stop(e) { const { to: t } = this.animation; return this._focus(this.get()), oR(this._state, e && this._lastCallId), BE.batchedUpdates((() => this._stop(t, e))), this } reset() { this._update({ reset: !0 }) } eventObserved(e) { "change" == e.type ? this._start() : "priority" == e.type && (this.priority = e.priority + 1) } _prepareNode(e) { const t = this.key || ""; let { to: n, from: r } = e; n = KE.obj(n) ? n[t] : n, (null == n || YT(n)) && (n = void 0), r = KE.obj(r) ? r[t] : r, null == r && (r = void 0); const i = { to: n, from: r }; return pR(this) || (e.reverse && ([n, r] = [r, n]), r = YC(r), KE.und(r) ? MT(this) || this._set(n) : this._set(r)), i } _update({ ...e }, t) { const { key: n, defaultProps: r } = this; e.default && Object.assign(r, jT(e, ((e, t) => /^on/.test(t) ? zT(e, n) : e))), _R(this, e, "onProps"), ER(this, "onProps", e, this); const i = this._prepareNode(e); if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"); const a = this._state; return eR(++this._lastCallId, { key: n, props: e, defaultProps: r, state: a, actions: { pause: () => { mR(this) || (vR(this, !0), iC(a.pauseQueue), ER(this, "onPause", rR(this, bR(this, this.animation.to)), this)) }, resume: () => { mR(this) && (vR(this, !1), fR(this) && this._resume(), iC(a.resumeQueue), ER(this, "onResume", rR(this, bR(this, this.animation.to)), this)) }, start: this._merge.bind(this, i) } }).then((n => { if (e.loop && n.finished && (!t || !n.noop)) { const t = xR(e); if (t) return this._update(t, !0) } return n })) } _merge(e, t, n) { if (t.cancel) return this.stop(!0), n(iR(this)); const r = !KE.und(e.to), i = !KE.und(e.from); if (r || i) { if (!(t.callId > this._lastToId)) return n(iR(this)); this._lastToId = t.callId } const { key: a, defaultProps: o, animation: s } = this, { to: l, from: c } = s; let { to: u = l, from: d = c } = e; !i || r || t.default && !KE.und(u) || (u = d), t.reverse && ([u, d] = [d, u]); const h = !qE(d, c); h && (s.from = d), d = YC(d); const p = !qE(u, l); p && this._focus(u); const f = YT(t.to), { config: m } = s, { decay: g, velocity: v } = m; (r || i) && (m.velocity = 0), t.config && !f && function (e, t, n) { n && (qT(n = { ...n }, t), t = { ...n, ...t }), qT(e, t), Object.assign(e, t); for (const t in QT) null == e[t] && (e[t] = QT[t]); let { frequency: r, damping: i } = e; const { mass: a } = e; KE.und(r) || (r < .01 && (r = .01), i < 0 && (i = 0), e.tension = Math.pow(2 * Math.PI / r, 2) * a, e.friction = 4 * Math.PI * i * a / r) }(m, OT(t.config, a), t.config !== o.config ? OT(o.config, a) : void 0); let y = MT(this); if (!y || KE.und(u)) return n(rR(this, !0)); const b = KE.und(t.reset) ? i && !t.default : !KE.und(d) && UT(t.reset, a), x = b ? d : this.get(), A = JT(u), S = KE.num(A) || KE.arr(A) || gT(A), M = !f && (!S || UT(o.immediate || t.immediate, a)); if (p) { const e = LT(u); if (e !== y.constructor) { if (!M) throw Error(`Cannot animate between ${y.constructor.name} and ${e.name}, as the "to" prop suggests`); y = this._set(A) } } const w = y.constructor; let _ = JC(u), E = !1; if (!_) { const e = b || !pR(this) && h; (p || e) && (E = qE(JT(x), A), _ = !E), (qE(s.immediate, M) || M) && qE(m.decay, g) && qE(m.velocity, v) || (_ = !0) } if (E && fR(this) && (s.changed && !b ? _ = !0 : _ || this._stop(l)), !f && ((_ || JC(l)) && (s.values = y.getPayload(), s.toValues = JC(u) ? null : w == TT ? [1] : eC(A)), s.immediate != M && (s.immediate = M, M || b || this._set(l)), _)) { const { onRest: e } = s; ZE(wR, (e => _R(this, t, e))); const r = rR(this, bR(this, l)); iC(this._pendingCalls, r), this._pendingCalls.add(n), s.changed && BE.batchedUpdates((() => { s.changed = !b, e?.(r, this), b ? OT(o.onRest, r) : s.onStart?.(r, this) })) } b && this._set(x), f ? n(aR(t.to, t, this._state, this)) : _ ? this._start() : fR(this) && !p ? this._pendingCalls.add(n) : n(nR(x)) } _focus(e) { const t = this.animation; e !== t.to && (QC(this) && this._detach(), t.to = e, QC(this) && this._attach()) } _attach() { let e = 0; const { to: t } = this.animation; JC(t) && ($C(t, this), cR(t) && (e = t.priority + 1)), this.priority = e } _detach() { const { to: e } = this.animation; JC(e) && eT(e, this) } _set(e, t = !0) { const n = YC(e); if (!KE.und(n)) { const e = MT(this); if (!e || !qE(n, e.getValue())) { const r = LT(n); e && e.constructor == r ? e.setValue(n) : wT(this, r.create(n)), e && BE.batchedUpdates((() => { this._onChange(n, t) })) } } return MT(this) } _onStart() { const e = this.animation; e.changed || (e.changed = !0, ER(this, "onStart", rR(this, bR(this, e.to)), this)) } _onChange(e, t) { t || (this._onStart(), OT(this.animation.onChange, e, this)), OT(this.defaultProps.onChange, e, this), super._onChange(e, t) } _start() { const e = this.animation; MT(this).reset(YC(e.to)), e.immediate || (e.fromValues = e.values.map((e => e.lastPosition))), fR(this) || (gR(this, !0), mR(this) || this._resume()) } _resume() { YE.skipAnimation ? this.finish() : fC.start(this) } _stop(e, t) { if (fR(this)) { gR(this, !1); const n = this.animation; ZE(n.values, (e => { e.done = !0 })), n.toValues && (n.onChange = n.onPause = n.onResume = void 0), KC(this, { type: "idle", parent: this }); const r = t ? iR(this.get()) : rR(this.get(), bR(this, e ?? n.to)); iC(this._pendingCalls, r), n.changed && (n.changed = !1, ER(this, "onRest", r, this)) } } }; function bR(e, t) { const n = JT(t); return qE(JT(e.get()), n) } function xR(e, t = e.loop, n = e.to) { const r = OT(t); if (r) { const i = !0 !== r && XT(r), a = (i || e).reverse, o = !i || i.reset; return AR({ ...e, loop: t, default: !1, pause: void 0, to: !a || YT(n) ? n : void 0, from: o ? e.from : void 0, reset: o, ...i }) } } function AR(e) { const { to: t, from: n } = e = XT(e), r = new Set; return KE.obj(t) && MR(t, r), KE.obj(n) && MR(n, r), e.keys = r.size ? Array.from(r) : null, e } function SR(e) { const t = AR(e); return KE.und(t.default) && (t.default = jT(t)), t } function MR(e, t) { $E(e, ((e, n) => null != e && t.add(n))) } var wR = ["onStart", "onRest", "onChange", "onPause", "onResume"]; function _R(e, t, n) { e.animation[n] = t[n] !== HT(t, n) ? zT(t[n], e.key) : void 0 } function ER(e, t, ...n) { e.animation[t]?.(...n), e.defaultProps[t]?.(...n) } var CR = ["onStart", "onChange", "onRest"], TR = 1, RR = class { constructor(e, t) { this.id = TR++, this.springs = {}, this.queue = [], this._lastAsyncId = 0, this._active = new Set, this._changed = new Set, this._started = !1, this._state = { paused: !1, pauseQueue: new Set, resumeQueue: new Set, timeouts: new Set }, this._events = { onStart: new Map, onChange: new Map, onRest: new Map }, this._onFrame = this._onFrame.bind(this), t && (this._flush = t), e && this.start({ default: !0, ...e }) } get idle() { return !this._state.asyncTo && Object.values(this.springs).every((e => e.idle && !e.isDelayed && !e.isPaused)) } get item() { return this._item } set item(e) { this._item = e } get() { const e = {}; return this.each(((t, n) => e[n] = t.get())), e } set(e) { for (const t in e) { const n = e[t]; KE.und(n) || this.springs[t].set(n) } } update(e) { return e && this.queue.push(AR(e)), this } start(e) { let { queue: t } = this; return e ? t = eC(e).map(AR) : this.queue = [], this._flush ? this._flush(this, t) : (NR(this, t), BR(this, t)) } stop(e, t) { if (e !== !!e && (t = e), t) { const n = this.springs; ZE(eC(t), (t => n[t].stop(!!e))) } else oR(this._state, this._lastAsyncId), this.each((t => t.stop(!!e))); return this } pause(e) { if (KE.und(e)) this.start({ pause: !0 }); else { const t = this.springs; ZE(eC(e), (e => t[e].pause())) } return this } resume(e) { if (KE.und(e)) this.start({ pause: !1 }); else { const t = this.springs; ZE(eC(e), (e => t[e].resume())) } return this } each(e) { $E(this.springs, e) } _onFrame() { const { onStart: e, onChange: t, onRest: n } = this._events, r = this._active.size > 0, i = this._changed.size > 0; (r && !this._started || i && !this._started) && (this._started = !0, tC(e, (([e, t]) => { t.value = this.get(), e(t, this, this._item) }))); const a = !r && this._started, o = i || a && n.size ? this.get() : null; i && t.size && tC(t, (([e, t]) => { t.value = o, e(t, this, this._item) })), a && (this._started = !1, tC(n, (([e, t]) => { t.value = o, e(t, this, this._item) }))) } eventObserved(e) { if ("change" == e.type) this._changed.add(e.parent), e.idle || this._active.add(e.parent); else { if ("idle" != e.type) return; this._active.delete(e.parent) } BE.onFrame(this._onFrame) } }; function BR(e, t) { return Promise.all(t.map((t => IR(e, t)))).then((t => tR(e, t))) } async function IR(e, t, n) { const { keys: r, to: i, from: a, loop: o, onRest: s, onResolve: l } = t, c = KE.obj(t.default) && t.default; o && (t.loop = !1), !1 === i && (t.to = null), !1 === a && (t.from = null); const u = KE.arr(i) || KE.fun(i) ? i : void 0; u ? (t.to = void 0, t.onRest = void 0, c && (c.onRest = void 0)) : ZE(CR, (n => { const r = t[n]; if (KE.fun(r)) { const i = e._events[n]; t[n] = ({ finished: e, cancelled: t }) => { const n = i.get(r); n ? (e || (n.finished = !1), t && (n.cancelled = !0)) : i.set(r, { value: null, finished: e || !1, cancelled: t || !1 }) }, c && (c[n] = t[n]) } })); const d = e._state; t.pause === !d.paused ? (d.paused = t.pause, iC(t.pause ? d.pauseQueue : d.resumeQueue)) : d.paused && (t.pause = !0); const h = (r || Object.keys(e.springs)).map((n => e.springs[n].start(t))), p = !0 === t.cancel || !0 === HT(t, "cancel"); (u || p && d.asyncId) && h.push(eR(++e._lastAsyncId, { props: t, state: d, actions: { pause: QE, resume: QE, start(t, n) { p ? (oR(d, e._lastAsyncId), n(iR(e))) : (t.onRest = s, n(aR(u, t, d, e))) } } })), d.paused && await new Promise((e => { d.resumeQueue.add(e) })); const f = tR(e, await Promise.all(h)); if (o && f.finished && (!n || !f.noop)) { const n = xR(t, o, i); if (n) return NR(e, [n]), IR(e, n, !0) } return l && BE.batchedUpdates((() => l(f, e, e.item))), f } function PR(e, t) { const n = { ...e.springs }; return t && ZE(eC(t), (e => { KE.und(e.keys) && (e = AR(e)), KE.obj(e.to) || (e = { ...e, to: void 0 }), kR(n, e, (e => DR(e))) })), LR(e, n), n } function LR(e, t) { $E(t, ((t, n) => { e.springs[n] || (e.springs[n] = t, $C(t, e)) })) } function DR(e, t) { const n = new yR; return n.key = e, t && $C(n, t), n } function kR(e, t, n) { t.keys && ZE(t.keys, (r => { (e[r] || (e[r] = n(r)))._prepareNode(t) })) } function NR(e, t) { ZE(t, (t => { kR(e.springs, t, (t => DR(t, e))) })) } var FR, OR, UR = ({ children: e, ...t }) => { const r = (0, n.useContext)(zR), i = t.pause || !!r.pause, a = t.immediate || !!r.immediate; t = function (e, t) { const [r] = (0, n.useState)((() => ({ inputs: t, result: e() }))), i = (0, n.useRef)(), a = i.current; let o = a; if (o) { const n = Boolean(t && o.inputs && function (e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1; return !0 }(t, o.inputs)); n || (o = { inputs: t, result: e() }) } else o = r; return (0, n.useEffect)((() => { i.current = o, a == r && (r.inputs = r.result = void 0) }), [o]), o.result }((() => ({ pause: i, immediate: a })), [i, a]); const { Provider: o } = zR; return n.createElement(o, { value: t }, e) }, zR = (FR = UR, OR = {}, Object.assign(FR, n.createContext(OR)), FR.Provider._context = FR, FR.Consumer._context = FR, FR); UR.Provider = zR.Provider, UR.Consumer = zR.Consumer; var HR = () => { const e = [], t = function (t) { mT(`${hT}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`); const r = []; return ZE(e, ((e, i) => { if (KE.und(t)) r.push(e.start()); else { const a = n(t, e, i); a && r.push(e.start(a)) } })), r }; t.current = e, t.add = function (t) { e.includes(t) || e.push(t) }, t.delete = function (t) { const n = e.indexOf(t); ~n && e.splice(n, 1) }, t.pause = function () { return ZE(e, (e => e.pause(...arguments))), this }, t.resume = function () { return ZE(e, (e => e.resume(...arguments))), this }, t.set = function (t) { ZE(e, ((e, n) => { const r = KE.fun(t) ? t(n, e) : t; r && e.set(r) })) }, t.start = function (t) { const n = []; return ZE(e, ((e, r) => { if (KE.und(t)) n.push(e.start()); else { const i = this._getProps(t, e, r); i && n.push(e.start(i)) } })), n }, t.stop = function () { return ZE(e, (e => e.stop(...arguments))), this }, t.update = function (t) { return ZE(e, ((e, n) => e.update(this._getProps(t, e, n)))), this }; const n = function (e, t, n) { return KE.fun(e) ? e(n, t) : e }; return t._getProps = n, t }; function GR(e, t) { const r = KE.fun(e), [[i], a] = function (e, t, r) { const i = KE.fun(t) && t; i && !r && (r = []); const a = (0, n.useMemo)((() => i || 3 == arguments.length ? HR() : void 0), []), o = (0, n.useRef)(0), s = yT(), l = (0, n.useMemo)((() => ({ ctrls: [], queue: [], flush(e, t) { const n = PR(e, t); return o.current > 0 && !l.queue.length && !Object.keys(n).some((t => !e.springs[t])) ? BR(e, t) : new Promise((r => { LR(e, n), l.queue.push((() => { r(BR(e, t)) })), s() })) } })), []), c = (0, n.useRef)([...l.ctrls]), u = [], d = AT(e) || 0; function h(e, n) { for (let r = e; r < n; r++) { const e = c.current[r] || (c.current[r] = new RR(null, l.flush)), n = i ? i(r, e) : t[r]; n && (u[r] = SR(n)) } } (0, n.useMemo)((() => { ZE(c.current.slice(e, d), (e => { (function (e, t) { e.ref?.delete(e), t?.delete(e) })(e, a), e.stop(!0) })), c.current.length = e, h(d, e) }), [e]), (0, n.useMemo)((() => { h(0, Math.min(d, e)) }), r); const p = c.current.map(((e, t) => PR(e, u[t]))), f = (0, n.useContext)(UR), m = AT(f), g = f !== m && function (e) { for (const t in e) return !0; return !1 }(f); vT((() => { o.current++, l.ctrls = c.current; const { queue: e } = l; e.length && (l.queue = [], ZE(e, (e => e()))), ZE(c.current, ((e, t) => { a?.add(e), g && e.start({ default: f }); const n = u[t]; n && (function (e, t) { t && e.ref !== t && (e.ref?.delete(e), t.add(e), e.ref = t) }(e, n.ref), e.ref ? e.queue.push(n) : e.start(n)) })) })), bT((() => () => { ZE(l.ctrls, (e => e.stop(!0))) })); const v = p.map((e => ({ ...e }))); return a ? [v, a] : v }(1, r ? e : [e], r ? t || [] : t); return r || 2 == arguments.length ? [i, a] : i } var jR = class extends dR { constructor(e, t) { super(), this.source = e, this.idle = !0, this._active = new Set, this.calc = FC(...t); const n = this._get(), r = LT(n); wT(this, r.create(n)) } advance(e) { const t = this._get(); qE(t, this.get()) || (MT(this).setValue(t), this._onChange(t, this.idle)), !this.idle && WR(this._active) && XR(this) } _get() { const e = KE.arr(this.source) ? this.source.map(YC) : eC(YC(this.source)); return this.calc(...e) } _start() { this.idle && !WR(this._active) && (this.idle = !1, ZE(_T(this), (e => { e.done = !1 })), YE.skipAnimation ? (BE.batchedUpdates((() => this.advance())), XR(this)) : fC.start(this)) } _attach() { let e = 1; ZE(eC(this.source), (t => { JC(t) && $C(t, this), cR(t) && (t.idle || this._active.add(t), e = Math.max(e, t.priority + 1)) })), this.priority = e, this._start() } _detach() { ZE(eC(this.source), (e => { JC(e) && eT(e, this) })), this._active.clear(), XR(this) } eventObserved(e) { "change" == e.type ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : "idle" == e.type ? this._active.delete(e.parent) : "priority" == e.type && (this.priority = eC(this.source).reduce(((e, t) => Math.max(e, (cR(t) ? t.priority : 0) + 1)), 0)) } }; function VR(e) { return !1 !== e.idle } function WR(e) { return !e.size || Array.from(e).every(VR) } function XR(e) { e.idle || (e.idle = !0, ZE(_T(e), (e => { e.done = !0 })), KC(e, { type: "idle", parent: e })) } YE.assign({ createStringInterpolator: dT, to: (e, t) => new jR(e, t) }), fC.advance; var JR = ["primitive"].concat(Object.keys(e).filter((e => /^[A-Z]/.test(e))).map((e => e[0].toLowerCase() + e.slice(1)))); YE.assign({ createStringInterpolator: dT, colors: { transparent: 0, aliceblue: 4042850303, antiquewhite: 4209760255, aqua: 16777215, aquamarine: 2147472639, azure: 4043309055, beige: 4126530815, bisque: 4293182719, black: 255, blanchedalmond: 4293643775, blue: 65535, blueviolet: 2318131967, brown: 2771004159, burlywood: 3736635391, burntsienna: 3934150143, cadetblue: 1604231423, chartreuse: 2147418367, chocolate: 3530104575, coral: 4286533887, cornflowerblue: 1687547391, cornsilk: 4294499583, crimson: 3692313855, cyan: 16777215, darkblue: 35839, darkcyan: 9145343, darkgoldenrod: 3095792639, darkgray: 2846468607, darkgreen: 6553855, darkgrey: 2846468607, darkkhaki: 3182914559, darkmagenta: 2332068863, darkolivegreen: 1433087999, darkorange: 4287365375, darkorchid: 2570243327, darkred: 2332033279, darksalmon: 3918953215, darkseagreen: 2411499519, darkslateblue: 1211993087, darkslategray: 793726975, darkslategrey: 793726975, darkturquoise: 13554175, darkviolet: 2483082239, deeppink: 4279538687, deepskyblue: 12582911, dimgray: 1768516095, dimgrey: 1768516095, dodgerblue: 512819199, firebrick: 2988581631, floralwhite: 4294635775, forestgreen: 579543807, fuchsia: 4278255615, gainsboro: 3705462015, ghostwhite: 4177068031, gold: 4292280575, goldenrod: 3668254975, gray: 2155905279, green: 8388863, greenyellow: 2919182335, grey: 2155905279, honeydew: 4043305215, hotpink: 4285117695, indianred: 3445382399, indigo: 1258324735, ivory: 4294963455, khaki: 4041641215, lavender: 3873897215, lavenderblush: 4293981695, lawngreen: 2096890111, lemonchiffon: 4294626815, lightblue: 2916673279, lightcoral: 4034953471, lightcyan: 3774873599, lightgoldenrodyellow: 4210742015, lightgray: 3553874943, lightgreen: 2431553791, lightgrey: 3553874943, lightpink: 4290167295, lightsalmon: 4288707327, lightseagreen: 548580095, lightskyblue: 2278488831, lightslategray: 2005441023, lightslategrey: 2005441023, lightsteelblue: 2965692159, lightyellow: 4294959359, lime: 16711935, limegreen: 852308735, linen: 4210091775, magenta: 4278255615, maroon: 2147483903, mediumaquamarine: 1724754687, mediumblue: 52735, mediumorchid: 3126187007, mediumpurple: 2473647103, mediumseagreen: 1018393087, mediumslateblue: 2070474495, mediumspringgreen: 16423679, mediumturquoise: 1221709055, mediumvioletred: 3340076543, midnightblue: 421097727, mintcream: 4127193855, mistyrose: 4293190143, moccasin: 4293178879, navajowhite: 4292783615, navy: 33023, oldlace: 4260751103, olive: 2155872511, olivedrab: 1804477439, orange: 4289003775, orangered: 4282712319, orchid: 3664828159, palegoldenrod: 4008225535, palegreen: 2566625535, paleturquoise: 2951671551, palevioletred: 3681588223, papayawhip: 4293907967, peachpuff: 4292524543, peru: 3448061951, pink: 4290825215, plum: 3718307327, powderblue: 2967529215, purple: 2147516671, rebeccapurple: 1714657791, red: 4278190335, rosybrown: 3163525119, royalblue: 1097458175, saddlebrown: 2336560127, salmon: 4202722047, sandybrown: 4104413439, seagreen: 780883967, seashell: 4294307583, sienna: 2689740287, silver: 3233857791, skyblue: 2278484991, slateblue: 1784335871, slategray: 1887473919, slategrey: 1887473919, snow: 4294638335, springgreen: 16744447, steelblue: 1182971135, tan: 3535047935, teal: 8421631, thistle: 3636451583, tomato: 4284696575, turquoise: 1088475391, violet: 4001558271, wheat: 4125012991, white: 4294967295, whitesmoke: 4126537215, yellow: 4294902015, yellowgreen: 2597139199 }, frameLoop: "demand" }), function (e, t) { const n = { callback: e }; t.add(n) }((() => { BE.advance() }), i_); var YR = ((e, { applyAnimatedValues: t = () => !1, createAnimatedStyle: n = e => new BT(e), getComponentProps: r = e => e } = {}) => { const i = { applyAnimatedValues: t, createAnimatedStyle: n, getComponentProps: r }, a = e => { const t = FT(e) || "Anonymous"; return (e = KE.str(e) ? a[e] || (a[e] = DT(e, i)) : e[NT] || (e[NT] = DT(e, i))).displayName = `Animated(${t})`, e }; return $E(e, ((t, n) => { KE.arr(e) && (n = FT(t)), a[n] = a(t) })), { animated: a } })(JR, { applyAnimatedValues: x_ }), QR = YR.animated; const KR = e => { const t = "p2" === e.cube.player && e.vsAI ? 500 : 0, { yOffset: n } = GR({ yOffset: 0, from: { yOffset: 20 }, config: { mass: 1.5, friction: 30 }, delay: t }); return (0, ii.jsx)(QR.mesh, { position: n.to((e => [0, e, 0])), children: (0, ii.jsx)(TE, { args: [.99, .99, .99], position: e.cube.position, castShadow: !1, radius: .05, smoothness: 4, onClick: t => { t.stopPropagation(), e.update({ type: "PreviewPiece", data: [e.cube.position[0], e.cube.position[1] + 1, e.cube.position[2]] }) }, children: (0, ii.jsx)("meshPhongMaterial", { color: A[e.cube.player] }) }) }) }, qR = e => { const t = e.boardState.board.cells.flatMap(((e, t) => e.flatMap(((e, n) => e.map(((e, r) => ({ position: [t, n, r], cell: e }))))))).filter((e => "Player" === e.cell.type)).map((e => ({ position: e.position, error: null, player: "Player" === e.cell.type ? e.cell.data : "p1" }))); return (0, ii.jsx)(ii.Fragment, { children: t.map((t => (0, ii.jsx)(KR, { cube: t, update: e.update, vsAI: e.vsAI }, t.position.toString()))) }) }; let ZR, $R = 0, eB = null; function tB() { return null !== eB && 0 !== eB.byteLength || (eB = new Uint8Array(ZR.memory.buffer)), eB } const nB = "undefined" != typeof TextEncoder ? new TextEncoder("utf-8") : { encode: () => { throw Error("TextEncoder not available") } }, rB = "function" == typeof nB.encodeInto ? function (e, t) { return nB.encodeInto(e, t) } : function (e, t) { const n = nB.encode(e); return t.set(n), { read: e.length, written: n.length } }; function iB(e, t, n) { if (void 0 === n) { const n = nB.encode(e), r = t(n.length, 1) >>> 0; return tB().subarray(r, r + n.length).set(n), $R = n.length, r } let r = e.length, i = t(r, 1) >>> 0; const a = tB(); let o = 0; for (; o < r; o++) { const t = e.charCodeAt(o); if (t > 127) break; a[i + o] = t } if (o !== r) { 0 !== o && (e = e.slice(o)), i = n(i, r, r = o + 3 * e.length, 1) >>> 0; const t = tB().subarray(i + o, i + r); o += rB(e, t).written } return $R = o, i } let aB = null; function oB() { return null !== aB && 0 !== aB.byteLength || (aB = new Int32Array(ZR.memory.buffer)), aB } const sB = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => { throw Error("TextDecoder not available") } }; function lB(e, t) { return e >>>= 0, sB.decode(tB().subarray(e, e + t)) } function cB(e) { let t, n; try { const a = ZR.__wbindgen_add_to_stack_pointer(-16), o = iB(e, ZR.__wbindgen_malloc, ZR.__wbindgen_realloc), s = $R; ZR.new_game(a, o, s); var r = oB()[a / 4 + 0], i = oB()[a / 4 + 1]; return t = r, n = i, lB(r, i) } finally { ZR.__wbindgen_add_to_stack_pointer(16), ZR.__wbindgen_free(t, n, 1) } } function uB(e, t) { let n, r; try { const o = ZR.__wbindgen_add_to_stack_pointer(-16), s = iB(e, ZR.__wbindgen_malloc, ZR.__wbindgen_realloc), l = $R, c = iB(t, ZR.__wbindgen_malloc, ZR.__wbindgen_realloc), u = $R; ZR.next_game_state(o, s, l, c, u); var i = oB()[o / 4 + 0], a = oB()[o / 4 + 1]; return n = i, r = a, lB(i, a) } finally { ZR.__wbindgen_add_to_stack_pointer(16), ZR.__wbindgen_free(n, r, 1) } } function dB(e, t) { return ZR = e.exports, pB.__wbindgen_wasm_module = t, aB = null, eB = null, ZR } function hB(e) { if (void 0 !== ZR) return ZR; const t = { wbg: {} }; return e instanceof WebAssembly.Module || (e = new WebAssembly.Module(e)), dB(new WebAssembly.Instance(e, t), e) } async function pB(e) { if (void 0 !== ZR) return ZR; void 0 === e && (e = new URL(i(985), i.b)); const t = { wbg: {} }; ("string" == typeof e || "function" == typeof Request && e instanceof Request || "function" == typeof URL && e instanceof URL) && (e = fetch(e)); const { instance: n, module: r } = await async function (e, t) { if ("function" == typeof Response && e instanceof Response) { if ("function" == typeof WebAssembly.instantiateStreaming) try { return await WebAssembly.instantiateStreaming(e, t) } catch (t) { if ("application/wasm" == e.headers.get("Content-Type")) throw t; console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t) } const n = await e.arrayBuffer(); return await WebAssembly.instantiate(n, t) } { const n = await WebAssembly.instantiate(e, t); return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n } }(await e, t); return dB(n, r) } "undefined" != typeof TextDecoder && sB.decode(); const fB = pB; function mB(e) { const t = e.gameState.board_state.previewed_piece; return (0, ii.jsx)("group", { castShadow: !1, receiveShadow: !1, children: t?.map((e => (0, ii.jsx)(gB, { cube: e }, JSON.stringify(e)))) }) } function gB(e) { const t = e.cube.error ? "red" : A[e.cube.player]; return (0, ii.jsxs)("mesh", { castShadow: !1, position: e.cube.position, children: [(0, ii.jsx)("boxGeometry", { args: [1, 1, 1] }), (0, ii.jsx)("meshStandardMaterial", { color: t, opacity: .5, transparent: !0 })] }) } const vB = n.forwardRef((function ({ children: e, disable: t, disableX: r, disableY: i, disableZ: a, left: o, right: s, top: l, bottom: c, front: u, back: d, onCentered: h, precise: p = !0, cacheKey: f = 0, ...m }, g) { const v = n.useRef(null), y = n.useRef(null), b = n.useRef(null); return n.useLayoutEffect((() => { y.current.matrixWorld.identity(); const e = (new Wh).setFromObject(b.current, p), n = new Gh, f = new cp, m = e.max.x - e.min.x, g = e.max.y - e.min.y, x = e.max.z - e.min.z; e.getCenter(n), e.getBoundingSphere(f); const A = l ? g / 2 : c ? -g / 2 : 0, S = o ? -m / 2 : s ? m / 2 : 0, M = u ? x / 2 : d ? -x / 2 : 0; y.current.position.set(t || r ? 0 : -n.x + S, t || i ? 0 : -n.y + A, t || a ? 0 : -n.z + M), void 0 !== h && h({ parent: v.current.parent, container: v.current, width: m, height: g, depth: x, boundingBox: e, boundingSphere: f, center: n, verticalAlignment: A, horizontalAlignment: S, depthAlignment: M }) }), [f, h, l, o, u, t, r, i, a, p, s, c, d]), n.useImperativeHandle(g, (() => v.current), []), n.createElement("group", _({ ref: v }, m), n.createElement("group", { ref: y }, n.createElement("group", { ref: b }, e))) })); function yB(e) { return (0, ii.jsx)(vB, { onCentered: () => { }, children: e.piece.coords.map((t => (0, ii.jsx)(bB, { cube: { player: e.owner, position: t, error: null }, selected: 0 === t[0] && 0 === t[1] && 0 === t[2], setSelectedPieceOrigin: () => e.update({ type: "SetSelectedPieceOrigin", data: t }) }, JSON.stringify(t)))) }) } function bB(e) { return (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)(TE, { args: [.99, .99, .99], radius: .05, smoothness: 4, position: e.cube.position, onClick: t => { t.stopPropagation(), e.setSelectedPieceOrigin() }, children: (0, ii.jsx)("meshPhongMaterial", { color: A[e.cube.player] }) }), e.selected && (0, ii.jsx)(xB, {})] }) } function xB() { return (0, ii.jsx)(yE, { geometry: new em(1, 1, 1), simplify: !1, fillOpacity: 0, stroke: "#000000", thickness: .15 }) } const AB = new WeakMap; class SB extends $A { constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, n, r) { const i = new nS(this.manager); i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, (e => { const n = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(e, n).then(t).catch(r) }), n, r) } decodeDracoFile(e, t, n, r) { const i = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n }; this.decodeGeometry(e, i).then(t) } decodeGeometry(e, t) { for (const e in t.attributeTypes) { const n = t.attributeTypes[e]; void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name) } const n = JSON.stringify(t); if (AB.has(e)) { const t = AB.get(e); if (t.key === n) return t.promise; if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r; const i = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(i, a).then((n => (r = n, new Promise(((n, a) => { r._callbacks[i] = { resolve: n, reject: a }, r.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]) }))))).then((e => this._createGeometry(e.geometry))); return o.catch((() => !0)).then((() => { r && i && this._releaseTask(r, i) })), AB.set(e, { key: n, promise: o }), o } _createGeometry(e) { const t = new zf; e.index && t.setIndex(new Mf(e.index.array, 1)); for (let n = 0; n < e.attributes.length; n++) { const r = e.attributes[n], i = r.name, a = r.array, o = r.itemSize; t.setAttribute(i, new Mf(a, o)) } return t } _loadLibrary(e, t) { const n = new nS(this.manager); return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, r) => { n.load(e, t, void 0, r) })) } preload() { return this._initDecoder(), this } _initDecoder() { if (this.decoderPending) return this.decoderPending; const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => { const n = t[0]; e || (this.decoderConfig.wasmBinary = t[1]); const r = MB.toString(), i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([i])) })), this.decoderPending } _getWorker(e, t) { return this._initDecoder().then((() => { if (this.workerPool.length < this.workerLimit) { const e = new Worker(this.workerSourceURL); e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e.onmessage = function (t) { const n = t.data; switch (n.type) { case "decode": e._callbacks[n.id].resolve(n); break; case "error": e._callbacks[n.id].reject(n); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"') } }, this.workerPool.push(e) } else this.workerPool.sort((function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 })); const n = this.workerPool[this.workerPool.length - 1]; return n._taskCosts[e] = t, n._taskLoad += t, n })) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map((e => e._taskLoad))) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this } } function MB() { let e, t; function n(e, t, n, r, i, a) { const o = a.num_components(), s = n.num_points() * o, l = s * i.BYTES_PER_ELEMENT, c = function (e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(e, i), u = e._malloc(l); t.GetAttributeDataArrayForAllPoints(n, a, c, l, u); const d = new i(e.HEAPF32.buffer, u, s).slice(); return e._free(u), { name: r, array: d, itemSize: o } } onmessage = function (r) { const i = r.data; switch (i.type) { case "init": e = i.decoderConfig, t = new Promise((function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) })); break; case "decode": const r = i.buffer, a = i.taskConfig; t.then((e => { const t = e.draco, o = new t.Decoder, s = new t.DecoderBuffer; s.Init(new Int8Array(r), r.byteLength); try { const e = function (e, t, r, i) { const a = i.attributeIDs, o = i.attributeTypes; let s, l; const c = t.GetEncodedGeometryType(r); if (c === e.TRIANGULAR_MESH) s = new e.Mesh, l = t.DecodeBufferToMesh(r, s); else { if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); s = new e.PointCloud, l = t.DecodeBufferToPointCloud(r, s) } if (!l.ok() || 0 === s.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg()); const u = { index: null, attributes: [] }; for (const r in a) { const l = self[o[r]]; let c, d; if (i.useUniqueIDs) d = a[r], c = t.GetAttributeByUniqueId(s, d); else { if (d = t.GetAttributeId(s, e[a[r]]), -1 === d) continue; c = t.GetAttribute(s, d) } u.attributes.push(n(e, t, s, r, l, c)) } return c === e.TRIANGULAR_MESH && (u.index = function (e, t, n) { const r = 3 * n.num_faces(), i = 4 * r, a = e._malloc(i); t.GetTrianglesUInt32Array(n, i, a); const o = new Uint32Array(e.HEAPF32.buffer, a, r).slice(); return e._free(a), { array: o, itemSize: 1 } }(e, t, s)), e.destroy(s), u }(t, o, s, a), r = e.attributes.map((e => e.array.buffer)); e.index && r.push(e.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: e }, r) } catch (e) { console.error(e), self.postMessage({ type: "error", id: i.id, error: e.message }) } finally { t.destroy(s), t.destroy(o) } })) } } } let wB; const _B = parseInt(dl.replace(/\D+/g, "")); function EB(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let n = 0, r = e.length; n < r; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } const CB = "srgb", TB = "srgb-linear"; class RB extends $A { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new kB(e) })), this.register((function (e) { return new NB(e) })), this.register((function (e) { return new WB(e) })), this.register((function (e) { return new XB(e) })), this.register((function (e) { return new JB(e) })), this.register((function (e) { return new OB(e) })), this.register((function (e) { return new UB(e) })), this.register((function (e) { return new zB(e) })), this.register((function (e) { return new HB(e) })), this.register((function (e) { return new DB(e) })), this.register((function (e) { return new GB(e) })), this.register((function (e) { return new FB(e) })), this.register((function (e) { return new VB(e) })), this.register((function (e) { return new jB(e) })), this.register((function (e) { return new PB(e) })), this.register((function (e) { return new YB(e) })), this.register((function (e) { return new QB(e) })) } load(e, t, n, r) { const i = this; let a; if ("" !== this.resourcePath) a = this.resourcePath; else if ("" !== this.path) { const t = RS.extractUrlBase(e); a = RS.resolveURL(t, this.path) } else a = RS.extractUrlBase(e); this.manager.itemStart(e); const o = function (t) { r ? r(t) : console.error(t), i.manager.itemError(e), i.manager.itemEnd(e) }, s = new nS(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (n) { try { i.parse(n, a, (function (n) { t(n), i.manager.itemEnd(e) }), o) } catch (e) { o(e) } }), n, o) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, r) { let i; const a = {}, o = {}; if ("string" == typeof e) i = JSON.parse(e); else if (e instanceof ArrayBuffer) if (EB(new Uint8Array(e.slice(0, 4))) === KB) { try { a[IB.KHR_BINARY_GLTF] = new qB(e) } catch (e) { return void (r && r(e)) } i = JSON.parse(a[IB.KHR_BINARY_GLTF].content) } else i = JSON.parse(EB(new Uint8Array(e))); else i = e; if (void 0 === i.asset || i.asset.version[0] < 2) return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const s = new bI(i, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); s.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](s); t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[t.name] = t, a[t.name] = !0 } if (i.extensionsUsed) for (let e = 0; e < i.extensionsUsed.length; ++e) { const t = i.extensionsUsed[e], n = i.extensionsRequired || []; switch (t) { case IB.KHR_MATERIALS_UNLIT: a[t] = new LB; break; case IB.KHR_DRACO_MESH_COMPRESSION: a[t] = new ZB(i, this.dracoLoader); break; case IB.KHR_TEXTURE_TRANSFORM: a[t] = new $B; break; case IB.KHR_MESH_QUANTIZATION: a[t] = new eI; break; default: n.indexOf(t) >= 0 && void 0 === o[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } s.setExtensions(a), s.setPlugins(o), s.parse(n, r) } parseAsync(e, t) { const n = this; return new Promise((function (r, i) { n.parse(e, t, r, i) })) } } function BB() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, n) { e[t] = n }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const IB = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class PB { constructor(e) { this.parser = e, this.name = IB.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let n = 0, r = t.length; n < r; n++) { const r = t[n]; r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let r = t.cache.get(n); if (r) return r; const i = t.json, a = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e]; let o; const s = new df(16777215); void 0 !== a.color && s.setRGB(a.color[0], a.color[1], a.color[2], TB); const l = void 0 !== a.range ? a.range : 0; switch (a.type) { case "directional": o = new MS(s), o.target.position.set(0, 0, -1), o.add(o.target); break; case "point": o = new AS(s), o.distance = l; break; case "spot": o = new gS(s), o.distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type) }return o.position.set(0, 0, 0), o.decay = 2, pI(o, a), void 0 !== a.intensity && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(o), t.cache.add(n, r), r } getDependency(e, t) { if ("light" === e) return this._loadLight(t) } createNodeAttachment(e) { const t = this, n = this.parser, r = n.json.nodes[e], i = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === i ? null : this._loadLight(i).then((function (e) { return n._getNodeRef(t.cache, i, e) })) } } class LB { constructor() { this.name = IB.KHR_MATERIALS_UNLIT } getMaterialType() { return mf } extendParams(e, t, n) { const r = []; e.color = new df(1, 1, 1), e.opacity = 1; const i = t.pbrMetallicRoughness; if (i) { if (Array.isArray(i.baseColorFactor)) { const t = i.baseColorFactor; e.color.setRGB(t[0], t[1], t[2], TB), e.opacity = t[3] } void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture, CB)) } return Promise.all(r) } } class DB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = n.extensions[this.name].emissiveStrength; return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve() } } class kB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { const e = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new uh(e, e) } return Promise.all(i) } } class NB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_DISPERSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = n.extensions[this.name]; return t.dispersion = void 0 !== r.dispersion ? r.dispersion : 0, Promise.resolve() } } class FB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor), void 0 !== a.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), void 0 !== a.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(i) } } class OB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = []; t.sheenColor = new df(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const a = r.extensions[this.name]; if (void 0 !== a.sheenColorFactor) { const e = a.sheenColorFactor; t.sheenColor.setRGB(e[0], e[1], e[2], TB) } return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, CB)), void 0 !== a.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(i) } } class UB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(i) } } class zB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_VOLUME } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0; const o = a.attenuationColor || [1, 1, 1]; return t.attenuationColor = (new df).setRGB(o[0], o[1], o[2], TB), Promise.all(i) } } class HB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = n.extensions[this.name]; return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve() } } class GB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture)); const o = a.specularColorFactor || [1, 1, 1]; return t.specularColor = (new df).setRGB(o[0], o[1], o[2], TB), void 0 !== a.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, CB)), Promise.all(i) } } class jB { constructor(e) { this.parser = e, this.name = IB.EXT_MATERIALS_BUMP } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1, void 0 !== a.bumpTexture && i.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(i) } } class VB { constructor(e) { this.parser = e, this.name = IB.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MA : null } extendMaterialParams(e, t) { const n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], a = r.extensions[this.name]; return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength), void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation), void 0 !== a.anisotropyTexture && i.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(i) } } class WB { constructor(e) { this.parser = e, this.name = IB.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, r = n.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; const i = r.extensions[this.name], a = t.options.ktx2Loader; if (!a) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, i.source, a) } } class XB { constructor(e) { this.parser = e, this.name = IB.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, r = n.json, i = r.textures[e]; if (!i.extensions || !i.extensions[t]) return null; const a = i.extensions[t], o = r.images[a.source]; let s = n.textureLoader; if (o.uri) { const e = n.options.manager.getHandler(o.uri); null !== e && (s = e) } return this.detectSupport().then((function (i) { if (i) return n.loadTextureImage(e, a.source, s); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class JB { constructor(e) { this.parser = e, this.name = IB.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, r = n.json, i = r.textures[e]; if (!i.extensions || !i.extensions[t]) return null; const a = i.extensions[t], o = r.images[a.source]; let s = n.textureLoader; if (o.uri) { const e = n.options.manager.getHandler(o.uri); null !== e && (s = e) } return this.detectSupport().then((function (i) { if (i) return n.loadTextureImage(e, a.source, s); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return n.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class YB { constructor(e) { this.name = IB.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, n = t.bufferViews[e]; if (n.extensions && n.extensions[this.name]) { const e = n.extensions[this.name], r = this.parser.getDependency("buffer", e.buffer), i = this.parser.options.meshoptDecoder; if (!i || !i.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return r.then((function (t) { const n = e.byteOffset || 0, r = e.byteLength || 0, a = e.count, o = e.byteStride, s = new Uint8Array(t, n, r); return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(a, o, s, e.mode, e.filter).then((function (e) { return e.buffer })) : i.ready.then((function () { const t = new ArrayBuffer(a * o); return i.decodeGltfBuffer(new Uint8Array(t), a, o, s, e.mode, e.filter), t })) })) } return null } } class QB { constructor(e) { this.name = IB.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, n = t.nodes[e]; if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null; const r = t.meshes[n.mesh]; for (const e of r.primitives) if (e.mode !== iI.TRIANGLES && e.mode !== iI.TRIANGLE_STRIP && e.mode !== iI.TRIANGLE_FAN && void 0 !== e.mode) return null; const i = n.extensions[this.name].attributes, a = [], o = {}; for (const e in i) a.push(this.parser.getDependency("accessor", i[e]).then((t => (o[e] = t, o[e])))); return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((e => { const t = e.pop(), n = t.isGroup ? t.children : [t], r = e[0].count, i = []; for (const e of n) { const t = new yp, n = new Gh, a = new Hh, s = new Gh(1, 1, 1), l = new ab(e.geometry, e.material, r); for (let e = 0; e < r; e++)o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, e), o.ROTATION && a.fromBufferAttribute(o.ROTATION, e), o.SCALE && s.fromBufferAttribute(o.SCALE, e), l.setMatrixAt(e, t.compose(n, a, s)); for (const t in o) if ("_COLOR_0" === t) { const e = o[t]; l.instanceColor = new qy(e.array, e.itemSize, e.normalized) } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, o[t]); Wp.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), i.push(l) } return t.isGroup ? (t.clear(), t.add(...i), t) : i[0] }))) } } const KB = "glTF"; class qB { constructor(e) { this.name = IB.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12); if (this.header = { magic: EB(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== KB) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, r = new DataView(e, 12); let i = 0; for (; i < n;) { const t = r.getUint32(i, !0); i += 4; const n = r.getUint32(i, !0); if (i += 4, 1313821514 === n) { const n = new Uint8Array(e, 12 + i, t); this.content = EB(n) } else if (5130562 === n) { const n = 12 + i; this.body = e.slice(n, n + t) } i += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class ZB { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = IB.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, r = this.dracoLoader, i = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, s = {}, l = {}; for (const e in a) { const t = cI[e] || e.toLowerCase(); o[t] = a[e] } for (const t in e.attributes) { const r = cI[t] || t.toLowerCase(); if (void 0 !== a[t]) { const i = n.accessors[e.attributes[t]], a = aI[i.componentType]; l[r] = a.name, s[r] = !0 === i.normalized } } return t.getDependency("bufferView", i).then((function (e) { return new Promise((function (t, n) { r.decodeDracoFile(e, (function (e) { for (const t in e.attributes) { const n = e.attributes[t], r = s[t]; void 0 !== r && (n.normalized = r) } t(e) }), o, l, TB, n) })) })) } } class $B { constructor() { this.name = IB.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e } } class eI { constructor() { this.name = IB.KHR_MESH_QUANTIZATION } } class tI extends NA { constructor(e, t, n, r) { super(e, t, n, r) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r; for (let e = 0; e !== r; e++)t[e] = n[i + e]; return t } interpolate_(e, t, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, u = (n - t) / c, d = u * u, h = d * u, p = e * l, f = p - l, m = -2 * h + 3 * d, g = h - d, v = 1 - m, y = g - d + u; for (let e = 0; e !== o; e++) { const t = a[f + e + o], n = a[f + e + s] * c, r = a[p + e + o], l = a[p + e] * c; i[e] = v * t + y * n + m * r + g * l } return i } } const nI = new Hh; class rI extends tI { interpolate_(e, t, n, r) { const i = super.interpolate_(e, t, n, r); return nI.fromArray(i).normalize().toArray(i), i } } const iI = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, aI = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, oI = { 9728: Cc, 9729: Pc, 9984: Tc, 9985: Lc, 9986: Bc, 9987: kc }, sI = { 33071: _c, 33648: Ec, 10497: wc }, lI = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, cI = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", ..._B >= 152 ? { TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3" } : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }, COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, uI = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, dI = { CUBICSPLINE: void 0, LINEAR: Vu, STEP: ju }; function hI(e, t, n) { for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r]) } function pI(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function fI(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, r = t.weights.length; n < r; n++)e.morphTargetInfluences[n] = t.weights[n]; if (t.extras && Array.isArray(t.extras.targetNames)) { const n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (let t = 0, r = n.length; t < r; t++)e.morphTargetDictionary[n[t]] = t } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function mI(e) { let t; const n = e.extensions && e.extensions[IB.KHR_DRACO_MESH_COMPRESSION]; if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + gI(n.attributes) : e.indices + ":" + gI(e.attributes) + ":" + e.mode, void 0 !== e.targets) for (let n = 0, r = e.targets.length; n < r; n++)t += ":" + gI(e.targets[n]); return t } function gI(e) { let t = ""; const n = Object.keys(e).sort(); for (let r = 0, i = n.length; r < i; r++)t += n[r] + ":" + e[n[r]] + ";"; return t } function vI(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } const yI = new yp; class bI { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new BB, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let n = !1, r = !1, i = -1; "undefined" != typeof navigator && void 0 !== navigator.userAgent && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), r = navigator.userAgent.indexOf("Firefox") > -1, i = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || r && i < 98 ? this.textureLoader = new lS(this.options.manager) : this.textureLoader = new NS(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new nS(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const n = this, r = this.json, i = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function (t) { const a = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: n, userData: {} }; return hI(i, a, r), pI(a, r), Promise.all(n._invokeAll((function (e) { return e.afterRoot && e.afterRoot(a) }))).then((function () { for (const e of a.scenes) e.updateMatrixWorld(); e(a) })) })).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || []; for (let n = 0, r = t.length; n < r; n++) { const r = t[n].joints; for (let t = 0, n = r.length; t < n; t++)e[r[t]].isBone = !0 } for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const r = n.clone(), i = (e, t) => { const n = this.associations.get(e); null != n && this.associations.set(t, n); for (const [n, r] of e.children.entries()) i(r, t.children[n]) }; return i(n, r), r.name += "_instance_" + e.uses[t]++, r } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let n = 0; n < t.length; n++) { const r = e(t[n]); if (r) return r } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const n = []; for (let r = 0; r < t.length; r++) { const i = e(t[r]); i && n.push(i) } return n } getDependency(e, t) { const n = e + ":" + t; let r = this.cache.get(n); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this._invokeOne((function (e) { return e.loadNode && e.loadNode(t) })); break; case "mesh": r = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": r = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this._invokeOne((function (e) { return e.loadAnimation && e.loadAnimation(t) })); break; case "camera": r = this.loadCamera(t); break; default: if (r = this._invokeOne((function (n) { return n != this && n.getDependency && n.getDependency(e, t) })), !r) throw new Error("Unknown type: " + e) }this.cache.add(n, r) } return r } getDependencies(e) { let t = this.cache.get(e); if (!t) { const n = this, r = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(r.map((function (t, r) { return n.getDependency(e, r) }))), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], n = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[IB.KHR_BINARY_GLTF].body); const r = this.options; return new Promise((function (e, i) { n.load(RS.resolveURL(t.uri, r.path), e, void 0, (function () { i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { const n = t.byteLength || 0, r = t.byteOffset || 0; return e.slice(r, r + n) })) } loadAccessor(e) { const t = this, n = this.json, r = this.json.accessors[e]; if (void 0 === r.bufferView && void 0 === r.sparse) { const e = lI[r.type], t = aI[r.componentType], n = !0 === r.normalized, i = new t(r.count * e); return Promise.resolve(new Mf(i, e, n)) } const i = []; return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then((function (e) { const i = e[0], a = lI[r.type], o = aI[r.componentType], s = o.BYTES_PER_ELEMENT, l = s * a, c = r.byteOffset || 0, u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0, d = !0 === r.normalized; let h, p; if (u && u !== l) { const e = Math.floor(c / u), n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count; let l = t.cache.get(n); l || (h = new o(i, e * u, r.count * u / s), l = new fy(h, u / s), t.cache.add(n, l)), p = new gy(l, a, c % u / s, d) } else h = null === i ? new o(r.count * a) : new o(i, c, r.count * a), p = new Mf(h, a, d); if (void 0 !== r.sparse) { const t = lI.SCALAR, n = aI[r.sparse.indices.componentType], s = r.sparse.indices.byteOffset || 0, l = r.sparse.values.byteOffset || 0, c = new n(e[1], s, r.sparse.count * t), u = new o(e[2], l, r.sparse.count * a); null !== i && (p = new Mf(p.array.slice(), p.itemSize, p.normalized)); for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (p.setX(t, u[e * a]), a >= 2 && p.setY(t, u[e * a + 1]), a >= 3 && p.setZ(t, u[e * a + 2]), a >= 4 && p.setW(t, u[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return p })) } loadTexture(e) { const t = this.json, n = this.options, r = t.textures[e].source, i = t.images[r]; let a = this.textureLoader; if (i.uri) { const e = n.manager.getHandler(i.uri); null !== e && (a = e) } return this.loadTextureImage(e, r, a) } loadTextureImage(e, t, n) { const r = this, i = this.json, a = i.textures[e], o = i.images[t], s = (o.uri || o.bufferView) + ":" + a.sampler; if (this.textureCache[s]) return this.textureCache[s]; const l = this.loadImageSource(t, n).then((function (t) { t.flipY = !1, t.name = a.name || o.name || "", "" === t.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (t.name = o.uri); const n = (i.samplers || {})[a.sampler] || {}; return t.magFilter = oI[n.magFilter] || Pc, t.minFilter = oI[n.minFilter] || kc, t.wrapS = sI[n.wrapS] || wc, t.wrapT = sI[n.wrapT] || wc, r.associations.set(t, { textures: e }), t })).catch((function () { return null })); return this.textureCache[s] = l, l } loadImageSource(e, t) { const n = this.json, r = this.options; if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone())); const i = n.images[e], a = self.URL || self.webkitURL; let o = i.uri || "", s = !1; if (void 0 !== i.bufferView) o = this.getDependency("bufferView", i.bufferView).then((function (e) { s = !0; const t = new Blob([e], { type: i.mimeType }); return o = a.createObjectURL(t), o })); else if (void 0 === i.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const l = Promise.resolve(o).then((function (e) { return new Promise((function (n, i) { let a = n; !0 === t.isImageBitmapLoader && (a = function (e) { const t = new Lh(e); t.needsUpdate = !0, n(t) }), t.load(RS.resolveURL(e, r.path), a, void 0, i) })) })).then((function (e) { var t; return !0 === s && a.revokeObjectURL(o), pI(e, i), e.userData.mimeType = i.mimeType || ((t = i.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e })).catch((function (e) { throw console.error("THREE.GLTFLoader: Couldn't load texture", o), e })); return this.sourceCache[e] = l, l } assignTexture(e, t, n, r) { const i = this; return this.getDependency("texture", n.index).then((function (a) { if (!a) return null; if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord), i.extensions[IB.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== n.extensions ? n.extensions[IB.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = i.associations.get(a); a = i.extensions[IB.KHR_TEXTURE_TRANSFORM].extendTexture(a, e), i.associations.set(a, t) } } return void 0 !== r && ("number" == typeof r && (r = 3001 === r ? CB : TB), "colorSpace" in a ? a.colorSpace = r : a.encoding = r === CB ? 3001 : 3e3), e[t] = a, a })) } assignFinalMaterial(e) { const t = e.geometry; let n = e.material; const r = void 0 === t.attributes.tangent, i = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new Ub, ff.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t } else if (e.isLine) { const e = "LineBasicMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new _b, ff.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t } if (r || i || a) { let e = "ClonedMaterial:" + n.uuid + ":"; r && (e += "derivative-tangents:"), i && (e += "vertex-colors:"), a && (e += "flat-shading:"); let t = this.cache.get(e); t || (t = n.clone(), i && (t.vertexColors = !0), a && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t } e.material = n } getMaterialType() { return SA } loadMaterial(e) { const t = this, n = this.json, r = this.extensions, i = n.materials[e]; let a; const o = {}, s = []; if ((i.extensions || {})[IB.KHR_MATERIALS_UNLIT]) { const e = r[IB.KHR_MATERIALS_UNLIT]; a = e.getMaterialType(), s.push(e.extendParams(o, i, t)) } else { const n = i.pbrMetallicRoughness || {}; if (o.color = new df(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) { const e = n.baseColorFactor; o.color.setRGB(e[0], e[1], e[2], TB), o.opacity = e[3] } void 0 !== n.baseColorTexture && s.push(t.assignTexture(o, "map", n.baseColorTexture, CB)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (s.push(t.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), s.push(t.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), a = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), s.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, o) })))) } !0 === i.doubleSided && (o.side = wl); const l = i.alphaMode || "OPAQUE"; if ("BLEND" === l ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, "MASK" === l && (o.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && a !== mf && (s.push(t.assignTexture(o, "normalMap", i.normalTexture)), o.normalScale = new uh(1, 1), void 0 !== i.normalTexture.scale)) { const e = i.normalTexture.scale; o.normalScale.set(e, e) } if (void 0 !== i.occlusionTexture && a !== mf && (s.push(t.assignTexture(o, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (o.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && a !== mf) { const e = i.emissiveFactor; o.emissive = (new df).setRGB(e[0], e[1], e[2], TB) } return void 0 !== i.emissiveTexture && a !== mf && s.push(t.assignTexture(o, "emissiveMap", i.emissiveTexture, CB)), Promise.all(s).then((function () { const n = new a(o); return i.name && (n.name = i.name), pI(n, i), t.associations.set(n, { materials: e }), i.extensions && hI(r, n, i), n })) } createUniqueName(e) { const t = dM.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, n = this.extensions, r = this.primitiveCache; function i(e) { return n[IB.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) { return xI(n, e, t) })) } const a = []; for (let n = 0, o = e.length; n < o; n++) { const o = e[n], s = mI(o), l = r[s]; if (l) a.push(l.promise); else { let e; e = o.extensions && o.extensions[IB.KHR_DRACO_MESH_COMPRESSION] ? i(o) : xI(new zf, o, t), r[s] = { primitive: o, promise: e }, a.push(e) } } return Promise.all(a) } loadMesh(e) { const t = this, n = this.json, r = this.extensions, i = n.meshes[e], a = i.primitives, o = []; for (let e = 0, t = a.length; e < t; e++) { const t = void 0 === a[e].material ? (void 0 === (s = this.cache).DefaultMaterial && (s.DefaultMaterial = new SA({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: Sl })), s.DefaultMaterial) : this.getDependency("material", a[e].material); o.push(t) } var s; return o.push(t.loadGeometries(a)), Promise.all(o).then((function (n) { const o = n.slice(0, n.length - 1), s = n[n.length - 1], l = []; for (let n = 0, c = s.length; n < c; n++) { const c = s[n], u = a[n]; let d; const h = o[n]; if (u.mode === iI.TRIANGLES || u.mode === iI.TRIANGLE_STRIP || u.mode === iI.TRIANGLE_FAN || void 0 === u.mode) d = !0 === i.isSkinnedMesh ? new Wy(c, h) : new Zf(c, h), !0 === d.isSkinnedMesh && d.normalizeSkinWeights(), u.mode === iI.TRIANGLE_STRIP ? d.geometry = EE(d.geometry, Zu) : u.mode === iI.TRIANGLE_FAN && (d.geometry = EE(d.geometry, $u)); else if (u.mode === iI.LINES) d = new Fb(c, h); else if (u.mode === iI.LINE_STRIP) d = new Lb(c, h); else if (u.mode === iI.LINE_LOOP) d = new Ob(c, h); else { if (u.mode !== iI.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode); d = new Vb(c, h) } Object.keys(d.geometry.morphAttributes).length > 0 && fI(d, i), d.name = t.createUniqueName(i.name || "mesh_" + e), pI(d, i), u.extensions && hI(r, d, u), t.assignFinalMaterial(d), l.push(d) } for (let n = 0, r = l.length; n < r; n++)t.associations.set(l[n], { meshes: e, primitives: n }); if (1 === l.length) return i.extensions && hI(r, l[0], i), l[0]; const c = new ty; i.extensions && hI(r, c, i), t.associations.set(c, { meshes: e }); for (let e = 0, t = l.length; e < t; e++)c.add(l[e]); return c })) } loadCamera(e) { let t; const n = this.json.cameras[e], r = n[n.type]; if (r) return "perspective" === n.type ? t = new um(ch.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new Fm(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), pI(t, n), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], n = []; for (let e = 0, r = t.joints.length; e < r; e++)n.push(this._loadNodeShallow(t.joints[e])); return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function (e) { const n = e.pop(), r = e, i = [], a = []; for (let e = 0, o = r.length; e < o; e++) { const o = r[e]; if (o) { i.push(o); const t = new yp; null !== n && t.fromArray(n.array, 16 * e), a.push(t) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]) } return new Ky(i, a) })) } loadAnimation(e) { const t = this.json, n = this, r = t.animations[e], i = r.name ? r.name : "animation_" + e, a = [], o = [], s = [], l = [], c = []; for (let e = 0, t = r.channels.length; e < t; e++) { const t = r.channels[e], n = r.samplers[t.sampler], i = t.target, u = i.node, d = void 0 !== r.parameters ? r.parameters[n.input] : n.input, h = void 0 !== r.parameters ? r.parameters[n.output] : n.output; void 0 !== i.node && (a.push(this.getDependency("node", u)), o.push(this.getDependency("accessor", d)), s.push(this.getDependency("accessor", h)), l.push(n), c.push(i)) } return Promise.all([Promise.all(a), Promise.all(o), Promise.all(s), Promise.all(l), Promise.all(c)]).then((function (e) { const t = e[0], r = e[1], a = e[2], o = e[3], s = e[4], l = []; for (let e = 0, i = t.length; e < i; e++) { const i = t[e], c = r[e], u = a[e], d = o[e], h = s[e]; if (void 0 === i) continue; i.updateMatrix && i.updateMatrix(); const p = n._createAnimationTracks(i, c, u, d, h); if (p) for (let e = 0; e < p.length; e++)l.push(p[e]) } return new YA(i, void 0, l) })) } createNodeMesh(e) { const t = this.json, n = this, r = t.nodes[e]; return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function (e) { const t = n._getNodeRef(n.meshCache, r.mesh, e); return void 0 !== r.weights && t.traverse((function (e) { if (e.isMesh) for (let t = 0, n = r.weights.length; t < n; t++)e.morphTargetInfluences[t] = r.weights[t] })), t })) } loadNode(e) { const t = this, n = this.json.nodes[e], r = t._loadNodeShallow(e), i = [], a = n.children || []; for (let e = 0, n = a.length; e < n; e++)i.push(t.getDependency("node", a[e])); const o = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin); return Promise.all([r, Promise.all(i), o]).then((function (e) { const t = e[0], n = e[1], r = e[2]; null !== r && t.traverse((function (e) { e.isSkinnedMesh && e.bind(r, yI) })); for (let e = 0, r = n.length; e < r; e++)t.add(n[e]); return t })) } _loadNodeShallow(e) { const t = this.json, n = this.extensions, r = this; if (void 0 !== this.nodeCache[e]) return this.nodeCache[e]; const i = t.nodes[e], a = i.name ? r.createUniqueName(i.name) : "", o = [], s = r._invokeOne((function (t) { return t.createNodeMesh && t.createNodeMesh(e) })); return s && o.push(s), void 0 !== i.camera && o.push(r.getDependency("camera", i.camera).then((function (e) { return r._getNodeRef(r.cameraCache, i.camera, e) }))), r._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { o.push(e) })), this.nodeCache[e] = Promise.all(o).then((function (t) { let o; if (o = !0 === i.isBone ? new Xy : t.length > 1 ? new ty : 1 === t.length ? t[0] : new Wp, o !== t[0]) for (let e = 0, n = t.length; e < n; e++)o.add(t[e]); if (i.name && (o.userData.name = i.name, o.name = a), pI(o, i), i.extensions && hI(n, o, i), void 0 !== i.matrix) { const e = new yp; e.fromArray(i.matrix), o.applyMatrix4(e) } else void 0 !== i.translation && o.position.fromArray(i.translation), void 0 !== i.rotation && o.quaternion.fromArray(i.rotation), void 0 !== i.scale && o.scale.fromArray(i.scale); return r.associations.has(o) || r.associations.set(o, {}), r.associations.get(o).nodes = e, o })), this.nodeCache[e] } loadScene(e) { const t = this.extensions, n = this.json.scenes[e], r = this, i = new ty; n.name && (i.name = r.createUniqueName(n.name)), pI(i, n), n.extensions && hI(t, i, n); const a = n.nodes || [], o = []; for (let e = 0, t = a.length; e < t; e++)o.push(r.getDependency("node", a[e])); return Promise.all(o).then((function (e) { for (let t = 0, n = e.length; t < n; t++)i.add(e[t]); return r.associations = (e => { const t = new Map; for (const [e, n] of r.associations) (e instanceof ff || e instanceof Lh) && t.set(e, n); return e.traverse((e => { const n = r.associations.get(e); null != n && t.set(e, n) })), t })(i), i })) } _createAnimationTracks(e, t, n, r, i) { const a = [], o = e.name ? e.name : e.uuid, s = []; let l; switch (uI[i.path] === uI.weights ? e.traverse((function (e) { e.morphTargetInfluences && s.push(e.name ? e.name : e.uuid) })) : s.push(o), uI[i.path]) { case uI.weights: l = jA; break; case uI.rotation: l = WA; break; case uI.position: case uI.scale: l = JA; break; default: l = 1 === n.itemSize ? jA : JA }const c = void 0 !== r.interpolation ? dI[r.interpolation] : Vu, u = this._getArrayFromAccessor(n); for (let e = 0, n = s.length; e < n; e++) { const n = new l(s[e] + "." + uI[i.path], t.array, u, c); "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(n), a.push(n) } return a } _getArrayFromAccessor(e) { let t = e.array; if (e.normalized) { const e = vI(t.constructor), n = new Float32Array(t.length); for (let r = 0, i = t.length; r < i; r++)n[r] = t[r] * e; t = n } return t } _createCubicSplineTrackInterpolant(e) { e.createInterpolant = function (e) { return new (this instanceof WA ? rI : tI)(this.times, this.values, this.getValueSize() / 3, e) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } } function xI(e, t, n) { const r = t.attributes, i = []; function a(t, r) { return n.getDependency("accessor", t).then((function (t) { e.setAttribute(r, t) })) } for (const t in r) { const n = cI[t] || t.toLowerCase(); n in e.attributes || i.push(a(r[t], n)) } if (void 0 !== t.indices && !e.index) { const r = n.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); i.push(r) } return pI(e, t), function (e, t, n) { const r = t.attributes, i = new Wh; if (void 0 === r.POSITION) return; { const e = n.json.accessors[r.POSITION], t = e.min, a = e.max; if (void 0 === t || void 0 === a) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (i.set(new Gh(t[0], t[1], t[2]), new Gh(a[0], a[1], a[2])), e.normalized) { const t = vI(aI[e.componentType]); i.min.multiplyScalar(t), i.max.multiplyScalar(t) } } const a = t.targets; if (void 0 !== a) { const e = new Gh, t = new Gh; for (let r = 0, i = a.length; r < i; r++) { const i = a[r]; if (void 0 !== i.POSITION) { const r = n.json.accessors[i.POSITION], a = r.min, o = r.max; if (void 0 !== a && void 0 !== o) { if (t.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))), r.normalized) { const e = vI(aI[r.componentType]); t.multiplyScalar(e) } e.max(t) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } i.expandByVector(e) } e.boundingBox = i; const o = new cp; i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = o }(e, t, n), Promise.all(i).then((function () { return void 0 !== t.targets ? function (e, t, n) { let r = !1, i = !1, a = !1; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), void 0 !== n.COLOR_0 && (a = !0), r && i && a) break } if (!r && !i && !a) return Promise.resolve(e); const o = [], s = [], l = []; for (let c = 0, u = t.length; c < u; c++) { const u = t[c]; if (r) { const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position; o.push(t) } if (i) { const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal; s.push(t) } if (a) { const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color; l.push(t) } } return Promise.all([Promise.all(o), Promise.all(s), Promise.all(l)]).then((function (t) { const n = t[0], o = t[1], s = t[2]; return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = o), a && (e.morphAttributes.color = s), e.morphTargetsRelative = !0, e })) }(e, t.targets, n) : e })) } function AI(e, t, n) { n(e, t); for (let r = 0; r < e.children.length; r++)AI(e.children[r], t.children[r], n) } const SI = function (e) { const t = new Map, n = new Map, r = e.clone(); return AI(e, r, (function (e, r) { t.set(r, e), n.set(e, r) })), r.traverse((function (e) { if (!e.isSkinnedMesh) return; const r = e, i = t.get(e), a = i.skeleton.bones; r.skeleton = i.skeleton.clone(), r.bindMatrix.copy(i.bindMatrix), r.skeleton.bones = a.map((function (e) { return n.get(e) })), r.bind(r.skeleton, r.bindMatrix) })), r }, MI = n.forwardRef((({ isChild: e = !1, object: t, children: r, deep: i, castShadow: a, receiveShadow: o, inject: s, keys: l, ...c }, u) => { const d = { keys: l, deep: i, inject: s, castShadow: a, receiveShadow: o }; if (t = n.useMemo((() => { if (!1 === e && !Array.isArray(t)) { let e = !1; if (t.traverse((t => { t.isSkinnedMesh && (e = !0) })), e) return SI(t) } return t }), [t, e]), Array.isArray(t)) return n.createElement("group", _({}, c, { ref: u }), t.map((e => n.createElement(MI, _({ key: e.uuid, object: e }, d)))), r); const { children: h, ...p } = function (e, { keys: t = ["near", "far", "color", "distance", "decay", "penumbra", "angle", "intensity", "skeleton", "visible", "castShadow", "receiveShadow", "morphTargetDictionary", "morphTargetInfluences", "name", "geometry", "material", "position", "rotation", "scale", "up", "userData", "bindMode", "bindMatrix", "bindMatrixInverse", "skeleton"], deep: r, inject: i, castShadow: a, receiveShadow: o }) { let s = {}; for (const n of t) s[n] = e[n]; return r && (s.geometry && "materialsOnly" !== r && (s.geometry = s.geometry.clone()), s.material && "geometriesOnly" !== r && (s.material = s.material.clone())), i && (s = "function" == typeof i ? { ...s, children: i(e) } : n.isValidElement(i) ? { ...s, children: i } : { ...s, ...i }), e instanceof Zf && (a && (s.castShadow = !0), o && (s.receiveShadow = !0)), s }(t, d), f = t.type[0].toLowerCase() + t.type.slice(1); return n.createElement(f, _({}, p, c, { ref: u }), t.children.map((e => "Bone" === e.type ? n.createElement("primitive", _({ key: e.uuid, object: e }, d)) : n.createElement(MI, _({ key: e.uuid, object: e }, d, { isChild: !0 })))), r, h) })); let wI = null, _I = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"; function EI(e = !0, t = !0, n) { return r => { n && n(r), e && (wI || (wI = new SB), wI.setDecoderPath("string" == typeof e ? e : _I), r.setDRACOLoader(wI)), t && r.setMeshoptDecoder((() => { if (wB) return wB; const e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), t = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]); if ("object" != typeof WebAssembly) return { supported: !1 }; let n, r = "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"; WebAssembly.validate(e) && (r = "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"); const i = WebAssembly.instantiate(function (e) { const n = new Uint8Array(e.length); for (let t = 0; t < e.length; ++t) { const r = e.charCodeAt(t); n[t] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62 } let r = 0; for (let i = 0; i < e.length; ++i)n[r++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i]; return n.buffer.slice(0, r) }(r), {}).then((e => { n = e.instance, n.exports.__wasm_call_ctors() })); function a(e, t, r, i, a, o) { const s = n.exports.sbrk, l = r + 3 & -4, c = s(l * i), u = s(a.length), d = new Uint8Array(n.exports.memory.buffer); d.set(a, u); const h = e(c, r, i, u, a.length); if (0 === h && o && o(c, l, i), t.set(d.subarray(c, c + r * i)), s(c - s(0)), 0 !== h) throw new Error(`Malformed buffer data: ${h}`) } const o = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, s = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return wB = { ready: i, supported: !0, decodeVertexBuffer(e, t, r, i, s) { a(n.exports.meshopt_decodeVertexBuffer, e, t, r, i, n.exports[o[s]]) }, decodeIndexBuffer(e, t, r, i) { a(n.exports.meshopt_decodeIndexBuffer, e, t, r, i) }, decodeIndexSequence(e, t, r, i) { a(n.exports.meshopt_decodeIndexSequence, e, t, r, i) }, decodeGltfBuffer(e, t, r, i, l, c) { a(n.exports[s[l]], e, t, r, i, n.exports[o[c]]) } }, wB })()) } } const CI = (e, t, n, r) => m_(RB, e, EI(t, n, r)); CI.preload = (e, t, n, r) => m_.preload(RB, e, EI(t, n, r)), CI.clear = e => m_.clear(RB, e), CI.setDecoderPath = e => { _I = e }; const TI = n.forwardRef((({ src: e, useDraco: t, useMeshOpt: r, extendLoader: i, ...a }, o) => { const { scene: s } = CI(e, t, r, i); return n.createElement(MI, _({ ref: o }, a, { object: s })) })), RI = new Tp(Math.PI, 0, Math.PI / 2, "XYZ"), BI = new Tp(0, Math.PI, 0, "XYZ"); function II(e) { const t = e.playerState.players[e.playerState.current_player], n = t.selected_piece && t.pieces[t.selected_piece]; return (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)(lE, {}), (0, ii.jsx)(PI, { rotation: RI, rotate: () => e.update({ type: "RotateSelectedPiece", data: "Y" }), position: [0, 3, 0] }), (0, ii.jsx)(PI, { rotation: BI, rotate: () => e.update({ type: "RotateSelectedPiece", data: "X" }), position: [3, 0, 0] }), n && (0, ii.jsx)(yB, { piece: n, update: e.update, owner: e.playerState.current_player })] }) } function PI(e) { return (0, ii.jsxs)("group", { onClick: t => { t.stopPropagation(), e.rotate() }, position: e.position, rotation: e.rotation, children: [(0, ii.jsxs)("mesh", { visible: !1, children: [(0, ii.jsx)("boxGeometry", { args: [1.5, 1.5, 1.5] }), (0, ii.jsx)("meshStandardMaterial", { transparent: !0, opacity: .1, color: "green" })] }), (0, ii.jsx)(n.Suspense, { children: (0, ii.jsx)(TI, { position: [-.5, 0, .5], src: "arrow.glb", scale: .045 }) })] }) } function LI(e) { return (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)(lE, {}), (0, ii.jsx)(qP, { gameState: e.gameState, update: e.update })] }) } var DI = i(518), kI = {}; kI.styleTagTransform = v(), kI.setAttributes = p(), kI.insert = d().bind(null, "head"), kI.domAPI = c(), kI.insertStyleElement = m(), s()(DI.A, kI); const NI = DI.A && DI.A.locals ? DI.A.locals : void 0; var FI = i(535), OI = {}; OI.styleTagTransform = v(), OI.setAttributes = p(), OI.insert = d().bind(null, "head"), OI.domAPI = c(), OI.insertStyleElement = m(), s()(FI.A, OI); const UI = FI.A && FI.A.locals ? FI.A.locals : void 0; function zI(e) { return (0, ii.jsx)("div", { style: { borderRadius: "3px", margin: "5px", width: `${e.size.toString()}px`, height: `${e.size.toString()}px`, backgroundColor: A[e.player] } }) } var HI = function () { return HI = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, HI.apply(this, arguments) }, GI = !1, jI = (0, n.forwardRef)((function (e, t) { var r = e.style, i = function (e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n }(e, ["style"]), a = WI(); !GI && (null == r ? void 0 : r.height) && (GI = !0, console.warn("<Div100vh /> overrides the height property of the style prop")); var o = HI(HI({}, r), { height: a ? a + "px" : "100vh" }); return n.createElement("div", HI({ ref: t, style: o }, i)) })); jI.displayName = "Div100vh"; const VI = jI; function WI() { var e = (0, n.useState)(XI), t = e[0], r = e[1], i = function () { var e = (0, n.useState)(!1), t = e[0], r = e[1]; return (0, n.useEffect)((function () { JI() && r(!0) }), []), t }(); return (0, n.useEffect)((function () { if (i) return window.addEventListener("resize", e), function () { return window.removeEventListener("resize", e) }; function e() { var e = XI(); r(e) } }), [i]), i ? t : null } function XI() { return JI() ? window.innerHeight : null } function JI() { return "undefined" != typeof window && "undefined" != typeof document } function YI(e) { return vi("MuiCard", e) } yi("MuiCard", ["root"]); const QI = ei(Si, { name: "MuiCard", slot: "Root", overridesResolver: (e, t) => t.root })({ overflow: "hidden" }), KI = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiCard" }), { className: r, raised: i = !1, ...a } = n, o = { ...n, raised: i }, s = (e => { const { classes: t } = e; return w({ root: ["root"] }, YI, t) })(o); return (0, ii.jsx)(QI, { className: M(s.root, r), elevation: i ? 8 : void 0, ref: t, ownerState: o, ...a }) })), qI = { one_by_two: "data:image/png;base64,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", one_by_three: "data:image/png;base64,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", one_by_four: "data:image/png;base64,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", two_by_two: "data:image/png;base64,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", z: "data:image/png;base64,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", t: "data:image/png;base64,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", l: "data:image/png;base64,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", short_l: "data:image/png;base64,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", right_screw: "data:image/png;base64,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", left_screw: "data:image/png;base64,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", corner: "data:image/png;base64,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" }; function ZI(e) { const t = e.state.player_state.current_player, n = e.state.player_state.players[t], r = Object.entries(n.pieces), i = WI(); return (0, ii.jsx)(ii.Fragment, { children: i && (0, ii.jsxs)(KI, { className: UI.pieceSelectorContainer, style: { height: i / 2, width: "100%" }, children: [(0, ii.jsx)($I, { current_player: t }), (0, ii.jsx)(eP, { pieces: r, current_player: t, update: e.update })] }) }) } function $I(e) { return (0, ii.jsxs)("div", { style: { height: "30px", display: "flex", flexDirection: "row", justifyContent: "space-evenly", alignItems: "center" }, children: [(0, ii.jsx)("h4", { children: "Select a Piece" }), (0, ii.jsxs)("div", { style: { display: "flex", flexDirection: "row", alignItems: "center" }, children: [(0, ii.jsx)("h4", { children: "Current player: " }), (0, ii.jsx)(zI, { size: 25, player: e.current_player })] })] }) } function eP(e) { return (0, ii.jsx)("div", { className: UI.pieceGroup, children: e.pieces.map((t => { let [n, r] = t; return (0, ii.jsx)(tP, { piece: r, status: r ? "available" : "unavailable", pieceName: n, setSelected: () => e.update({ type: "SelectPiece", data: n }) }, `${n}${e.current_player}`) })) }) } function tP(e) { return (0, ii.jsx)(el, { className: UI[e.status], sx: { color: "" }, disabled: "unavailable" === e.status, onClick: () => "available" === e.status && e.setSelected(), variant: "contained", children: (0, ii.jsx)("img", { src: qI[e.pieceName], alt: e.pieceName, draggable: "false" }) }) } const nP = e => { const t = e.gameState.player_state.players[e.gameState.player_state.current_player].selected_piece; return (0, ii.jsxs)("div", { className: NI.controlsContainer, children: [(0, ii.jsx)("div", { style: { flex: "1" }, children: (0, ii.jsx)(rP, { gameState: e.gameState, update: e.update, error: e.error }) }), (0, ii.jsx)("div", { className: NI.bottomControls, children: null === t ? (0, ii.jsx)(ZI, { state: e.gameState, update: e.update }) : (0, ii.jsx)(aP, { update: e.update }) })] }) }, rP = e => { const { showAvailableSpace: t, setShowAvailableSpace: r } = (0, n.useContext)(JP); return (0, ii.jsxs)("div", { className: NI.topControls, children: [(0, ii.jsx)(el, { sx: { height: 50, width: 85, margin: 1 }, variant: "contained", onClick: () => r(!t), children: (0, ii.jsx)(ki, { variant: "button", sx: { scale: .75 }, children: (t ? "Hide" : "Show") + " available space" }) }), (0, ii.jsx)(iP, { p1score: e.gameState.score.p1, p2score: e.gameState.score.p2 }), (0, ii.jsx)(el, { sx: { height: 50, width: 85, margin: 1 }, variant: "contained", onClick: () => e.update({ type: "PlayPreviewedPiece" }), disabled: !e.gameState.board_state.previewed_piece || !!e.error, children: (0, ii.jsx)(ki, { variant: "button", children: "Play" }) })] }) }, iP = e => (0, ii.jsxs)("div", { className: NI.scoreContainer, children: [(0, ii.jsxs)("div", { className: NI.scoreRow, children: [(0, ii.jsx)("h2", { children: e.p1score }), (0, ii.jsx)(zI, { player: "p1", size: 25 })] }), (0, ii.jsx)("div", { style: { height: 30, width: 3, borderRadius: 2, backgroundColor: "black", margin: 5 } }), (0, ii.jsxs)("div", { className: NI.scoreRow, children: [(0, ii.jsx)(zI, { player: "p2", size: 25 }), (0, ii.jsx)("h2", { children: e.p2score })] })] }), aP = e => (0, ii.jsxs)("div", { style: { width: "100%", display: "flex", justifyContent: "space-between" }, children: [(0, ii.jsx)(el, { sx: { margin: 1 }, variant: "contained", className: NI.button, onClick: () => e.update({ type: "PassTurn" }), children: "Pass Turn" }), (0, ii.jsx)(el, { sx: { margin: 1 }, variant: "contained", className: NI.button, onClick: () => e.update({ type: "ClearSelectedPiece" }), children: "Switch Piece" })] }); var oP = i(820), sP = {}; sP.styleTagTransform = v(), sP.setAttributes = p(), sP.insert = d().bind(null, "head"), sP.domAPI = c(), sP.insertStyleElement = m(), s()(oP.A, sP); const lP = oP.A && oP.A.locals ? oP.A.locals : void 0, cP = e => { let t; const n = new Set, r = (e, r) => { const i = "function" == typeof e ? e(t) : e; if (!Object.is(i, t)) { const e = t; t = (null != r ? r : "object" != typeof i || null === i) ? i : Object.assign({}, t, i), n.forEach((n => n(t, e))) } }, i = () => t, a = { setState: r, getState: i, getInitialState: () => o, subscribe: e => (n.add(e), () => n.delete(e)), destroy: () => { console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear() } }, o = t = e(r, i, a); return a }; var uP = i(242); const { useDebugValue: dP } = n, { useSyncExternalStoreWithSelector: hP } = uP; let pP = !1; const fP = e => e, mP = e => { "function" != typeof e && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."); const t = "function" == typeof e ? (e => e ? cP(e) : cP)(e) : e, n = (e, n) => function (e, t = fP, n) { n && !pP && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), pP = !0); const r = hP(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n); return dP(r), r }(t, e, n); return Object.assign(n, t), n }; var gP, vP; const yP = "undefined" != typeof window && (null != (gP = window.document) && gP.createElement || "ReactNative" === (null == (vP = window.navigator) ? void 0 : vP.product)) ? n.useLayoutEffect : n.useEffect, bP = new df, xP = function () { const e = (t = e => ({ current: new Array, version: 0, set: e })) ? mP(t) : mP; var t; return { In: ({ children: t }) => { const n = e((e => e.set)), r = e((e => e.version)); return yP((() => { n((e => ({ version: e.version + 1 }))) }), []), yP((() => (n((({ current: e }) => ({ current: [...e, t] }))), () => n((({ current: e }) => ({ current: e.filter((e => e !== t)) }))))), [t, r]), null }, Out: () => { const t = e((e => e.current)); return n.createElement(n.Fragment, null, t) } } }(); function AP(e) { return "top" in e } function SP(e, t) { const { right: n, top: r, left: i, bottom: a, width: o, height: s } = t, l = t.bottom < 0 || r > e.height || n < 0 || t.left > e.width; if (AP(e)) { const t = e.top + e.height - a; return { position: { width: o, height: s, left: i - e.left, top: r, bottom: t, right: n }, isOffscreen: l } } return { position: { width: o, height: s, top: r, left: i, bottom: e.height - a, right: n }, isOffscreen: l } } function MP(e, { left: t, bottom: n, width: r, height: i }) { let a; const o = r / i; var s; return (s = e.camera) && s.isOrthographicCamera ? e.camera.left === r / -2 && e.camera.right === r / 2 && e.camera.top === i / 2 && e.camera.bottom === i / -2 || (Object.assign(e.camera, { left: r / -2, right: r / 2, top: i / 2, bottom: i / -2 }), e.camera.updateProjectionMatrix()) : e.camera.aspect !== o && (e.camera.aspect = o, e.camera.updateProjectionMatrix()), a = e.gl.autoClear, e.gl.autoClear = !1, e.gl.setViewport(t, n, r, i), e.gl.setScissor(t, n, r, i), e.gl.setScissorTest(!0), a } function wP(e, t) { e.gl.setScissorTest(!1), e.gl.autoClear = t } function _P(e) { e.gl.getClearColor(bP), e.gl.setClearColor(bP, e.gl.getClearAlpha()), e.gl.clear(!0, !0) } function EP({ visible: e = !0, canvasSize: t, scene: r, index: i, children: a, frames: o, rect: s, track: l }) { const c = d_(), [u, d] = n.useState(!1); let h = 0; return h_((n => { var i; if ((o === 1 / 0 || h <= o) && (l && (s.current = null == (i = l.current) ? void 0 : i.getBoundingClientRect()), h++), s.current) { const { position: i, isOffscreen: o } = SP(t, s.current); if (u !== o && d(o), e && !u && s.current) { const e = MP(n, i); n.gl.render(a ? n.scene : r, n.camera), wP(n, e) } } }), i), n.useLayoutEffect((() => { const n = s.current; if (n && (!e || !u)) { const { position: e } = SP(t, n), r = MP(c, e); _P(c), wP(c, r) } }), [e, u]), n.useEffect((() => { if (!l) return; const e = s.current, n = c.get().events.connected; return c.setEvents({ connected: l.current }), () => { if (e) { const { position: n } = SP(t, e), r = MP(c, n); _P(c), wP(c, r) } c.setEvents({ connected: n }) } }), [l]), n.useEffect((() => { AP(t) || console.warn("Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. Upgrade to @react-three/fiber ^8.1.0 for support.\n See https://github.com/pmndrs/drei/issues/944") }), []), n.createElement(n.Fragment, null, a, n.createElement("group", { onPointerOver: () => null })) } const CP = n.forwardRef((({ track: e, visible: t = !0, index: r = 1, id: i, style: a, className: o, frames: s = 1 / 0, children: l, ...c }, u) => { var d, h, p, f; const m = n.useRef(null), { size: g, scene: v } = d_(), [y] = n.useState((() => new py)), [b, x] = n.useReducer((() => !0), !1), A = n.useCallback(((t, n) => { if (m.current && e && e.current && t.target === e.current) { const { width: e, height: r, left: i, top: a } = m.current, o = t.clientX - i, s = t.clientY - a; n.pointer.set(o / e * 2 - 1, -s / r * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera) } }), [m, e]); return n.useEffect((() => { var t; e && (m.current = null == (t = e.current) ? void 0 : t.getBoundingClientRect()), x() }), [e]), n.createElement("group", _({ ref: u }, c), b && function (e, t, n) { return (0, ii.jsx)(__, { children: e, container: t, state: n }, t.uuid) }(n.createElement(EP, { visible: t, canvasSize: g, frames: s, scene: v, track: e, rect: m, index: r }, l), y, { events: { compute: A, priority: r }, size: { width: null == (d = m.current) ? void 0 : d.width, height: null == (h = m.current) ? void 0 : h.height, top: null == (p = m.current) ? void 0 : p.top, left: null == (f = m.current) ? void 0 : f.left } })) })), TP = n.forwardRef((({ as: e = "div", id: t, visible: r, className: i, style: a, index: o = 1, track: s, frames: l = 1 / 0, children: c, ...u }, d) => { const h = n.useId(), p = n.useRef(null); return n.useImperativeHandle(d, (() => p.current)), n.createElement(n.Fragment, null, n.createElement(e, _({ ref: p, id: t, className: i, style: a }, u)), n.createElement(xP.In, null, n.createElement(CP, { visible: r, key: h, track: p, frames: l, index: o }, c))) })), RP = n.forwardRef(((e, t) => n.useContext(e_) ? n.createElement(CP, _({ ref: t }, e)) : n.createElement(TP, _({ ref: t }, e)))); RP.Port = () => n.createElement(xP.Out, null); const BP = e => { const t = (0, n.useRef)(null), r = (0, n.useRef)(null), i = (0, n.useRef)(null); return (0, n.useEffect)((() => { console.log("running") }), [e]), (0, ii.jsxs)("div", { className: lP.canvasContainer, ref: i, children: [(0, ii.jsx)("div", { ...e.topDivProps, ref: t }), (0, ii.jsx)("div", { ...e.bottomDivProps, ref: r }), (0, ii.jsxs)(K_, { eventSource: i, frameloop: "always", style: { position: "absolute" }, children: [(0, ii.jsx)(sE, {}), (0, ii.jsx)(RP, { index: 1, track: t, children: e.topContent }), (0, ii.jsx)(RP, { index: 2, track: r, children: e.bottomContent })] })] }) }; function IP(e) { return vi("MuiAlert", e) } const PP = yi("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]), LP = al((0, ii.jsx)("path", { d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z" }), "SuccessOutlined"), DP = al((0, ii.jsx)("path", { d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z" }), "ReportProblemOutlined"), kP = al((0, ii.jsx)("path", { d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }), "ErrorOutline"), NP = al((0, ii.jsx)("path", { d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z" }), "InfoOutlined"), FP = al((0, ii.jsx)("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }), "Close"), OP = ei(Si, { name: "MuiAlert", slot: "Root", overridesResolver: (e, t) => { const { ownerState: n } = e; return [t.root, t[n.variant], t[`${n.variant}${li(n.color || n.severity)}`]] } })(ni((({ theme: e }) => { const t = "light" === e.palette.mode ? Tn : Bn, n = "light" === e.palette.mode ? Bn : Tn; return { ...e.typography.body2, backgroundColor: "transparent", display: "flex", padding: "6px 16px", variants: [...Object.entries(e.palette).filter(ci(["light"])).map((([r]) => ({ props: { colorSeverity: r, variant: "standard" }, style: { color: e.vars ? e.vars.palette.Alert[`${r}Color`] : t(e.palette[r].light, .6), backgroundColor: e.vars ? e.vars.palette.Alert[`${r}StandardBg`] : n(e.palette[r].light, .9), [`& .${PP.icon}`]: e.vars ? { color: e.vars.palette.Alert[`${r}IconColor`] } : { color: e.palette[r].main } } }))), ...Object.entries(e.palette).filter(ci(["light"])).map((([n]) => ({ props: { colorSeverity: n, variant: "outlined" }, style: { color: e.vars ? e.vars.palette.Alert[`${n}Color`] : t(e.palette[n].light, .6), border: `1px solid ${(e.vars || e).palette[n].light}`, [`& .${PP.icon}`]: e.vars ? { color: e.vars.palette.Alert[`${n}IconColor`] } : { color: e.palette[n].main } } }))), ...Object.entries(e.palette).filter(ci(["dark"])).map((([t]) => ({ props: { colorSeverity: t, variant: "filled" }, style: { fontWeight: e.typography.fontWeightMedium, ...e.vars ? { color: e.vars.palette.Alert[`${t}FilledColor`], backgroundColor: e.vars.palette.Alert[`${t}FilledBg`] } : { backgroundColor: "dark" === e.palette.mode ? e.palette[t].dark : e.palette[t].main, color: e.palette.getContrastText(e.palette[t].main) } } })))] } }))), UP = ei("div", { name: "MuiAlert", slot: "Icon", overridesResolver: (e, t) => t.icon })({ marginRight: 12, padding: "7px 0", display: "flex", fontSize: 22, opacity: .9 }), zP = ei("div", { name: "MuiAlert", slot: "Message", overridesResolver: (e, t) => t.message })({ padding: "8px 0", minWidth: 0, overflow: "auto" }), HP = ei("div", { name: "MuiAlert", slot: "Action", overridesResolver: (e, t) => t.action })({ display: "flex", alignItems: "flex-start", padding: "4px 0 0 16px", marginLeft: "auto", marginRight: -8 }), GP = { success: (0, ii.jsx)(LP, { fontSize: "inherit" }), warning: (0, ii.jsx)(DP, { fontSize: "inherit" }), error: (0, ii.jsx)(kP, { fontSize: "inherit" }), info: (0, ii.jsx)(NP, { fontSize: "inherit" }) }, jP = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiAlert" }), { action: r, children: i, className: a, closeText: o = "Close", color: s, components: l = {}, componentsProps: c = {}, icon: u, iconMapping: d = GP, onClose: h, role: p = "alert", severity: f = "success", slotProps: m = {}, slots: g = {}, variant: v = "standard", ...y } = n, b = { ...n, color: s, severity: f, variant: v, colorSeverity: s || f }, x = (e => { const { variant: t, color: n, severity: r, classes: i } = e; return w({ root: ["root", `color${li(n || r)}`, `${t}${li(n || r)}`, `${t}`], icon: ["icon"], message: ["message"], action: ["action"] }, IP, i) })(b), A = { slots: { closeButton: l.CloseButton, closeIcon: l.CloseIcon, ...g }, slotProps: { ...c, ...m } }, [S, _] = To("closeButton", { elementType: La, externalForwardedProps: A, ownerState: b }), [E, C] = To("closeIcon", { elementType: FP, externalForwardedProps: A, ownerState: b }); return (0, ii.jsxs)(OP, { role: p, elevation: 0, ownerState: b, className: M(x.root, a), ref: t, ...y, children: [!1 !== u ? (0, ii.jsx)(UP, { ownerState: b, className: x.icon, children: u || d[f] || GP[f] }) : null, (0, ii.jsx)(zP, { ownerState: b, className: x.message, children: i }), null != r ? (0, ii.jsx)(HP, { ownerState: b, className: x.action, children: r }) : null, null == r && h ? (0, ii.jsx)(HP, { ownerState: b, className: x.action, children: (0, ii.jsx)(S, { size: "small", "aria-label": o, title: o, color: "inherit", onClick: h, ..._, children: (0, ii.jsx)(E, { fontSize: "small", ...C }) }) }) : null] }) })); function VP(e) { return vi("MuiAlertTitle", e) } yi("MuiAlertTitle", ["root"]); const WP = ei(ki, { name: "MuiAlertTitle", slot: "Root", overridesResolver: (e, t) => t.root })(ni((({ theme: e }) => ({ fontWeight: e.typography.fontWeightMedium, marginTop: -2 })))), XP = n.forwardRef((function (e, t) { const n = si({ props: e, name: "MuiAlertTitle" }), { className: r, ...i } = n, a = n, o = (e => { const { classes: t } = e; return w({ root: ["root"] }, VP, t) })(a); return (0, ii.jsx)(WP, { gutterBottom: !0, component: "div", ownerState: a, ref: t, className: M(o.root, r), ...i }) })), JP = (0, n.createContext)({ showAvailableSpace: !1, setShowAvailableSpace: e => { } }); function YP(e) { const { state: r, update: i } = function (e) { const r = function () { const [e, r] = (0, n.useState)(); return (0, n.useEffect)((() => { (async () => { await fB(), r(t) })() }), []), e }(), [i, a] = (0, n.useState)(); return (0, n.useEffect)((() => { if (r) { let t = r.new_game(JSON.stringify(e)), n = JSON.parse(t); a(n) } }), [r, e]), (0, n.useEffect)((() => { if (r && "VSGreedyAI" === i?.game_mode.type && "p2" === i.player_state.current_player) { let e = { type: "MakeGreedyAIMove" }, t = r.next_game_state(JSON.stringify(i), JSON.stringify(e)), n = JSON.parse(t); a(n) } }), [i, r]), { state: i, update: e => { if (r) { let t = r.next_game_state(JSON.stringify(i), JSON.stringify(e)), n = JSON.parse(t); a(n) } } } }(e.mode), [a, o] = (0, n.useState)(!0), s = r?.board_state.previewed_piece?.find((e => e.error))?.error, [l, c] = (0, n.useState)(!1); return (0, n.useEffect)((() => { o(!0) }), [s]), (0, ii.jsx)(JP.Provider, { value: { showAvailableSpace: l, setShowAvailableSpace: c }, children: r && (0, ii.jsxs)(ii.Fragment, { children: [(0, ii.jsx)(BP, { topDivProps: { className: lP.canvasContainer, style: { backgroundColor: "grey" } }, topContent: (0, ii.jsx)(LI, { gameState: r, update: i }), bottomDivProps: { className: lP.canvasContainer, style: { backgroundColor: "#1f1f1f" } }, bottomContent: (0, ii.jsx)(II, { playerState: r.player_state, update: i }) }), (0, ii.jsx)(nP, { gameState: r, update: i, error: s }), (0, ii.jsx)(QP, { game_state: r, showError: a, setShowError: o })] }) }) } const QP = e => { const [t, r] = (0, n.useState)(!1), i = (e.game_state.board_state.previewed_piece || []).find((e => e.error))?.error; (0, n.useEffect)((() => { r(!1) }), [i]); return (0, ii.jsx)("div", { style: { position: "absolute", bottom: 5, left: 5, right: 5, display: "flex", justifyContent: "center", pointerEvents: "none" }, children: i && (0, ii.jsx)(el, { style: { pointerEvents: "all" }, children: (0, ii.jsxs)(jP, { onClick: () => r(!t), severity: "warning", style: { flexShrink: 1 }, onClose: t ? () => r(!1) : void 0, children: [(0, ii.jsx)(XP, { children: { Collision: "Collision", NotTouchingPiece: "Not Touching", OutOfBounds: "Out of bounds", Unsupported: "Unsupported" }[i] }), t && { Collision: "Can only play in open space", NotTouchingPiece: "Must touch own piece or opponent's piece on first turn", OutOfBounds: "All cubes must be inside the play area", Unsupported: "One or more cubes is unsupported" }[i]] }) }) }) }; function KP(e) { const { showAvailableSpace: t } = (0, n.useContext)(JP); let r = e.boardState.board.cells.flatMap(((e, t) => e.flatMap(((e, n) => e.map(((e, r) => ({ cell: e, position: [t, n, r] }))))))).filter((e => { let { cell: t, position: n } = e; return "Empty" === t.type })); return (0, ii.jsx)(ii.Fragment, { children: t && r.map((e => { let { position: t } = e; return (0, ii.jsx)(ii.Fragment, { children: (0, ii.jsx)("mesh", { position: t, children: (0, ii.jsx)(yE, { geometry: new em(1, 1, 1), simplify: !0, fill: ME(t[1]), stroke: "#000000", thickness: .15 }) }, t.toString()) }) })) }) } function qP(e) { let t = e.gameState.board_state.board.center; const n = (new Gh).fromArray(t).negate(); return (0, ii.jsxs)("group", { position: n, children: [(0, ii.jsx)(wE, { boardState: e.gameState.board_state, update: e.update }), (0, ii.jsx)(qR, { boardState: e.gameState.board_state, update: e.update, vsAI: "VSGreedyAI" === e.gameState.game_mode.type }), (0, ii.jsx)(mB, { gameState: e.gameState }), (0, ii.jsx)(KP, { boardState: e.gameState.board_state })] }) } const ZP = () => (0, ii.jsxs)(K_, { frameloop: "always", style: { cursor: "move" }, children: [(0, ii.jsx)(lE, {}), (0, ii.jsx)(sE, {}), (0, ii.jsx)(eL, {})] }), $P = { type: "TwoPlayer", data: "Tower" }, eL = () => { const { state: e } = function (e) { const r = function () { const [e, r] = (0, n.useState)(); return (0, n.useEffect)((() => { (async () => { await fB(), r(t) })() }), []), e }(), [i, a] = (0, n.useState)(); return (0, n.useEffect)((() => { if (r) { let t = r.new_game(JSON.stringify(e)), n = JSON.parse(t); a(n) } }), [r, e]), (0, n.useEffect)((() => { if (r && !1 === i?.game_ended) { console.log(i?.game_ended); let e = { type: "MakeGreedyAIMove" }, t = r.next_game_state(JSON.stringify(i), JSON.stringify(e)), n = JSON.parse(t); n.game_ended || setTimeout((() => { a(n) }), 750) } }), [i, r]), { state: i } }($P); return (0, ii.jsx)(ii.Fragment, { children: e && (0, ii.jsx)(qP, { gameState: e, update: e => { } }) }) }; var tL = i(593), nL = {}; nL.styleTagTransform = v(), nL.setAttributes = p(), nL.insert = d().bind(null, "head"), nL.domAPI = c(), nL.insertStyleElement = m(), s()(tL.A, nL); const rL = tL.A && tL.A.locals ? tL.A.locals : void 0, iL = yi("MuiBox", ["root"]), aL = Qr(), oL = function (e = {}) { const { themeId: t, defaultTheme: r, defaultClassName: i = "MuiBox-root", generateClassName: a } = e, o = tt("div", { shouldForwardProp: e => "theme" !== e && "sx" !== e && "as" !== e })(un), s = n.forwardRef((function (e, n) { const s = hi(r), { className: l, component: c = "div", ...u } = Ti(e); return (0, ii.jsx)(o, { as: c, ref: n, className: M(l, a ? a(i) : i), theme: t && s[t] || s, ...u }) })); return s }({ themeId: qr, defaultTheme: aL, defaultClassName: iL.root, generateClassName: mi.generate }), sL = oL, lL = e => (0, ii.jsxs)("div", { className: rL.menu, children: [(0, ii.jsx)(ZP, {}), (0, ii.jsx)(sL, { style: { flexDirection: "row" }, children: (0, ii.jsxs)(KI, { style: { width: "100%", alignItems: "center", display: "flex", flexDirection: "column" }, children: [(0, ii.jsx)(ki, { variant: "overline", children: "Select game mode:" }), (0, ii.jsxs)("div", { style: { flex: "1", display: "flex", width: "100%" }, children: [(0, ii.jsx)(cL, { setMode: e.setMode, gameMode: "VSGreedyAI" }), (0, ii.jsx)(cL, { setMode: e.setMode, gameMode: "TwoPlayer" })] })] }) })] }); function cL(e) { return (0, ii.jsxs)("div", { className: rL.mapSelector, children: [(0, ii.jsx)(ki, { variant: "subtitle1", children: e.gameMode }), ["Tower", "Pyramid", "Wall", "Stairs"].map((t => (0, ii.jsx)(ii.Fragment, { children: (0, ii.jsx)(el, { sx: { margin: 1 }, variant: "contained", className: rL.button, onClick: () => e.setMode({ type: e.gameMode, data: t }), children: t }) })))] }) } var uL = i(171), dL = {}; dL.styleTagTransform = v(), dL.setAttributes = p(), dL.insert = d().bind(null, "head"), dL.domAPI = c(), dL.insertStyleElement = m(), s()(uL.A, dL); const hL = uL.A && uL.A.locals ? uL.A.locals : void 0, pL = n.createContext(null); function fL() { return n.useContext(pL) } const mL = "function" == typeof Symbol && Symbol.for ? Symbol.for("mui.nested") : "__THEME_NESTED__", gL = function (e) { const { children: t, theme: r } = e, i = fL(), a = n.useMemo((() => { const e = null === i ? { ...r } : function (e, t) { return "function" == typeof t ? t(e) : { ...e, ...t } }(i, r); return null != e && (e[mL] = null !== i), e }), [r, i]); return (0, ii.jsx)(pL.Provider, { value: a, children: t }) }, vL = {}; function yL(e, t, r, i = !1) { return n.useMemo((() => { const n = e && t[e] || t; if ("function" == typeof r) { const a = r(n), o = e ? { ...t, [e]: a } : a; return i ? () => o : o } return e ? { ...t, [e]: r } : { ...t, ...r } }), [e, t, r, i]) } const bL = function (e) { const { children: t, theme: n, themeId: r } = e, i = ui(vL), a = fL() || vL, o = yL(r, i, n), s = yL(r, a, n, !0), l = "rtl" === o.direction; return (0, ii.jsx)(gL, { theme: s, children: (0, ii.jsx)(Xe.Provider, { value: o, children: (0, ii.jsx)(ka, { value: l, children: (0, ii.jsx)(oi, { value: o?.components, children: t }) }) }) }) }; function xL({ theme: e, ...t }) { const n = qr in e ? e[qr] : void 0; return (0, ii.jsx)(bL, { ...t, themeId: n ? qr : void 0, theme: n || e }) } function AL(e) { const { styles: t, defaultTheme: n = {} } = e, r = "function" == typeof t ? e => { return t(null == (r = e) || 0 === Object.keys(r).length ? n : e); var r } : t; return (0, ii.jsx)(ma, { styles: r }) } const SL = "mode", ML = "color-scheme", wL = "data-color-scheme"; function _L(e) { if ("undefined" != typeof window && "function" == typeof window.matchMedia && "system" === e) return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" } function EL(e, t) { return "light" === e.mode || "system" === e.mode && "light" === e.systemMode ? t("light") : "dark" === e.mode || "system" === e.mode && "dark" === e.systemMode ? t("dark") : void 0 } function CL(e, t) { if ("undefined" == typeof window) return; let n; try { n = localStorage.getItem(e) || void 0, n || localStorage.setItem(e, t) } catch { } return n || t } const TL = "mui-color-scheme", RL = "light", BL = "dark", IL = "mui-mode", { CssVarsProvider: PL, useColorScheme: LL, getInitColorSchemeScript: DL } = function (e) { const { themeId: t, theme: r = {}, modeStorageKey: i = SL, colorSchemeStorageKey: a = ML, disableTransitionOnChange: o = !1, defaultColorScheme: s, resolveTheme: l } = e, c = { allColorSchemes: [], colorScheme: void 0, darkColorScheme: void 0, lightColorScheme: void 0, mode: void 0, setColorScheme: () => { }, setMode: () => { }, systemMode: void 0 }, u = n.createContext(void 0), d = "string" == typeof s ? s : s.light, h = "string" == typeof s ? s : s.dark; return { CssVarsProvider: function (e) { const { children: c, theme: d, modeStorageKey: h = i, colorSchemeStorageKey: p = a, disableTransitionOnChange: f = o, storageWindow: m = ("undefined" == typeof window ? void 0 : window), documentNode: g = ("undefined" == typeof document ? void 0 : document), colorSchemeNode: v = ("undefined" == typeof document ? void 0 : document.documentElement), disableNestedContext: y = !1, disableStyleSheetGeneration: b = !1, defaultMode: x = "system" } = e, A = n.useRef(!1), S = fL(), M = n.useContext(u), w = !!M && !y, _ = n.useMemo((() => d || ("function" == typeof r ? r() : r)), [d]), E = _[t], { colorSchemes: C = {}, components: T = {}, cssVarPrefix: R, ...B } = E || _, I = Object.keys(C).filter((e => !!C[e])).join(","), P = n.useMemo((() => I.split(",")), [I]), L = "string" == typeof s ? s : s.light, D = "string" == typeof s ? s : s.dark, k = C[L] && C[D] ? x : C[B.defaultColorScheme]?.palette?.mode || B.palette?.mode, { mode: N, setMode: F, systemMode: O, lightColorScheme: U, darkColorScheme: z, colorScheme: H, setColorScheme: G } = function (e) { const { defaultMode: t = "light", defaultLightColorScheme: r, defaultDarkColorScheme: i, supportedColorSchemes: a = [], modeStorageKey: o = SL, colorSchemeStorageKey: s = ML, storageWindow: l = ("undefined" == typeof window ? void 0 : window) } = e, c = a.join(","), u = a.length > 1, [d, h] = n.useState((() => { const e = CL(o, t), n = CL(`${s}-light`, r), a = CL(`${s}-dark`, i); return { mode: e, systemMode: _L(e), lightColorScheme: n, darkColorScheme: a } })), [, p] = n.useState(!1), f = n.useRef(!1); n.useEffect((() => { u && p(!0), f.current = !0 }), [u]); const m = function (e) { return EL(e, (t => "light" === t ? e.lightColorScheme : "dark" === t ? e.darkColorScheme : void 0)) }(d), g = n.useCallback((e => { h((n => { if (e === n.mode) return n; const r = e ?? t; try { localStorage.setItem(o, r) } catch { } return { ...n, mode: r, systemMode: _L(r) } })) }), [o, t]), v = n.useCallback((e => { e ? "string" == typeof e ? e && !c.includes(e) ? console.error(`\`${e}\` does not exist in \`theme.colorSchemes\`.`) : h((t => { const n = { ...t }; return EL(t, (t => { try { localStorage.setItem(`${s}-${t}`, e) } catch { } "light" === t && (n.lightColorScheme = e), "dark" === t && (n.darkColorScheme = e) })), n })) : h((t => { const n = { ...t }, a = null === e.light ? r : e.light, o = null === e.dark ? i : e.dark; if (a) if (c.includes(a)) { n.lightColorScheme = a; try { localStorage.setItem(`${s}-light`, a) } catch (e) { } } else console.error(`\`${a}\` does not exist in \`theme.colorSchemes\`.`); if (o) if (c.includes(o)) { n.darkColorScheme = o; try { localStorage.setItem(`${s}-dark`, o) } catch (e) { } } else console.error(`\`${o}\` does not exist in \`theme.colorSchemes\`.`); return n })) : h((e => { try { localStorage.setItem(`${s}-light`, r), localStorage.setItem(`${s}-dark`, i) } catch { } return { ...e, lightColorScheme: r, darkColorScheme: i } })) }), [c, s, r, i]), y = n.useCallback((e => { "system" === d.mode && h((t => { const n = e?.matches ? "dark" : "light"; return t.systemMode === n ? t : { ...t, systemMode: n } })) }), [d.mode]), b = n.useRef(y); return b.current = y, n.useEffect((() => { if ("function" != typeof window.matchMedia || !u) return; const e = (...e) => b.current(...e), t = window.matchMedia("(prefers-color-scheme: dark)"); return t.addListener(e), e(t), () => { t.removeListener(e) } }), [u]), n.useEffect((() => { if (l && u) { const e = e => { const n = e.newValue; "string" != typeof e.key || !e.key.startsWith(s) || n && !c.match(n) || (e.key.endsWith("light") && v({ light: n }), e.key.endsWith("dark") && v({ dark: n })), e.key !== o || n && !["light", "dark", "system"].includes(n) || g(n || t) }; return l.addEventListener("storage", e), () => { l.removeEventListener("storage", e) } } }), [v, g, o, s, c, t, l, u]), { ...d, mode: f.current || !u ? d.mode : void 0, systemMode: f.current || !u ? d.systemMode : void 0, colorScheme: f.current || !u ? m : void 0, setMode: g, setColorScheme: v } }({ supportedColorSchemes: P, defaultLightColorScheme: L, defaultDarkColorScheme: D, modeStorageKey: h, colorSchemeStorageKey: p, defaultMode: k, storageWindow: m }); let j = N, V = H; w && (j = M.mode, V = M.colorScheme); const W = V || B.defaultColorScheme, X = B.generateThemeVars?.() || B.vars, J = { ...B, components: T, colorSchemes: C, cssVarPrefix: R, vars: X }; if ("function" == typeof J.generateSpacing && (J.spacing = J.generateSpacing()), W) { const e = C[W]; e && "object" == typeof e && Object.keys(e).forEach((t => { e[t] && "object" == typeof e[t] ? J[t] = { ...J[t], ...e[t] } : J[t] = e[t] })) } const Y = B.colorSchemeSelector; n.useEffect((() => { if (V && v && Y && "media" !== Y) { const e = Y; let t = Y; if ("class" === e && (t = ".%s"), "data" === e && (t = "[data-%s]"), e?.startsWith("data-") && !e.includes("%s") && (t = `[${e}="%s"]`), t.startsWith(".")) v.classList.remove(...P.map((e => t.substring(1).replace("%s", e)))), v.classList.add(t.substring(1).replace("%s", V)); else { const e = t.replace("%s", V).match(/\[([^\]]+)\]/); if (e) { const [t, n] = e[1].split("="); n || P.forEach((e => { v.removeAttribute(t.replace(V, e)) })), v.setAttribute(t, n ? n.replace(/"|'/g, "") : "") } else v.setAttribute(t, V) } } }), [V, Y, v, P]), n.useEffect((() => { let e; if (f && A.current && g) { const t = g.createElement("style"); t.appendChild(g.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), g.head.appendChild(t), window.getComputedStyle(g.body), e = setTimeout((() => { g.head.removeChild(t) }), 1) } return () => { clearTimeout(e) } }), [V, f, g]), n.useEffect((() => (A.current = !0, () => { A.current = !1 })), []); const Q = n.useMemo((() => ({ allColorSchemes: P, colorScheme: V, darkColorScheme: z, lightColorScheme: U, mode: j, setColorScheme: G, setMode: F, systemMode: O })), [P, V, z, U, j, G, F, O]); let K = !0; (b || !1 === B.cssVariables || w && S?.cssVarPrefix === R) && (K = !1); const q = (0, ii.jsxs)(n.Fragment, { children: [(0, ii.jsx)(bL, { themeId: E ? t : void 0, theme: l ? l(J) : J, children: c }), K && (0, ii.jsx)(AL, { styles: J.generateStyleSheets?.() || [] })] }); return w ? q : (0, ii.jsx)(u.Provider, { value: Q, children: q }) }, useColorScheme: () => n.useContext(u) || c, getInitColorSchemeScript: e => function (e) { const { defaultLightColorScheme: t = "light", defaultDarkColorScheme: n = "dark", modeStorageKey: r = SL, colorSchemeStorageKey: i = ML, attribute: a = wL, colorSchemeNode: o = "document.documentElement", nonce: s } = e || {}; let l = "", c = a; if ("class" === a && (c = ".%s"), "data" === a && (c = "[data-%s]"), c.startsWith(".")) { const e = c.substring(1); l += `${o}.classList.remove('${e}'.replace('%s', light), '${e}'.replace('%s', dark));\n      ${o}.classList.add('${e}'.replace('%s', colorScheme));` } const u = c.match(/\[([^\]]+)\]/); if (u) { const [e, t] = u[1].split("="); t || (l += `${o}.removeAttribute('${e}'.replace('%s', light));\n      ${o}.removeAttribute('${e}'.replace('%s', dark));`), l += `\n      ${o}.setAttribute('${e}'.replace('%s', colorScheme), ${t ? `${t}.replace('%s', colorScheme)` : '""'});` } else l += `${o}.setAttribute('${c}', colorScheme);`; return (0, ii.jsx)("script", { suppressHydrationWarning: !0, nonce: "undefined" == typeof window ? s : "", dangerouslySetInnerHTML: { __html: `(function() {\ntry {\n  let colorScheme = '';\n  const mode = localStorage.getItem('${r}') || 'system';\n  const dark = localStorage.getItem('${i}-dark') || '${n}';\n  const light = localStorage.getItem('${i}-light') || '${t}';\n  if (mode === 'system') {\n    // handle system mode\n    const mql = window.matchMedia('(prefers-color-scheme: dark)');\n    if (mql.matches) {\n      colorScheme = dark\n    } else {\n      colorScheme = light\n    }\n  }\n  if (mode === 'light') {\n    colorScheme = light;\n  }\n  if (mode === 'dark') {\n    colorScheme = dark;\n  }\n  if (colorScheme) {\n    ${l}\n  }\n} catch(e){}})();` } }, "mui-color-scheme-init") }({ colorSchemeStorageKey: a, defaultLightColorScheme: d, defaultDarkColorScheme: h, modeStorageKey: i, ...e }) } }({ themeId: qr, theme: () => Qr({ cssVariables: !0 }), colorSchemeStorageKey: TL, modeStorageKey: IL, defaultColorScheme: { light: RL, dark: BL }, resolveTheme: e => { const t = { ...e, typography: _r(e.palette, e.typography) }; return t.unstable_sx = function (e) { return un({ sx: e, theme: this }) }, t } }), kL = PL; function NL({ theme: e, ...t }) { return "function" == typeof e ? (0, ii.jsx)(xL, { theme: e, ...t }) : "colorSchemes" in (qr in e ? e[qr] : e) ? (0, ii.jsx)(kL, { theme: e, ...t }) : (0, ii.jsx)(xL, { theme: e, ...t }) } const FL = Qr({ palette: { mode: "dark" } }), OL = function () { const [e, t] = (0, n.useState)("menu"); return (0, n.useEffect)((() => { document.body.style.overflow = "hidden" })), (0, ii.jsx)(VI, { children: (0, ii.jsx)(NL, { theme: FL, children: (0, ii.jsxs)("div", { className: hL.app, children: [(0, ii.jsx)(ul, { back: () => t("menu"), showBack: "menu" !== e }), "menu" === e ? (0, ii.jsx)(lL, { setMode: t }) : (0, ii.jsx)(YP, { mode: e })] }) }) }) }; a.createRoot(document.getElementById("root")).render((0, ii.jsx)(n.StrictMode, { children: (0, ii.jsx)(OL, {}) }))
  })()
})();